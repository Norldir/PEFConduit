unit undd_ws_layout_4210;

Interface
uses
  Classes,
  JanXMLParser2,
  uxmldsig_core_schema_v1_00,
  uXMLTools;

// targetNameSpace: http://www.nddigital.com.br/nddcargo
// NameSpacePrefix:
// Date of Schema : 16/08/2013 12:06:46
// Translationdate: 16/08/2013 12:07:07
//
//   includes xs=http://www.w3.org/2001/XMLSchema
//   includes ds=http://www.w3.org/2000/09/xmldsig# in 'xmldsig-core-schema_v1.00.pas'

// ordinal types
type
  ttoken = string;
  tbyte = string;
  t = string;

  ttpVersao = ttoken; //Versão do documento. Pode variar para cada tipo de documento. Ex. 2.00
  ttpToken = string; //Token de identificação para permissionamentos.
  ttpGUID = string; //Representa o identificador único.
  ttpSerieOT = string; //Número de série da operação de transporte.
  ttpInt = integer;
  ttpNumeroOT = string; //Número da operação de transporte.
  ttpRateioRetencoes = tbyte; //Define o tipo de rateio das retenções para a operação de transporte. 1 = Primeira, 2 = Última, 3 = Todas e 4 = Não reter.
  ttpRubricaSemMF = tbyte; //Define onde será aplicado o desconto. 1 = Frete, 2 = Combustivel, 3 = Pedágio.
  ttpProprietarioCarga = tbyte; //Determina o porprietário da carga. 1 = Remetente, 2 = Destinatário, 3 = Consignatário e 4 = Outro.
  ttpSimNao = tbyte; //1 = Sim ou 2 = Nao
  ttpCnpj = string; //Número do CNPJ
  ttpNaturezaCarga = string; //Define qual a natureza da carga conforme a tabela de códigos do Sistema Harmonizado de Designação e de Codificação de Mercadorias. Será utilizado os quatro primeiros dígitos.
  ttpDataHora = string; //Tipo data AAAA-MM-DD HH:MM:SS
  ttpData = string; //Tipo data AAAA-MM-DD
  ttpString = string; //Tipo string genérico
  ttpRntrc = string; //RNTRC do transportador.
  ttpRntrc_08 = string; //RNTRC do transportador com oito dígitos..
  ttpDec_1304 = string; //Tipo Decimal com 17 dígitos, sendo 13 de corpo e 4 decimais
  ttpDec_1302 = string; //Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais
  ttpDec_0202 = string; //Tipo Decimal com 4 dígitos, sendo 2 de corpo e 2 decimais
  ttpDec_0502 = string; //Tipo Decimal com 7 dígitos, sendo 5 de corpo e 2 decimais
  ttpDec_0802 = string; //Tipo Decimal com 10 dígitos, sendo 8 de corpo e 2 decimais
  ttpDec_1302Opc = string; //Tipo Decimal com 15 dígitos, sendo 13 de corpo e 2 decimais, utilizado em tags opcionais
  ttpCpf = string; //Número do CPF
  ttpCIOTCodVerificador = string; //Protocolo de autorização disponibilizado pela ANTT.
  ttpNDOPCodVerificador = string; //Protocolo de autorização disponibilizado pela ANTT.
  ttpCIOT = int64; //Código de Identificação da Operação de Transporte
  ttpNDOT = int64; //Número que identifica uma operação de transporte sem CIOT.
  ttpCategoriaPedagio = integer; //Define a categoria para cálculo de pedágio
  ttpTipoRota = tbyte; //Define o tipo de rota. Possibilidades: 1 = rota rápida e 2 = rota curta.
  ttpEmail = string; //Define o campo como sendo um email válido.
  ttpEfetivacaoPagamento = tbyte; //Define o local de efetivação do pagamento da parcela. Possibilidades: 1 = Posto credenciado, 2 = Centro de Triagem, = = Contratante ou 4 = Confirmador
  ttpCriterioRestricao = tbyte; //Define os critérios para a restrição. Possibilidades: 1 = Igual, 2 = Diferente, 3 = Maior, 4 = Maior ou iguak, 5 = Menor e 6 = Menor ou Igual.
  ttpCampoRestricao = tbyte; //Define o campo para comparação na restrição. Possibilidades: 1 = CNPJ do posto credenciado ou 2 = Data.
  ttpConectorRestricao = tbyte; //Define o conector. Possibilidades: 1 = E e 2 = OU.
  ttpUnidadeMedida = string; //Define a unidade de medida para as quantidades de cargas.
  ttpCodigoIBGE = string; //Define o código do IBGE
  ttpRubricaPgto = tbyte; //Define os valores correspondentes as rubricas de pagamento.
  ttpStatusParcela = tbyte; //Indica o status da parcela. 0 = Em aberto, 1 = Aguardando pagamento, 2 = Aguardando solicitação de pagamento, 3 = Paga ou 4 = Cancelada
  ttpStatusOT = tbyte; //Indica o status da operação de transporte. Vigente = 0, Encerrada = 1, Cancelada = 2, Aguardando Vigência = 4, Aberta = 5, Pendente = 6, Em Contingência = 7 ou Rejeitada = 8
  ttpNumeroEndereco = string; //Numero de endereçamento.
  ttpCEP = string; //CEP de endereçamento.
  ttpDescricaoMensagem = string; //Descrição da mensagem de erro
  ttpGestoraCartao = string; //Identificação da gestora de cartão.
  ttpCategoriaTransportador = string; //Indica a categoria do transportador, podendo ser TAC, ETC ou CTC.
  ttpPlacaVeiculo = string; //Indica a placa do veículo.
  ttpStatusOperacaoPagamento = tbyte; //Indica o status da operação de pagamento. Aberto = 0, Pago = 1, Cancelado = 2, Erro = 3.
  ttpTipoOperacao = tbyte; //Tipo da operação que esta sendo realizada. 1 – Adição de condutor, 2 – Remoção de condutor.
  ttpTipoDirecionamentoPedagio = tbyte; //Tipo da operação que esta sendo realizada. 1 – Adição de direcionamento de pedágio, 2 – Remoção de direcionamento de pedágio.
  ttpStatusPagementoPedagio = tbyte; //Tipo da operação que esta sendo realizada. 1 – Aberto, 2 – Pago.
  trotaERP = ttpString; //Nome da rota no ERP para a integração. Caso a tag abaixo seja informada, este será o nome usado para as próximas integrações.
  torigem = ttpString; //Cidade e estado de origem.
  tdestino = ttpString; //Cidade e estado de destino.
  tnome = ttpString; //Nome do estabelecimento.
  tlocalizacao = ttpString; //Localização da praça de pedágio.
  tcategoriaPedagio = ttpCategoriaPedagio; //Se a rota estiver utilizando o  roteirizador é necessário informar qual a categoria para calculo de pedágio. Valor padrão é 0 = Isento
  tpedagioERP = ttpString; //Identificador do direcionamento de pedágio.
  tdescricao = ttpString; //Descrição das despesas que deram origem ao valor.
  tmensagem = ttpDescricaoMensagem; //Descrição da mensagem
  tobservacao = string; //Observacao sobre  a mensagem. Nesta observação é que serão apresentados informações mais técnicas do que está acontecendo
  tidentidade = ttpString; //Identidade do condutor.
  ttelefone = int64; //Telefone celular do condutor.
  tcartaoId = int64; //Identificador do cartão.
  tptEmissor = ttpString; //Ponto emissor que esta realizando o pagamento.
  tcontrato = ttpString; //Informar o número do contrato entre o transportador e a contratante.
  tgestoraCartao = ttpGestoraCartao; //Código de identificação da gestora de cartão que será usada para o pagamento desta. Este campo é opcional porque não precisa ser informado quando a operação for sem movimentação financeira para parcelas e pedágio.
  tplaca = string; //Placa do veículo
  tinscEstadual = ttpString; //Inscrição estadual do transportador.
  temail = ttpEmail; //Email do responsável.
  tmodelo = ttpString; //Modelo do veículo.
  tCNH = int64; //CNH do condutor.
  ttipo = ttpString; //Tipo de documentto.
  tnumero = ttpString; //Descrever qual a numeração do documentos.
  tcontato = ttpString; //Informação de contato que pode ser o telefone ou email.
  tUF = ttpString; //Sigla da UF, , informar EX para operações com o exterior.
  tcidade = ttpString; //Cidade do endereço.
  tbairro = ttpString; //Nome do bairro. Informar EXTERIOR caso seja do exterior.
  tlogradouro = ttpString; //Nome do logradouro. Informar EXTERIOR caso seja do exterior.
  tcomplemento = ttpString; //Complemento
  tcodigoMunicipio = ttpCodigoIBGE; //Código do município (utilizar a tabela do IBGE), informar 9999999 para operações com o exterior.
  tvalor = ttpString; //Va.lor formatado do campo
  tregraERP = ttpString; //Nome da regra de parcelamento no ERP para a integração.
  tnmDesc = ttpString; //Nome do desconto
  tdsDesc = ttpString; //Informações adicionaris para o desconto.
  tcep = string; //CEP do ponto de parada.
  tmotivo = ttpString; //Descrever o motivo da alteração.
  tprotocoloCanc = ttpString; //Protocolo de cancelamento disponibilizado pela ANTT.
  tnomeParcela = ttpString; //Nome da parcela a ser paga.
  tcomentario = ttpString; //Comentário realizado durante a ação que deu origem ao pagamento.
  tSourceId = tbyte; //Identifdicador do sistema que está ntegrando
  tprotocoloEnce = ttpString; //Protocolo de encerramento da operação de transporte.
  tpontoEmissor = string;
  tdescricaoErro = string; //Mensagem de erro
  tnomeImpressora = string;
  tusuarioDocumento = string;
  tcomandosImpressao = string;
  tnomeArquivo = string;
  ttpConteudo = tbyte; //Determina o conteudo que será impresso: 1 - DOT, 2 - Documentos adicionais, 3 - DOT e Documentos adicionais, 4 - NDOP .
  ttpStatusImpressao = tbyte; //Determina o resultado da impressão : 1 - Sucesso, 2 - Erro.
  ttpAgrupar = tbyte; //Agrupar DOT = 1, Não-Agrupar DOT = 0
  turlIntegracao = string;
  tperiodicidade = integer;
  tintervaloConsultaPagamento = integer;
  tversaoProcessamento = string;
  tversaoCorrente = string;
  tintegracao = integer;
  tnomeColaborador = ttpString; //Nome do colaborador vinculado ao cartão.
  tmotivoCancelamento = ttpString; //Motivo do cancelamento da operação de pagamento
  tnomeTransportador = ttpString; //Nome cadastrado do transportador na ANTT.


type
  tBaseNddWS = class
  public
     constructor Create; 
     destructor destroy; override;
  end;

const
  snveiculo_veiculosTransportador = 'veiculo';
  snveiculo_veiculosTransportador_placa = 'placa';
  snveiculo_veiculosTransportador_situacao = 'situacao';

type
  tveiculo_veiculosTransportador = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fplaca: string; // (E)
    Fsituacao: tbyte; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property placa: string read Fplaca write Fplaca; //Indica a placa do veículo.
    property situacao: tbyte read Fsituacao write Fsituacao; //Indica se o veículo pertence ao transportador, sendo 1 = pertence e 2 = não pertence.
  end;

const
  snveiculosTransportador = 'veiculosTransportador';
  snveiculosTransportador_veiculo = 'veiculo';

type
  tveiculosTransportador = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fveiculo: tManagedStringList; // of tveiculo_veiculosTransportador(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property veiculo: tManagedStringList read Fveiculo write Fveiculo; // of tveiculo_veiculosTransportador
  end;

const
  snsituacaoTransportador = 'situacaoTransportador';
  snsituacaoTransportador_dataValidadeRNTRC = 'dataValidadeRNTRC';
  snsituacaoTransportador_categoria = 'categoria';
  snsituacaoTransportador_equiparado = 'equiparado';
  snsituacaoTransportador_cadastradonddCargo = 'cadastradonddCargo';

type
  tsituacaoTransportador = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FdataValidadeRNTRC: string; // (E)
    Fcategoria: string; // (E)
    Fequiparado: tbyte; // (E)
    FcadastradonddCargo: tbyte; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataValidadeRNTRC: string read FdataValidadeRNTRC write FdataValidadeRNTRC; //Data de validade do RNTRC do transportador.
    property categoria: string read Fcategoria write Fcategoria; //Indica a categoria do transportador, podendo ser TAC, ETC ou CTC.
    property equiparado: tbyte read Fequiparado write Fequiparado; //Indica se o transportador está equiparado ao TAC. 1 = pertence e 2 = não pertence.
    property cadastradonddCargo: tbyte read FcadastradonddCargo write FcadastradonddCargo; //Indica se o transportador está cadastrado no nddCargo. 1 = cadastrado e 2 = não cadastrado.
  end;

const
  snveiculo_veiculos_tpConsultaANTTVeiculosTransportador = 'veiculo';
  snveiculo_veiculos_tpConsultaANTTVeiculosTransportador_placa = 'placa';

type
  tveiculo_veiculos_tpConsultaANTTVeiculosTransportador = class( tBaseNddWS ) // Dados do veículo
  private
    F_NameSpaceAlias: string;
    Fplaca: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property placa: string read Fplaca write Fplaca; //Placa do veículo
  end;

const
  snveiculos_tpConsultaANTTVeiculosTransportador = 'veiculos';
  snveiculos_tpConsultaANTTVeiculosTransportador_veiculo = 'veiculo';

type
  tveiculos_tpConsultaANTTVeiculosTransportador = class( tBaseNddWS ) // Lista de veículos do transportador.
  private
    F_NameSpaceAlias: string;
    Fveiculo: tManagedStringList; // of tveiculo_veiculos_tpConsultaANTTVeiculosTransportador(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property veiculo: tManagedStringList read Fveiculo write Fveiculo; // of tveiculo_veiculos_tpConsultaANTTVeiculosTransportador
  end;

const
  sntpConsultaANTTVeiculosTransportador = 'tpConsultaANTTVeiculosTransportador';
  sntpConsultaANTTVeiculosTransportador_RNTRC = 'RNTRC';
  sntpConsultaANTTVeiculosTransportador_cpf = 'cpf';
  sntpConsultaANTTVeiculosTransportador_cnpj = 'cnpj';
  sntpConsultaANTTVeiculosTransportador_veiculos = 'veiculos';

type
  ttpConsultaANTTVeiculosTransportador = class( tBaseNddWS ) // Dados da consulta de veículos do transportador na ANTT.
  private
    F_NameSpaceAlias: string;
    FRNTRC: string; // (E)
    Fcpf: string; // (E)
    Fcpf_IsSet_: boolean;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    Fveiculos: tveiculos_tpConsultaANTTVeiculosTransportador; // (E)
    procedure Setcpf(value:string);
    procedure Setcnpj(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property RNTRC: string read FRNTRC write FRNTRC; //RNTRC do transporador.
    property cpf: string read Fcpf write Setcpf; //CPF do transportador.
    property cpf_IsSet_:boolean read Fcpf_IsSet_;
    property cnpj: string read Fcnpj write Setcnpj; //CNPJ do transportador.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
    property veiculos: tveiculos_tpConsultaANTTVeiculosTransportador read Fveiculos; // write Fveiculos;
  end;

const
  sntpConsultaANTTSituacaoTransporador = 'tpConsultaANTTSituacaoTransporador';
  sntpConsultaANTTSituacaoTransporador_RNTRC = 'RNTRC';
  sntpConsultaANTTSituacaoTransporador_cpf = 'cpf';
  sntpConsultaANTTSituacaoTransporador_cnpj = 'cnpj';

type
  ttpConsultaANTTSituacaoTransporador = class( tBaseNddWS ) // Dados da consulta de situação do transportador na ANTT.
  private
    F_NameSpaceAlias: string;
    FRNTRC: string; // (E)
    Fcpf: string; // (E)
    Fcpf_IsSet_: boolean;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    procedure Setcpf(value:string);
    procedure Setcnpj(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property RNTRC: string read FRNTRC write FRNTRC; //RNTRC do transportador.
    property cpf: string read Fcpf write Setcpf; //CPF do transportador.
    property cpf_IsSet_:boolean read Fcpf_IsSet_;
    property cnpj: string read Fcnpj write Setcnpj; //CNPJ do transportador.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
  end;

const
  sntpEnvioConsultaANTTDetalhe = 'tpEnvioConsultaANTTDetalhe';
  sntpEnvioConsultaANTTDetalhe_cnpj = 'cnpj';
  sntpEnvioConsultaANTTDetalhe_situacaoTransportador = 'situacaoTransportador';
  sntpEnvioConsultaANTTDetalhe_veiculosTransportador = 'veiculosTransportador';
  antpEnvioConsultaANTTDetalhe_versao = 'versao';
  antpEnvioConsultaANTTDetalhe_token = 'token';

type
  ttpEnvioConsultaANTTDetalhe = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FsituacaoTransportador: ttpConsultaANTTSituacaoTransporador; // (E)
    FsituacaoTransportador_IsSet_: boolean;
    FveiculosTransportador: ttpConsultaANTTVeiculosTransportador; // (E)
    FveiculosTransportador_IsSet_: boolean;
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure SetsituacaoTransportador(value:ttpConsultaANTTSituacaoTransporador);
    procedure SetveiculosTransportador(value:ttpConsultaANTTVeiculosTransportador);
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante.
    property situacaoTransportador: ttpConsultaANTTSituacaoTransporador read FsituacaoTransportador write SetsituacaoTransportador; //Consulta a situação do transportador na ANTT.
    property situacaoTransportador_IsSet_:boolean read FsituacaoTransportador_IsSet_;
    property veiculosTransportador: ttpConsultaANTTVeiculosTransportador read FveiculosTransportador write SetveiculosTransportador; //Consulta os veículos do transportador na ANTT.
    property veiculosTransportador_IsSet_:boolean read FveiculosTransportador_IsSet_;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sntpConsultaANTTDetalhe = 'tpConsultaANTTDetalhe';
  sntpConsultaANTTDetalhe_situacaoTransportador = 'situacaoTransportador';
  sntpConsultaANTTDetalhe_veiculosTransportador = 'veiculosTransportador';

type
  ttpConsultaANTTDetalhe = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FsituacaoTransportador: ttpConsultaANTTSituacaoTransporador; // (E)
    FsituacaoTransportador_IsSet_: boolean;
    FveiculosTransportador: ttpConsultaANTTVeiculosTransportador; // (E)
    FveiculosTransportador_IsSet_: boolean;
    procedure SetsituacaoTransportador(value:ttpConsultaANTTSituacaoTransporador);
    procedure SetveiculosTransportador(value:ttpConsultaANTTVeiculosTransportador);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property situacaoTransportador: ttpConsultaANTTSituacaoTransporador read FsituacaoTransportador write SetsituacaoTransportador; //Consulta a situação do transportador na ANTT.
    property situacaoTransportador_IsSet_:boolean read FsituacaoTransportador_IsSet_;
    property veiculosTransportador: ttpConsultaANTTVeiculosTransportador read FveiculosTransportador write SetveiculosTransportador; //Consulta os veículos do transportador na ANTT.
    property veiculosTransportador_IsSet_:boolean read FveiculosTransportador_IsSet_;
  end;

const
  sninfConsultasANTT = 'infConsultasANTT';
  sninfConsultasANTT_cnpj = 'cnpj';
  sninfConsultasANTT_consultaANTT = 'consultaANTT';

type
  tinfConsultasANTT = class( tBaseNddWS ) // Lista de consultas a serem feitas na ANTT.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FconsultaANTT: tManagedStringList; // of ttpConsultaANTTDetalhe(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante.
    property consultaANTT: tManagedStringList read FconsultaANTT write FconsultaANTT; // of ttpConsultaANTTDetalhe
  end;

const
  sntpConsultaANTT = 'tpConsultaANTT';
  sntpConsultaANTT_infConsultasANTT = 'infConsultasANTT';
  antpConsultaANTT_versao = 'versao';
  antpConsultaANTT_token = 'token';

type
  ttpConsultaANTT = class( tBaseNddWS ) // Consulta de informações na ANTT.
  private
    F_NameSpaceAlias: string;
    FinfConsultasANTT: tinfConsultasANTT; // (E)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infConsultasANTT: tinfConsultasANTT read FinfConsultasANTT; // write FinfConsultasANTT;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  snide_autorizacao_tpInfRetornoCancelarOperacaoPagamento = 'ide';
  snide_autorizacao_tpInfRetornoCancelarOperacaoPagamento_numero = 'numero';
  snide_autorizacao_tpInfRetornoCancelarOperacaoPagamento_serie = 'serie';

type
  tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: string; // (E)
    Fserie: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: string read Fnumero write Fnumero; //Número da operação de pagamento.
    property serie: string read Fserie write Fserie; //Série da operação de pagamento.
  end;

const
  snndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento = 'ndop';
  snndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento_numero = 'numero';
  snndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento_ndopCodVerificador = 'ndopCodVerificador';

type
  tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FndopCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Número que identifica a operação de pagamento.
    property ndopCodVerificador: string read FndopCodVerificador write FndopCodVerificador; //Protocolo de autorização disponibilizado para o NDOP.
  end;

const
  snautorizacao_tpInfRetornoCancelarOperacaoPagamento = 'autorizacao';
  snautorizacao_tpInfRetornoCancelarOperacaoPagamento_ndop = 'ndop';
  snautorizacao_tpInfRetornoCancelarOperacaoPagamento_ide = 'ide';

type
  tautorizacao_tpInfRetornoCancelarOperacaoPagamento = class( tBaseNddWS ) // Dados da autorização da operação de pagamento.
  private
    F_NameSpaceAlias: string;
    Fndop: tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento; // (E)
    Fndop_IsSet_: boolean;
    Fide: tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento; // (E)
    Fide_IsSet_: boolean;
    procedure Setndop(value:tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento);
    procedure Setide(value:tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ndop: tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento read Fndop write Setndop;
    property ndop_IsSet_:boolean read Fndop_IsSet_;
    property ide: tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento read Fide write Setide;
    property ide_IsSet_:boolean read Fide_IsSet_;
  end;

const
  sntpInfRetornoCancelarOperacaoPagamento = 'tpInfRetornoCancelarOperacaoPagamento';
  sntpInfRetornoCancelarOperacaoPagamento_cnpj = 'cnpj';
  sntpInfRetornoCancelarOperacaoPagamento_autorizacao = 'autorizacao';
  sntpInfRetornoCancelarOperacaoPagamento_motivoCancelamento = 'motivoCancelamento';
  antpInfRetornoCancelarOperacaoPagamento_ID = 'Id';
  antpInfRetornoCancelarOperacaoPagamento_token = 'token';

type
  ttpInfRetornoCancelarOperacaoPagamento = class( tBaseNddWS ) // Consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: tautorizacao_tpInfRetornoCancelarOperacaoPagamento; // (E)
    FmotivoCancelamento: string; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure SetID(value:string);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //Cnpj da contratante.
    property autorizacao: tautorizacao_tpInfRetornoCancelarOperacaoPagamento read Fautorizacao; // write Fautorizacao;
    property motivoCancelamento: string read FmotivoCancelamento write FmotivoCancelamento; //Motivo do cancelamento da operação de pagamento
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  snide_autorizacao_tpInfCancelarOperacaoPagamento = 'ide';
  snide_autorizacao_tpInfCancelarOperacaoPagamento_numero = 'numero';
  snide_autorizacao_tpInfCancelarOperacaoPagamento_serie = 'serie';

type
  tide_autorizacao_tpInfCancelarOperacaoPagamento = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: string; // (E)
    Fserie: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: string read Fnumero write Fnumero; //Número da operação de pagamento.
    property serie: string read Fserie write Fserie; //Série da operação de pagamento.
  end;

const
  snndop_autorizacao_tpInfCancelarOperacaoPagamento = 'ndop';
  snndop_autorizacao_tpInfCancelarOperacaoPagamento_numero = 'numero';
  snndop_autorizacao_tpInfCancelarOperacaoPagamento_ndopCodVerificador = 'ndopCodVerificador';

type
  tndop_autorizacao_tpInfCancelarOperacaoPagamento = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FndopCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Número que identifica a operação de pagamento.
    property ndopCodVerificador: string read FndopCodVerificador write FndopCodVerificador; //Protocolo de autorização disponibilizado para o NDOP.
  end;

const
  snautorizacao_tpInfCancelarOperacaoPagamento = 'autorizacao';
  snautorizacao_tpInfCancelarOperacaoPagamento_ndop = 'ndop';
  snautorizacao_tpInfCancelarOperacaoPagamento_ide = 'ide';

type
  tautorizacao_tpInfCancelarOperacaoPagamento = class( tBaseNddWS ) // Dados da autorização da operação de pagamento.
  private
    F_NameSpaceAlias: string;
    Fndop: tndop_autorizacao_tpInfCancelarOperacaoPagamento; // (E)
    Fndop_IsSet_: boolean;
    Fide: tide_autorizacao_tpInfCancelarOperacaoPagamento; // (E)
    Fide_IsSet_: boolean;
    procedure Setndop(value:tndop_autorizacao_tpInfCancelarOperacaoPagamento);
    procedure Setide(value:tide_autorizacao_tpInfCancelarOperacaoPagamento);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ndop: tndop_autorizacao_tpInfCancelarOperacaoPagamento read Fndop write Setndop;
    property ndop_IsSet_:boolean read Fndop_IsSet_;
    property ide: tide_autorizacao_tpInfCancelarOperacaoPagamento read Fide write Setide;
    property ide_IsSet_:boolean read Fide_IsSet_;
  end;

const
  sntpInfCancelarOperacaoPagamento = 'tpInfCancelarOperacaoPagamento';
  sntpInfCancelarOperacaoPagamento_cnpj = 'cnpj';
  sntpInfCancelarOperacaoPagamento_autorizacao = 'autorizacao';
  sntpInfCancelarOperacaoPagamento_motivoCancelamento = 'motivoCancelamento';
  antpInfCancelarOperacaoPagamento_ID = 'Id';

type
  ttpInfCancelarOperacaoPagamento = class( tBaseNddWS ) // Consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: tautorizacao_tpInfCancelarOperacaoPagamento; // (E)
    FmotivoCancelamento: string; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //Cnpj da contratante.
    property autorizacao: tautorizacao_tpInfCancelarOperacaoPagamento read Fautorizacao; // write Fautorizacao;
    property motivoCancelamento: string read FmotivoCancelamento write FmotivoCancelamento; //Motivo do cancelamento da operação de pagamento
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  sntpCancelarOperacaoPagamento = 'tpCancelarOperacaoPagamento';
  sntpCancelarOperacaoPagamento_infCancelarOperacaoPagamento = 'infCancelarOperacaoPagamento';
  sntpCancelarOperacaoPagamento_Signature = 'Signature';
  antpCancelarOperacaoPagamento_versao = 'versao';
  antpCancelarOperacaoPagamento_token = 'token';

type
  ttpCancelarOperacaoPagamento = class( tBaseNddWS ) // Dados de envio para o cancelamento de operação de pagamento.
  private
    F_NameSpaceAlias: string;
    FinfCancelarOperacaoPagamento: ttpInfCancelarOperacaoPagamento; // (E)
    FSignature: tSignature; // (X)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infCancelarOperacaoPagamento: ttpInfCancelarOperacaoPagamento read FinfCancelarOperacaoPagamento; // write FinfCancelarOperacaoPagamento; //Informações do cancelamento da operação de pagamento.
    property Signature: tSignature read FSignature; // write FSignature;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  snsaldo_tpRetornoOperacaoPagamentoDetalhe = 'saldo';
  snsaldo_tpRetornoOperacaoPagamentoDetalhe_saldoDisponivel = 'saldoDisponivel';
  snsaldo_tpRetornoOperacaoPagamentoDetalhe_dataConsulta = 'dataConsulta';

type
  tsaldo_tpRetornoOperacaoPagamentoDetalhe = class( tBaseNddWS ) // Informações do cartão ativo do colaborador.
  private
    F_NameSpaceAlias: string;
    FsaldoDisponivel: string; // (E)
    FdataConsulta: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property saldoDisponivel: string read FsaldoDisponivel write FsaldoDisponivel; //Saldo disponível no cartão.
    property dataConsulta: string read FdataConsulta write FdataConsulta; //Data que foi realizada a consulta.
  end;

const
  snpedagio_tpRetornoOperacaoPagamentoDetalhe = 'pedagio';

type
  tpedagio_tpRetornoOperacaoPagamentoDetalhe = class( tBaseNddWS ) // Dados refetentes ao pedágio.
  private
    F_NameSpaceAlias: string;
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
  end;

const
  snndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe = 'ndop';
  snndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe_numero = 'numero';
  snndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe_ndopCodVerificador = 'ndopCodVerificador';

type
  tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FndopCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Número que identifica a operação de pagamento.
    property ndopCodVerificador: string read FndopCodVerificador write FndopCodVerificador; //Protocolo de autorização disponibilizado para o NDOP.
  end;

const
  snautorizacao_tpRetornoOperacaoPagamentoDetalhe = 'autorizacao';
  snautorizacao_tpRetornoOperacaoPagamentoDetalhe_ndop = 'ndop';

type
  tautorizacao_tpRetornoOperacaoPagamentoDetalhe = class( tBaseNddWS ) // Dados da autorização do pagamento.
  private
    F_NameSpaceAlias: string;
    Fndop: tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ndop: tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe read Fndop; // write Fndop;
  end;

const
  snsaldo_tpDetalheRetornoOperacaoPagamento = 'saldo';
  snsaldo_tpDetalheRetornoOperacaoPagamento_saldoDisponivel = 'saldoDisponivel';
  snsaldo_tpDetalheRetornoOperacaoPagamento_dataConsulta = 'dataConsulta';

type
  tsaldo_tpDetalheRetornoOperacaoPagamento = class( tBaseNddWS ) // Informações do cartão ativo do colaborador.
  private
    F_NameSpaceAlias: string;
    FsaldoDisponivel: string; // (E)
    FdataConsulta: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property saldoDisponivel: string read FsaldoDisponivel write FsaldoDisponivel; //Saldo disponível no cartão.
    property dataConsulta: string read FdataConsulta write FdataConsulta; //Data que foi realizada a consulta.
  end;

const
  snpedagio_tpDetalheRetornoOperacaoPagamento = 'pedagio';

type
  tpedagio_tpDetalheRetornoOperacaoPagamento = class( tBaseNddWS ) // Dados refetentes ao pedágio.
  private
    F_NameSpaceAlias: string;
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
  end;

const
  snndop_autorizacao_tpDetalheRetornoOperacaoPagamento = 'ndop';
  snndop_autorizacao_tpDetalheRetornoOperacaoPagamento_numero = 'numero';
  snndop_autorizacao_tpDetalheRetornoOperacaoPagamento_ndopCodVerificador = 'ndopCodVerificador';

type
  tndop_autorizacao_tpDetalheRetornoOperacaoPagamento = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FndopCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Número que identifica a operação de pagamento.
    property ndopCodVerificador: string read FndopCodVerificador write FndopCodVerificador; //Protocolo de autorização disponibilizado para o NDOP.
  end;

const
  snautorizacao_tpDetalheRetornoOperacaoPagamento = 'autorizacao';
  snautorizacao_tpDetalheRetornoOperacaoPagamento_ndop = 'ndop';

type
  tautorizacao_tpDetalheRetornoOperacaoPagamento = class( tBaseNddWS ) // Dados da autorização do pagamento.
  private
    F_NameSpaceAlias: string;
    Fndop: tndop_autorizacao_tpDetalheRetornoOperacaoPagamento; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ndop: tndop_autorizacao_tpDetalheRetornoOperacaoPagamento read Fndop; // write Fndop;
  end;

const
  snide_autorizacao_tpInfRetornoConsultaOperacaoPagamento = 'ide';
  snide_autorizacao_tpInfRetornoConsultaOperacaoPagamento_numero = 'numero';
  snide_autorizacao_tpInfRetornoConsultaOperacaoPagamento_serie = 'serie';

type
  tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: string; // (E)
    Fserie: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: string read Fnumero write Fnumero; //Número da operação de pagamento.
    property serie: string read Fserie write Fserie; //Série da operação de pagamento.
  end;

const
  snndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento = 'ndop';
  snndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento_numero = 'numero';
  snndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento_ndopCodVerificador = 'ndopCodVerificador';

type
  tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FndopCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Número que identifica a operação de pagamento.
    property ndopCodVerificador: string read FndopCodVerificador write FndopCodVerificador; //Protocolo de autorização disponibilizado para o NDOP.
  end;

const
  snautorizacao_tpInfRetornoConsultaOperacaoPagamento = 'autorizacao';
  snautorizacao_tpInfRetornoConsultaOperacaoPagamento_ndop = 'ndop';
  snautorizacao_tpInfRetornoConsultaOperacaoPagamento_ide = 'ide';

type
  tautorizacao_tpInfRetornoConsultaOperacaoPagamento = class( tBaseNddWS ) // Dados da autorização do pagamento.
  private
    F_NameSpaceAlias: string;
    Fndop: tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento; // (E)
    Fndop_IsSet_: boolean;
    Fide: tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento; // (E)
    Fide_IsSet_: boolean;
    procedure Setndop(value:tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento);
    procedure Setide(value:tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ndop: tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento read Fndop write Setndop;
    property ndop_IsSet_:boolean read Fndop_IsSet_;
    property ide: tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento read Fide write Setide;
    property ide_IsSet_:boolean read Fide_IsSet_;
  end;

const
  sntpInfRetornoConsultaOperacaoPagamento = 'tpInfRetornoConsultaOperacaoPagamento';
  sntpInfRetornoConsultaOperacaoPagamento_cnpj = 'cnpj';
  sntpInfRetornoConsultaOperacaoPagamento_autorizacao = 'autorizacao';
  antpInfRetornoConsultaOperacaoPagamento_ID = 'Id';
  antpInfRetornoConsultaOperacaoPagamento_token = 'token';

type
  ttpInfRetornoConsultaOperacaoPagamento = class( tBaseNddWS ) // Consulta da operação de pagamento.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: tautorizacao_tpInfRetornoConsultaOperacaoPagamento; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure SetID(value:string);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //Cnpj da contratante que esta realizando a consulta.
    property autorizacao: tautorizacao_tpInfRetornoConsultaOperacaoPagamento read Fautorizacao; // write Fautorizacao;
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  snide_autorizacao = 'ide';
  snide_autorizacao_numero = 'numero';
  snide_autorizacao_serie = 'serie';

type
  tide_autorizacao = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: string; // (E)
    Fserie: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: string read Fnumero write Fnumero; //Número da operação de pagamento.
    property serie: string read Fserie write Fserie; //Série da operação de pagamento.
  end;

const
  snndop_autorizacao = 'ndop';
  snndop_autorizacao_numero = 'numero';
  snndop_autorizacao_ndopCodVerificador = 'ndopCodVerificador';

type
  tndop_autorizacao = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FndopCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Número que identifica a operação de pagamento.
    property ndopCodVerificador: string read FndopCodVerificador write FndopCodVerificador; //Protocolo de autorização disponibilizado para o NDOP.
  end;

const
  snautorizacao = 'autorizacao';
  snautorizacao_ndop = 'ndop';
  snautorizacao_ide = 'ide';

type
  tautorizacao = class( tBaseNddWS ) // Dados da autorização do pagamento.
  private
    F_NameSpaceAlias: string;
    Fndop: tndop_autorizacao; // (E)
    Fndop_IsSet_: boolean;
    Fide: tide_autorizacao; // (E)
    Fide_IsSet_: boolean;
    procedure Setndop(value:tndop_autorizacao);
    procedure Setide(value:tide_autorizacao);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ndop: tndop_autorizacao read Fndop write Setndop;
    property ndop_IsSet_:boolean read Fndop_IsSet_;
    property ide: tide_autorizacao read Fide write Setide;
    property ide_IsSet_:boolean read Fide_IsSet_;
  end;

const
  sntpInfConsultaOperacaoPagamento = 'tpInfConsultaOperacaoPagamento';
  sntpInfConsultaOperacaoPagamento_cnpj = 'cnpj';
  sntpInfConsultaOperacaoPagamento_autorizacao = 'autorizacao';
  antpInfConsultaOperacaoPagamento_ID = 'Id';

type
  ttpInfConsultaOperacaoPagamento = class( tBaseNddWS ) // Consulta da operação de pagamento.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: tautorizacao; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //Cnpj da contratante que esta realizando a consulta.
    property autorizacao: tautorizacao read Fautorizacao; // write Fautorizacao;
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  sntpConsultaOperacaoPagamento = 'tpConsultaOperacaoPagamento';
  sntpConsultaOperacaoPagamento_infResumoOperacaoPagamento = 'infResumoOperacaoPagamento';
  sntpConsultaOperacaoPagamento_Signature = 'Signature';
  antpConsultaOperacaoPagamento_versao = 'versao';
  antpConsultaOperacaoPagamento_token = 'token';

type
  ttpConsultaOperacaoPagamento = class( tBaseNddWS ) // Consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FinfResumoOperacaoPagamento: ttpInfConsultaOperacaoPagamento; // (E)
    FSignature: tSignature; // (X)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infResumoOperacaoPagamento: ttpInfConsultaOperacaoPagamento read FinfResumoOperacaoPagamento; // write FinfResumoOperacaoPagamento;
    property Signature: tSignature read FSignature; // write FSignature;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  snpagamento_tpInfRetornoOperacaoPagamento = 'pagamento';
  snpagamento_tpInfRetornoOperacaoPagamento_gestoraCartao = 'gestoraCartao';
  snpagamento_tpInfRetornoOperacaoPagamento_valor = 'valor';
  snpagamento_tpInfRetornoOperacaoPagamento_valorPedagio = 'valorPedagio';

type
  tpagamento_tpInfRetornoOperacaoPagamento = class( tBaseNddWS ) // Informações sobre o pagamento.
  private
    F_NameSpaceAlias: string;
    FgestoraCartao: string; // (E)
    Fvalor: string; // (E)
    Fvalor_IsSet_: boolean;
    FvalorPedagio: string; // (E)
    FvalorPedagio_IsSet_: boolean;
    procedure Setvalor(value:string);
    procedure SetvalorPedagio(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property gestoraCartao: string read FgestoraCartao write FgestoraCartao; //Gestora de cartão do cartão ativo do colaborador.
    property valor: string read Fvalor write Setvalor; //Valor que esta sendo pago. Este campo será considerado obrigatório caso não seja informado o campo valorPedagio.
    property valor_IsSet_:boolean read Fvalor_IsSet_;
    property valorPedagio: string read FvalorPedagio write SetvalorPedagio; //Valor que esta sendo pago como pedágio.
    property valorPedagio_IsSet_:boolean read FvalorPedagio_IsSet_;
  end;

const
  snide_tpInfRetornoOperacaoPagamento = 'ide';
  snide_tpInfRetornoOperacaoPagamento_cnpj = 'cnpj';
  snide_tpInfRetornoOperacaoPagamento_ptEmissor = 'ptEmissor';
  snide_tpInfRetornoOperacaoPagamento_numero = 'numero';
  snide_tpInfRetornoOperacaoPagamento_serie = 'serie';

type
  tide_tpInfRetornoOperacaoPagamento = class( tBaseNddWS ) // Informações da contratante que esta realizando o pagamento.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FptEmissor: string; // (E)
    Fnumero: string; // (E)
    Fserie: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //Cnpj da contratante que esta realizando o pagamento.
    property ptEmissor: string read FptEmissor write FptEmissor; //Ponto emissor que esta realizando o pagamento.
    property numero: string read Fnumero write Fnumero; //Número para a operação de pagamento.
    property serie: string read Fserie write Fserie; //Série da operação de pagamento.
  end;

const
  snpagamento = 'pagamento';
  snpagamento_gestoraCartao = 'gestoraCartao';
  snpagamento_valor = 'valor';
  snpagamento_valorPedagio = 'valorPedagio';

type
  tpagamento = class( tBaseNddWS ) // Informações sobre o pagamento.
  private
    F_NameSpaceAlias: string;
    FgestoraCartao: string; // (E)
    Fvalor: string; // (E)
    Fvalor_IsSet_: boolean;
    FvalorPedagio: string; // (E)
    FvalorPedagio_IsSet_: boolean;
    procedure Setvalor(value:string);
    procedure SetvalorPedagio(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property gestoraCartao: string read FgestoraCartao write FgestoraCartao; //Gestora de cartão do cartão ativo do colaborador.
    property valor: string read Fvalor write Setvalor; //Valor que esta sendo pago. Este campo será considerado obrigatório caso não seja informado o campo valorPedagio.
    property valor_IsSet_:boolean read Fvalor_IsSet_;
    property valorPedagio: string read FvalorPedagio write SetvalorPedagio; //Valor que esta sendo pago como pedágio.
    property valorPedagio_IsSet_:boolean read FvalorPedagio_IsSet_;
  end;

const
  snide_tpInfOperacaoPagamento = 'ide';
  snide_tpInfOperacaoPagamento_cnpj = 'cnpj';
  snide_tpInfOperacaoPagamento_ptEmissor = 'ptEmissor';
  snide_tpInfOperacaoPagamento_numero = 'numero';
  snide_tpInfOperacaoPagamento_serie = 'serie';

type
  tide_tpInfOperacaoPagamento = class( tBaseNddWS ) // Informações da contratante que esta realizando o pagamento.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FptEmissor: string; // (E)
    Fnumero: string; // (E)
    Fserie: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //Cnpj da contratante que esta realizando o pagamento.
    property ptEmissor: string read FptEmissor write FptEmissor; //Ponto emissor que esta realizando o pagamento.
    property numero: string read Fnumero write Fnumero; //Número para a operação de pagamento.
    property serie: string read Fserie write Fserie; //Série da operação de pagamento.
  end;

const
  snsaldo = 'saldo';
  snsaldo_saldoPedagioDisponivel = 'saldoPedagioDisponivel';
  snsaldo_saldoDisponivel = 'saldoDisponivel';
  snsaldo_dataConsulta = 'dataConsulta';

type
  tsaldo = class( tBaseNddWS ) // Informações do cartão ativo do colaborador.
  private
    F_NameSpaceAlias: string;
    FsaldoPedagioDisponivel: string; // (E)
    FsaldoDisponivel: string; // (E)
    FdataConsulta: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property saldoPedagioDisponivel: string read FsaldoPedagioDisponivel write FsaldoPedagioDisponivel; //Valor de pedágio disponível para carga.
    property saldoDisponivel: string read FsaldoDisponivel write FsaldoDisponivel; //Saldo disponível no cartão.
    property dataConsulta: string read FdataConsulta write FdataConsulta; //Data que foi realizada a consulta.
  end;

const
  sntpInfConsultaSaldoCartaoFrota = 'tpInfConsultaSaldoCartaoFrota';
  sntpInfConsultaSaldoCartaoFrota_cpfColaborador = 'cpfColaborador';
  sntpInfConsultaSaldoCartaoFrota_cartaoId = 'cartaoId';

type
  ttpInfConsultaSaldoCartaoFrota = class( tBaseNddWS ) // Informações da consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FcpfColaborador: string; // (E)
    FcpfColaborador_IsSet_: boolean;
    FcartaoId: int64; // (E)
    procedure SetcpfColaborador(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cpfColaborador: string read FcpfColaborador write SetcpfColaborador; //CPF do colaborador.
    property cpfColaborador_IsSet_:boolean read FcpfColaborador_IsSet_;
    property cartaoId: int64 read FcartaoId write FcartaoId; //Identificador do cartão.
  end;

const
  sninfLote_envioConsulta = 'infLote';
  sninfLote_envioConsulta_cnpjContratante = 'cnpjContratante';
  sninfLote_envioConsulta_gestoraCartao = 'gestoraCartao';
  sninfLote_envioConsulta_ide = 'ide';
  aninfLote_envioConsulta_versao = 'versao';
  aninfLote_envioConsulta_token = 'token';

type
  tinfLote_envioConsulta = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FcnpjContratante: string; // (E)
    FgestoraCartao: string; // (E)
    Fide: tManagedStringList; // of ttpInfConsultaSaldoCartaoFrota(E)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpjContratante: string read FcnpjContratante write FcnpjContratante; //Cnpj da contratante.
    property gestoraCartao: string read FgestoraCartao write FgestoraCartao; //Gestora de cartão.
    property ide: tManagedStringList read Fide write Fide; // of ttpInfConsultaSaldoCartaoFrota
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  snenvioConsulta = 'envioConsulta';
  snenvioConsulta_infLote = 'infLote';

type
  tenvioConsulta = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FinfLote: tinfLote_envioConsulta; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infLote: tinfLote_envioConsulta read FinfLote; // write FinfLote;
  end;

const
  sninfLote = 'infLote';
  sninfLote_cnpj = 'cnpj';
  sninfLote_gestoraCartao = 'gestoraCartao';
  sninfLote_ide = 'ide';
  aninfLote_ID = 'Id';

type
  tinfLote = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FgestoraCartao: string; // (E)
    Fide: tManagedStringList; // of ttpInfConsultaSaldoCartaoFrota(E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //Cnpj da contratante.
    property gestoraCartao: string read FgestoraCartao write FgestoraCartao; //Gestora de cartão dos cartões que serão consultados.
    property ide: tManagedStringList read Fide write Fide; // of ttpInfConsultaSaldoCartaoFrota
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  sntpConsultaSaldoCartaoFrota = 'tpConsultaSaldoCartaoFrota';
  sntpConsultaSaldoCartaoFrota_infLote = 'infLote';
  sntpConsultaSaldoCartaoFrota_Signature = 'Signature';
  antpConsultaSaldoCartaoFrota_versao = 'versao';
  antpConsultaSaldoCartaoFrota_token = 'token';

type
  ttpConsultaSaldoCartaoFrota = class( tBaseNddWS ) // Consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FinfLote: tinfLote; // (E)
    FSignature: tSignature; // (X)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infLote: tinfLote read FinfLote; // write FinfLote;
    property Signature: tSignature read FSignature; // write FSignature;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sncondutor_condutores_tpInfRetornoConsultaResumoOT = 'condutor';
  sncondutor_condutores_tpInfRetornoConsultaResumoOT_cpf = 'cpf';
  sncondutor_condutores_tpInfRetornoConsultaResumoOT_nome = 'nome';

type
  tcondutor_condutores_tpInfRetornoConsultaResumoOT = class( tBaseNddWS ) // Dados do condutor
  private
    F_NameSpaceAlias: string;
    Fcpf: string; // (E)
    Fnome: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cpf: string read Fcpf write Fcpf; //Número do CPF do condutor.
    property nome: string read Fnome write Fnome; //Nome do condutor.
  end;

const
  sncondutores_tpInfRetornoConsultaResumoOT = 'condutores';
  sncondutores_tpInfRetornoConsultaResumoOT_condutor = 'condutor';

type
  tcondutores_tpInfRetornoConsultaResumoOT = class( tBaseNddWS ) // Dados dos condutores
  private
    F_NameSpaceAlias: string;
    Fcondutor: tManagedStringList; // of tcondutor_condutores_tpInfRetornoConsultaResumoOT(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property condutor: tManagedStringList read Fcondutor write Fcondutor; // of tcondutor_condutores_tpInfRetornoConsultaResumoOT
  end;

const
  snparcela_parcelas_tpInfRetornoConsultaResumoOT = 'parcela';
  snparcela_parcelas_tpInfRetornoConsultaResumoOT_nome = 'nome';
  snparcela_parcelas_tpInfRetornoConsultaResumoOT_valorReal = 'valorReal';
  snparcela_parcelas_tpInfRetornoConsultaResumoOT_valorAplicado = 'valorAplicado';
  snparcela_parcelas_tpInfRetornoConsultaResumoOT_dataPrevisao = 'dataPrevisao';
  snparcela_parcelas_tpInfRetornoConsultaResumoOT_dataPagamento = 'dataPagamento';
  snparcela_parcelas_tpInfRetornoConsultaResumoOT_status = 'status';

type
  tparcela_parcelas_tpInfRetornoConsultaResumoOT = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    FvalorReal: string; // (E)
    FvalorAplicado: string; // (E)
    FdataPrevisao: string; // (E)
    FdataPagamento: string; // (E)
    FdataPagamento_IsSet_: boolean;
    Fstatus: tbyte; // (E)
    procedure SetdataPagamento(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome para apresentação da parcela dentro do sistema.
    property valorReal: string read FvalorReal write FvalorReal; //Valor real para pagamento da parcela.
    property valorAplicado: string read FvalorAplicado write FvalorAplicado; //Valor aplicado para a parcela. Não levando em consideração os descontos.
    property dataPrevisao: string read FdataPrevisao write FdataPrevisao; //Data prevista para o pagamento. Padrão AAAA-MM-DD
    property dataPagamento: string read FdataPagamento write SetdataPagamento; //Data e hora de efetivação do pagamento.
    property dataPagamento_IsSet_:boolean read FdataPagamento_IsSet_;
    property status: tbyte read Fstatus write Fstatus; //Indica o status da parcela. 0 = Em aberto, 1 = Aguardando pagamento, 2 = Aguardando solicitação de pagamento, 3 = Paga ou 4 = Cancelada
  end;

const
  snparcelas_tpInfRetornoConsultaResumoOT = 'parcelas';
  snparcelas_tpInfRetornoConsultaResumoOT_parcela = 'parcela';

type
  tparcelas_tpInfRetornoConsultaResumoOT = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fparcela: tManagedStringList; // of tparcela_parcelas_tpInfRetornoConsultaResumoOT(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property parcela: tManagedStringList read Fparcela write Fparcela; // of tparcela_parcelas_tpInfRetornoConsultaResumoOT
  end;

const
  snpedagio_tpInfRetornoConsultaResumoOT = 'pedagio';
  snpedagio_tpInfRetornoConsultaResumoOT_valor = 'valor';
  snpedagio_tpInfRetornoConsultaResumoOT_origem = 'origem';
  snpedagio_tpInfRetornoConsultaResumoOT_destino = 'destino';

type
  tpedagio_tpInfRetornoConsultaResumoOT = class( tBaseNddWS ) // Dados refetentes ao pedágio.
  private
    F_NameSpaceAlias: string;
    Fvalor: string; // (E)
    Forigem: string; // (E)
    Forigem_IsSet_: boolean;
    Fdestino: string; // (E)
    Fdestino_IsSet_: boolean;
    procedure Setorigem(value:string);
    procedure Setdestino(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property valor: string read Fvalor write Fvalor; //Valor total do pedágio.
    property origem: string read Forigem write Setorigem; //Cidade e estado de origem.
    property origem_IsSet_:boolean read Forigem_IsSet_;
    property destino: string read Fdestino write Setdestino; //Cidade e estado de destino.
    property destino_IsSet_:boolean read Fdestino_IsSet_;
  end;

const
  snide_tpInfRetornoConsultaResumoOT = 'ide';
  snide_tpInfRetornoConsultaResumoOT_cnpj = 'cnpj';
  snide_tpInfRetornoConsultaResumoOT_serie = 'serie';
  snide_tpInfRetornoConsultaResumoOT_numero = 'numero';
  snide_tpInfRetornoConsultaResumoOT_dataEmissao = 'dataEmissao';
  snide_tpInfRetornoConsultaResumoOT_mfParcelas = 'mfParcelas';
  snide_tpInfRetornoConsultaResumoOT_mfPedagio = 'mfPedagio';
  snide_tpInfRetornoConsultaResumoOT_emAlteracao = 'emAlteracao';
  snide_tpInfRetornoConsultaResumoOT_status = 'status';
  snide_tpInfRetornoConsultaResumoOT_gestoraCartao = 'gestoraCartao';

type
  tide_tpInfRetornoConsultaResumoOT = class( tBaseNddWS ) // Dados para identificação da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fserie: string; // (E)
    Fnumero: string; // (E)
    FdataEmissao: string; // (E)
    FmfParcelas: tbyte; // (E)
    FmfPedagio: tbyte; // (E)
    FemAlteracao: tbyte; // (E)
    Fstatus: tbyte; // (E)
    FgestoraCartao: string; // (E)
    FgestoraCartao_IsSet_: boolean;
    procedure SetgestoraCartao(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante.
    property serie: string read Fserie write Fserie; //Número de série da operação de transporte,
    property numero: string read Fnumero write Fnumero; //Número da operação de transporte.
    property dataEmissao: string read FdataEmissao write FdataEmissao; //Data e hora da emissão  para a operação de transporte.
    property mfParcelas: tbyte read FmfParcelas write FmfParcelas; //Indica se a operação de transporte possui ou não movimentação financeira de parcelas. 1 = Sim e 2 = Não.
    property mfPedagio: tbyte read FmfPedagio write FmfPedagio; //Indica se a operação de transporte possui ou não movimentação financeira de pedágio. 1 = Sim e 2 = Não.
    property emAlteracao: tbyte read FemAlteracao write FemAlteracao; //Indica se a operação de transporte está em alteração. 1 = Sim e 2 = Não.
    property status: tbyte read Fstatus write Fstatus; //Indica o status da operação de transporte. Vigente = 0, Encerrada = 1, Cancelada = 2, Aguardando Vigência = 4, Aberta = 5, Pendente = 6, Em Contingência = 7 ou Rejeitada = 8
    property gestoraCartao: string read FgestoraCartao write SetgestoraCartao; //Indica a gestora de cartões da operação de transporte.
    property gestoraCartao_IsSet_:boolean read FgestoraCartao_IsSet_;
  end;

const
  snide_OT = 'ide';
  snide_OT_serie = 'serie';
  snide_OT_numero = 'numero';

type
  tide_OT = class( tBaseNddWS ) // Dados para identificação da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fserie: string; // (E)
    Fnumero: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property serie: string read Fserie write Fserie; //Série da operação de transporte.
    property numero: string read Fnumero write Fnumero; //Número para a operação de transporte.
  end;

const
  snOT = 'OT';
  snOT_ciot = 'ciot';
  snOT_ndot = 'ndot';
  snOT_ide = 'ide';

type
  tOT = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fciot: string; // (E)
    Fciot_IsSet_: boolean;
    Fndot: string; // (E)
    Fndot_IsSet_: boolean;
    Fide: tide_OT; // (E)
    Fide_IsSet_: boolean;
    procedure Setciot(value:string);
    procedure Setndot(value:string);
    procedure Setide(value:tide_OT);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ciot: string read Fciot write Setciot; //Código de identificação da operação de transporte. Não deve ser informado o código verificador ou XXXX.
    property ciot_IsSet_:boolean read Fciot_IsSet_;
    property ndot: string read Fndot write Setndot; //Número que identifica a operação de transporte sem CIOT.
    property ndot_IsSet_:boolean read Fndot_IsSet_;
    property ide: tide_OT read Fide write Setide;
    property ide_IsSet_:boolean read Fide_IsSet_;
  end;

const
  sntpInfConsultaResumoOT = 'tpInfConsultaResumoOT';
  sntpInfConsultaResumoOT_cnpj = 'cnpj';
  sntpInfConsultaResumoOT_OT = 'OT';
  antpInfConsultaResumoOT_ID = 'Id';

type
  ttpInfConsultaResumoOT = class( tBaseNddWS ) // Informações da consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FOT: tOT; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante da operação que esta sendo consultada.
    property OT: tOT read FOT; // write FOT;
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  sninfConsultaResumoOT = 'infConsultaResumoOT';

type
  tinfConsultaResumoOT = ttpInfConsultaResumoOT;

const
  sntpConsultaResumoOT = 'tpConsultaResumoOT';
  sntpConsultaResumoOT_infConsultaResumoOT = 'infConsultaResumoOT';
  sntpConsultaResumoOT_Signature = 'Signature';
  antpConsultaResumoOT_versao = 'versao';
  antpConsultaResumoOT_token = 'token';

type
  ttpConsultaResumoOT = class( tBaseNddWS ) // Consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FinfConsultaResumoOT: tinfConsultaResumoOT; // (E)
    //FSignature: tSignature; // (X)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infConsultaResumoOT: tinfConsultaResumoOT read FinfConsultaResumoOT; // write FinfConsultaResumoOT;
    //property Signature: tSignature read FSignature; // write FSignature;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  snintegracoes = 'integracoes';
  snintegracoes_integracao = 'integracao';

type
  tintegracoes = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fintegracao: tManagedStringList; // of integer(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property integracao: tManagedStringList read Fintegracao write Fintegracao; // of integer
  end;

const
  snconfiguracao = 'configuracao';
  snconfiguracao_urlIntegracao = 'urlIntegracao';
  snconfiguracao_periodicidade = 'periodicidade';
  snconfiguracao_intervaloConsultaPagamento = 'intervaloConsultaPagamento';
  snconfiguracao_versaoProcessamento = 'versaoProcessamento';
  snconfiguracao_versaoCorrente = 'versaoCorrente';
  snconfiguracao_integracoes = 'integracoes';

type
  tconfiguracao = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FurlIntegracao: string; // (E)
    Fperiodicidade: integer; // (E)
    FintervaloConsultaPagamento: integer; // (E)
    FversaoProcessamento: string; // (E)
    FversaoCorrente: string; // (E)
    Fintegracoes: tintegracoes; // (E)
    Fintegracoes_IsSet_: boolean;
    procedure Setintegracoes(value:tintegracoes);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property urlIntegracao: string read FurlIntegracao write FurlIntegracao;
    property periodicidade: integer read Fperiodicidade write Fperiodicidade;
    property intervaloConsultaPagamento: integer read FintervaloConsultaPagamento write FintervaloConsultaPagamento;
    property versaoProcessamento: string read FversaoProcessamento write FversaoProcessamento;
    property versaoCorrente: string read FversaoCorrente write FversaoCorrente;
    property integracoes: tintegracoes read Fintegracoes write Setintegracoes;
    property integracoes_IsSet_:boolean read Fintegracoes_IsSet_;
  end;

const
  sntpConfiguracao = 'tpConfiguracao';
  sntpConfiguracao_cnpj = 'cnpj';
  sntpConfiguracao_pontoEmissor = 'pontoEmissor';

type
  ttpConfiguracao = class( tBaseNddWS ) // Configuração doa agente
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FpontoEmissor: tManagedStringList; // of string(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante ou agrupador.
    property pontoEmissor: tManagedStringList read FpontoEmissor write FpontoEmissor; // of string
  end;

const
  sntbPadraoImpressaoCompleto = 'tbPadraoImpressaoCompleto';
  sntbPadraoImpressaoCompleto_nomeArquivo = 'nomeArquivo';
  sntbPadraoImpressaoCompleto_nomeImpressora = 'nomeImpressora';
  sntbPadraoImpressaoCompleto_usuarioDocumento = 'usuarioDocumento';
  sntbPadraoImpressaoCompleto_comandosImpressao = 'comandosImpressao';

type
  ttbPadraoImpressaoCompleto = class( tBaseNddWS ) // Impressão de documentos
  private
    F_NameSpaceAlias: string;
    FnomeArquivo: string; // (E)
    FnomeImpressora: string; // (E)
    FusuarioDocumento: string; // (E)
    FusuarioDocumento_IsSet_: boolean;
    FcomandosImpressao: string; // (E)
    FcomandosImpressao_IsSet_: boolean;
    procedure SetusuarioDocumento(value:string);
    procedure SetcomandosImpressao(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nomeArquivo: string read FnomeArquivo write FnomeArquivo;
    property nomeImpressora: string read FnomeImpressora write FnomeImpressora;
    property usuarioDocumento: string read FusuarioDocumento write SetusuarioDocumento;
    property usuarioDocumento_IsSet_:boolean read FusuarioDocumento_IsSet_;
    property comandosImpressao: string read FcomandosImpressao write SetcomandosImpressao;
    property comandosImpressao_IsSet_:boolean read FcomandosImpressao_IsSet_;
  end;

const
  snimpressao_tpRetornoConfiguracao = 'impressao';
  snimpressao_tpRetornoConfiguracao_PontoEmissor = 'PontoEmissor';
  snimpressao_tpRetornoConfiguracao_PadraoImpressao = 'PadraoImpressao';

type
  timpressao_tpRetornoConfiguracao = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FPontoEmissor: string; // (E)
    FPadraoImpressao: ttbPadraoImpressaoCompleto; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property PontoEmissor: string read FPontoEmissor write FPontoEmissor;
    property PadraoImpressao: ttbPadraoImpressaoCompleto read FPadraoImpressao; // write FPadraoImpressao;
  end;

const
  sntpCabecalhoFormularioImpressao = 'tpCabecalhoFormularioImpressao';
  sntpCabecalhoFormularioImpressao_padraoImpressao = 'padraoImpressao';
  sntpCabecalhoFormularioImpressao_agruparDOTs = 'agruparDOTs';

type
  ttpCabecalhoFormularioImpressao = class( tBaseNddWS ) // Impressão de documentos
  private
    F_NameSpaceAlias: string;
    FpadraoImpressao: ttbPadraoImpressaoCompleto; // (E)
    FagruparDOTs: tbyte; // (E)
    FagruparDOTs_IsSet_: boolean;
    procedure SetagruparDOTs(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property padraoImpressao: ttbPadraoImpressaoCompleto read FpadraoImpressao; // write FpadraoImpressao;
    property agruparDOTs: tbyte read FagruparDOTs write SetagruparDOTs;
    property agruparDOTs_IsSet_:boolean read FagruparDOTs_IsSet_;
  end;

const
  sntbPadraoImpressao = 'tbPadraoImpressao';
  sntbPadraoImpressao_nomeImpressora = 'nomeImpressora';
  sntbPadraoImpressao_usuarioDocumento = 'usuarioDocumento';
  sntbPadraoImpressao_comandosImpressao = 'comandosImpressao';

type
  ttbPadraoImpressao = class( tBaseNddWS ) // Impressão de documentos
  private
    F_NameSpaceAlias: string;
    FnomeImpressora: string; // (E)
    FusuarioDocumento: string; // (E)
    FusuarioDocumento_IsSet_: boolean;
    FcomandosImpressao: string; // (E)
    FcomandosImpressao_IsSet_: boolean;
    procedure SetusuarioDocumento(value:string);
    procedure SetcomandosImpressao(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nomeImpressora: string read FnomeImpressora write FnomeImpressora;
    property usuarioDocumento: string read FusuarioDocumento write SetusuarioDocumento;
    property usuarioDocumento_IsSet_:boolean read FusuarioDocumento_IsSet_;
    property comandosImpressao: string read FcomandosImpressao write SetcomandosImpressao;
    property comandosImpressao_IsSet_:boolean read FcomandosImpressao_IsSet_;
  end;

const
  sntpPadraoImpressaoDocumentos = 'tpPadraoImpressaoDocumentos';
  sntpPadraoImpressaoDocumentos_cnpj = 'cnpj';
  sntpPadraoImpressaoDocumentos_pontoEmissor = 'pontoEmissor';

type
  ttpPadraoImpressaoDocumentos = class( tBaseNddWS ) // Impressão de documentos
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FpontoEmissor: tManagedStringList; // of string(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante.
    property pontoEmissor: tManagedStringList read FpontoEmissor write FpontoEmissor; // of string
  end;

const
  snCrossTalk_Header_Response_Type = 'CrossTalk_Header_Response_Type';
  snCrossTalk_Header_Response_Type_ResponseCode = 'ResponseCode';
  snCrossTalk_Header_Response_Type_ResponseCodeMessage = 'ResponseCodeMessage';
  snCrossTalk_Header_Response_Type_ProcessCode = 'ProcessCode';
  snCrossTalk_Header_Response_Type_MessageType = 'MessageType';
  snCrossTalk_Header_Response_Type_ExchangePattern = 'ExchangePattern';
  snCrossTalk_Header_Response_Type_SourceId = 'SourceId';
  snCrossTalk_Header_Response_Type_GUID = 'GUID';
  snCrossTalk_Header_Response_Type_DateTime = 'DateTime';
  snCrossTalk_Header_Response_Type_EnterpriseId = 'EnterpriseId';
  snCrossTalk_Header_Response_Type_Token = 'Token';
  snCrossTalk_Header_Response_Type_ContentType = 'ContentType';
  snCrossTalk_Header_Response_Type_ContentEncoding = 'ContentEncoding';

type
  tCrossTalk_Header_Response_Type = class( tBaseNddWS ) // Cabeçalho da mensagem
  private
    F_NameSpaceAlias: string;
    FResponseCode: integer; // (E)
    FResponseCodeMessage: string; // (E)
    FResponseCodeMessage_IsSet_: boolean;
    FProcessCode: integer; // (E)
    FMessageType: integer; // (E)
    FExchangePattern: tbyte; // (E)
    FExchangePattern_IsSet_: boolean;
    FSourceId: tbyte; // (E)
    FSourceId_IsSet_: boolean;
    FGUID: string; // (E)
    FGUID_IsSet_: boolean;
    FDateTime: tDateTime; // (E)
    FDateTime_IsSet_: boolean;
    FEnterpriseId: int64; // (E)
    FToken: string; // (E)
    FContentType: string; // (E)
    FContentType_IsSet_: boolean;
    FContentEncoding: string; // (E)
    FContentEncoding_IsSet_: boolean;
    procedure SetResponseCodeMessage(value:string);
    procedure SetExchangePattern(value:tbyte);
    procedure SetSourceId(value:tbyte);
    procedure SetGUID(value:string);
    procedure SetDateTime(value:tDateTime);
    procedure SetContentType(value:string);
    procedure SetContentEncoding(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ResponseCode: integer read FResponseCode write FResponseCode; //Codigo da resposta do processamento da mensagem
    property ResponseCodeMessage: string read FResponseCodeMessage write SetResponseCodeMessage; //Descricao do codigo da mensagem
    property ResponseCodeMessage_IsSet_:boolean read FResponseCodeMessage_IsSet_;
    property ProcessCode: integer read FProcessCode write FProcessCode; //Código do processamento
    property MessageType: integer read FMessageType write FMessageType; //Tipo de mensagem que será processada
    property ExchangePattern: tbyte read FExchangePattern write SetExchangePattern; //Padrão de troca de mensagem
    property ExchangePattern_IsSet_:boolean read FExchangePattern_IsSet_;
    property SourceId: tbyte read FSourceId write SetSourceId; //Identifdicador do sistema que está ntegrando
    property SourceId_IsSet_:boolean read FSourceId_IsSet_;
    property GUID: string read FGUID write SetGUID; //Identificador unico gerado pela aplicação para poder recuperar a mensagem
    property GUID_IsSet_:boolean read FGUID_IsSet_;
    property DateTime: tDateTime read FDateTime write SetDateTime; //Data e hora do envio da mensagem para processamento
    property DateTime_IsSet_:boolean read FDateTime_IsSet_;
    property EnterpriseId: int64 read FEnterpriseId write FEnterpriseId; //Identificador da empresa
    property Token: string read FToken write FToken; //Identificador exclusivo que contêm os vinculos de processamento necessários no ETransportBusiness
    property ContentType: string read FContentType write SetContentType; //Tipo de conteudo da mensagem enviada
    property ContentType_IsSet_:boolean read FContentType_IsSet_;
    property ContentEncoding: string read FContentEncoding write SetContentEncoding; //Tipo de codificação dos caracteres passados na mensagem
    property ContentEncoding_IsSet_:boolean read FContentEncoding_IsSet_;
  end;

const
  snautomatica = 'automatica';
  snautomatica_dataHora = 'dataHora';

type
  tautomatica = class( tBaseNddWS ) // Pagamento realizado devido a um agendamento.
  private
    F_NameSpaceAlias: string;
    FdataHora: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataHora: string read FdataHora write FdataHora; //Data e hora do agendamento.
  end;

const
  snperiodo = 'periodo';
  snperiodo_dataInicial = 'dataInicial';
  snperiodo_dataFinal = 'dataFinal';

type
  tperiodo = class( tBaseNddWS ) // Intervalo de datas a ser retornado os pagamentos.
  private
    F_NameSpaceAlias: string;
    FdataInicial: string; // (E)
    FdataFinal: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataInicial: string read FdataInicial write FdataInicial; //Data inicial para a conuslta de pagamentos.
    property dataFinal: string read FdataFinal write FdataFinal; //Data final para a consulta de pagamentos.
  end;

const
  sntpConsultaPgtos = 'tpConsultaPgtos';
  sntpConsultaPgtos_cnpjContratante = 'cnpjContratante';
  sntpConsultaPgtos_cnpjEmitente = 'cnpjEmitente';
  sntpConsultaPgtos_GUID = 'GUID';
  sntpConsultaPgtos_periodo = 'periodo';
  antpConsultaPgtos_versao = 'versao';
  antpConsultaPgtos_token = 'token';

type
  ttpConsultaPgtos = class( tBaseNddWS ) // Dados necessários para a consulta de pagamento realizados.
  private
    F_NameSpaceAlias: string;
    FcnpjContratante: string; // (E)
    FcnpjContratante_IsSet_: boolean;
    FcnpjEmitente: string; // (E)
    FcnpjEmitente_IsSet_: boolean;
    FGUID: string; // (E)
    FGUID_IsSet_: boolean;
    Fperiodo: tperiodo; // (E)
    Fperiodo_IsSet_: boolean;
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure SetcnpjContratante(value:string);
    procedure SetcnpjEmitente(value:string);
    procedure SetGUID(value:string);
    procedure Setperiodo(value:tperiodo);
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpjContratante: string read FcnpjContratante write SetcnpjContratante; //CNPJ da contratante ou agrupador solicitante dos pagamentos.
    property cnpjContratante_IsSet_:boolean read FcnpjContratante_IsSet_;
    property cnpjEmitente: string read FcnpjEmitente write SetcnpjEmitente; //CNPJ do emitente solicitante dos pagamentos.
    property cnpjEmitente_IsSet_:boolean read FcnpjEmitente_IsSet_;
    property GUID: string read FGUID write SetGUID; //Identificador único a ser associado com a integração de pagamentos. Caso ja existe uma integração para este identificador, esta será retornada.
    property GUID_IsSet_:boolean read FGUID_IsSet_;
    property periodo: tperiodo read Fperiodo write Setperiodo;
    property periodo_IsSet_:boolean read Fperiodo_IsSet_;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  snremover = 'remover';
  snremover_pedagioERP = 'pedagioERP';
  snremover_cpf = 'cpf';

type
  tremover = class( tBaseNddWS ) // Informações para remover um direcionamento de pedágio existente.
  private
    F_NameSpaceAlias: string;
    FpedagioERP: string; // (E)
    Fcpf: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property pedagioERP: string read FpedagioERP write FpedagioERP; //Identificador do direcionamento de pedágio.
    property cpf: string read Fcpf write Fcpf; //Número do CPF do condutor.
  end;

const
  snaltData = 'altData';
  snaltData_data = 'data';

type
  taltData = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fdata: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property data: string read Fdata write Fdata; //Novo valor de data, se a parcela for automativa o agendamente será alterado e caso seja manual a data prevista será alterada.
  end;

const
  snvalidade = 'validade';
  snvalidade_dtInicio = 'dtInicio';
  snvalidade_dtFim = 'dtFim';

type
  tvalidade = class( tBaseNddWS ) // Dados de identificação da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FdtInicio: string; // (E)
    FdtFim: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dtInicio: string read FdtInicio write FdtInicio; //Data de inicio da viagem.
    property dtFim: string read FdtFim write FdtFim; //Data de término da viagem.
  end;

const
  sntpDescontoSemMF = 'tpDescontoSemMF';
  sntpDescontoSemMF_nmDesc = 'nmDesc';
  sntpDescontoSemMF_vlrDesc = 'vlrDesc';
  sntpDescontoSemMF_rubrica = 'rubrica';
  sntpDescontoSemMF_dsDesc = 'dsDesc';

type
  ttpDescontoSemMF = class( tBaseNddWS ) // Desconto aplicado a operação de transporte
  private
    F_NameSpaceAlias: string;
    FnmDesc: string; // (E)
    FvlrDesc: string; // (E)
    Frubrica: tbyte; // (E)
    FdsDesc: string; // (E)
    FdsDesc_IsSet_: boolean;
    procedure SetdsDesc(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nmDesc: string read FnmDesc write FnmDesc; //Nome do desconto
    property vlrDesc: string read FvlrDesc write FvlrDesc; //Valor do desconto
    property rubrica: tbyte read Frubrica write Frubrica; //Informar qual rubrica o valor se refere: 1-Frete, 2-Combustivel, 3-Pedagio
    property dsDesc: string read FdsDesc write SetdsDesc; //Informações adicionaris para o desconto.
    property dsDesc_IsSet_:boolean read FdsDesc_IsSet_;
  end;

const
  snresponsavel = 'responsavel';
  snresponsavel_nome = 'nome';
  snresponsavel_email = 'email';

type
  tresponsavel = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    Femail: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome do responsável.
    property email: string read Femail write Femail; //Email do responsável.
  end;

const
  snresponsaveis = 'responsaveis';
  snresponsaveis_responsavel = 'responsavel';

type
  tresponsaveis = class( tBaseNddWS ) // Lista de responsáveis específicos para a rota.
  private
    F_NameSpaceAlias: string;
    Fresponsavel: tManagedStringList; // of tresponsavel(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property responsavel: tManagedStringList read Fresponsavel write Fresponsavel; // of tresponsavel
  end;

const
  snpontoParada = 'pontoParada';
  snpontoParada_codigoIBGE = 'codigoIBGE';
  snpontoParada_cep = 'cep';
  snpontoParada_tipoRotaEspecifico = 'tipoRotaEspecifico';

type
  tpontoParada = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FcodigoIBGE: string; // (E)
    FcodigoIBGE_IsSet_: boolean;
    Fcep: string; // (E)
    FtipoRotaEspecifico: tbyte; // (E)
    FtipoRotaEspecifico_IsSet_: boolean;
    procedure SetcodigoIBGE(value:string);
    procedure SettipoRotaEspecifico(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property codigoIBGE: string read FcodigoIBGE write SetcodigoIBGE; //Código do IBGE do ponto de parada.
    property codigoIBGE_IsSet_:boolean read FcodigoIBGE_IsSet_;
    property cep: string read Fcep write Fcep; //CEP do ponto de parada.
    property tipoRotaEspecifico: tbyte read FtipoRotaEspecifico write SettipoRotaEspecifico; //Define o tipo de rota específico para o ponto de parada em relação ao anterior. Isso deve ignorar o tipo de rota definido como padrão.
    property tipoRotaEspecifico_IsSet_:boolean read FtipoRotaEspecifico_IsSet_;
  end;

const
  snpontosParada = 'pontosParada';
  snpontosParada_pontoParada = 'pontoParada';

type
  tpontosParada = class( tBaseNddWS ) // Define os pontos de parada, bem como a origem e destino. A sequencia de pontos de parada na lista é a sequencia da rota.
  private
    F_NameSpaceAlias: string;
    FpontoParada: tManagedStringList; // of tpontoParada(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property pontoParada: tManagedStringList read FpontoParada write FpontoParada; // of tpontoParada
  end;

const
  sninformacoes_tpRota = 'informacoes';
  sninformacoes_tpRota_nome = 'nome';
  sninformacoes_tpRota_tipoRotaPadrao = 'tipoRotaPadrao';
  sninformacoes_tpRota_pontosParada = 'pontosParada';
  sninformacoes_tpRota_responsaveis = 'responsaveis';
  sninformacoes_tpRota_utilizarRoteirizador = 'utilizarRoteirizador';
  sninformacoes_tpRota_totalKm = 'totalKm';
  sninformacoes_tpRota_notificarRespContratante = 'notificarRespContratante';

type
  tinformacoes_tpRota = class( tBaseNddWS ) // Dados da rota a serem inseridos ou atualizados no sistema. Se a tag acima for identica a alguma rota no banco, as informações desta serão alteradas por esta tag.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    FtipoRotaPadrao: tbyte; // (E)
    FtipoRotaPadrao_IsSet_: boolean;
    FpontosParada: tpontosParada; // (E)
    Fresponsaveis: tresponsaveis; // (E)
    Fresponsaveis_IsSet_: boolean;
    FutilizarRoteirizador: tbyte; // (E)
    FutilizarRoteirizador_IsSet_: boolean;
    FtotalKm: string; // (E)
    FtotalKm_IsSet_: boolean;
    FnotificarRespContratante: tbyte; // (E)
    FnotificarRespContratante_IsSet_: boolean;
    procedure SettipoRotaPadrao(value:tbyte);
    procedure Setresponsaveis(value:tresponsaveis);
    procedure SetutilizarRoteirizador(value:tbyte);
    procedure SettotalKm(value:string);
    procedure SetnotificarRespContratante(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome para apresentação da rota dentro do sistema.
    property tipoRotaPadrao: tbyte read FtipoRotaPadrao write SettipoRotaPadrao; //Define o tipo de rota padrão a ser utilizado nos pontos de parada que não possuem um tipo específico. Por padrão será utilizado a rota rápida(1).
    property tipoRotaPadrao_IsSet_:boolean read FtipoRotaPadrao_IsSet_;
    property pontosParada: tpontosParada read FpontosParada; // write FpontosParada;
    property responsaveis: tresponsaveis read Fresponsaveis write Setresponsaveis;
    property responsaveis_IsSet_:boolean read Fresponsaveis_IsSet_;
    property utilizarRoteirizador: tbyte read FutilizarRoteirizador write SetutilizarRoteirizador; //Possibilita a utilização do retirizador para cálcular o pedágio e a distância. Por padrão será utilizado o roteirizador (1).
    property utilizarRoteirizador_IsSet_:boolean read FutilizarRoteirizador_IsSet_;
    property totalKm: string read FtotalKm write SettotalKm; //Determina a quilometragem da rota.
    property totalKm_IsSet_:boolean read FtotalKm_IsSet_;
    property notificarRespContratante: tbyte read FnotificarRespContratante write SetnotificarRespContratante; //Possibilita a notificação dos responsáveis da contratante caso o roteirizador identifique alterações na rota. Por padrão serão notificados (1).
    property notificarRespContratante_IsSet_:boolean read FnotificarRespContratante_IsSet_;
  end;

const
  sntpRota = 'tpRota';
  sntpRota_rotaERP = 'rotaERP';
  sntpRota_informacoes = 'informacoes';

type
  ttpRota = class( tBaseNddWS ) // Define os dados da rota.
  private
    F_NameSpaceAlias: string;
    FrotaERP: string; // (E)
    Finformacoes: tinformacoes_tpRota; // (E)
    Finformacoes_IsSet_: boolean;
    FrotaERP_isSet_: boolean;
    procedure Setinformacoes(value:tinformacoes_tpRota);
    procedure SetFrotaERP(const Value: string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property rotaERP: string read FrotaERP write SetFrotaERP; //Nome da rota no ERP para a integração. Caso a tag abaixo seja informada, este será o nome usado para as próximas integrações.
    property rotaERP_isSet_: boolean read FrotaERP_isSet_ ; //Nome da rota no ERP para a integração. Caso a tag abaixo seja informada, este será o nome usado para as próximas integrações.
    property informacoes: tinformacoes_tpRota read Finformacoes write Setinformacoes;
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
  end;

const
  snviagem = 'viagem';
  snviagem_rota = 'rota';
  snviagem_codigoSH = 'codigoSH';
  snviagem_qtdeCarga = 'qtdeCarga';
  snviagem_qtdeViagens = 'qtdeViagens';

type
  tviagem = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Frota: ttpRota; // (E)
    FcodigoSH: string; // (E)
    FqtdeCarga: string; // (E)
    FqtdeViagens: integer; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property rota: ttpRota read Frota; // write Frota; //Define a rota da viagem.
    property codigoSH: string read FcodigoSH write FcodigoSH; //Código do Sistema Harmonizado. Define qual a natureza da carga conforme a tabela de códigos do Sistema Harmonizado de Designação e de Codificação de Mercadorias.
    property qtdeCarga: string read FqtdeCarga write FqtdeCarga; //Informa a quantidade total da carga de todas as operações de transporte realizadas.
    property qtdeViagens: integer read FqtdeViagens write FqtdeViagens; //Quantidade de viagens realizadas durante o período de vigência da operação de transporte.
  end;

const
  snviagens = 'viagens';
  snviagens_viagem = 'viagem';

type
  tviagens = class( tBaseNddWS ) // Viagens realizadas durante o período de vigência da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fviagem: tManagedStringList; // of tviagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property viagem: tManagedStringList read Fviagem write Fviagem; // of tviagem
  end;

const
  sncampo = 'campo';
  sncampo_nome = 'nome';
  sncampo_valor = 'valor';

type
  tcampo = class( tBaseNddWS ) // Campos de informação
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    Fvalor: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome do campo. Caso ja exista um campo com este nome, o valor será alterado.
    property valor: string read Fvalor write Fvalor; //Va.lor formatado do campo
  end;

const
  sntpAdicionalImpressao = 'tpAdicionalImpressao';
  sntpAdicionalImpressao_campo = 'campo';

type
  ttpAdicionalImpressao = class( tBaseNddWS ) // Contém dados de adicionais de impressão.
  private
    F_NameSpaceAlias: string;
    Fcampo: tManagedStringList; // of tcampo(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property campo: tManagedStringList read Fcampo write Fcampo; // of tcampo
  end;

const
  snTACagregado_encerramento = 'TACagregado';
  snTACagregado_encerramento_viagens = 'viagens';
  snTACagregado_encerramento_adicionais = 'adicionais';

type
  tTACagregado_encerramento = class( tBaseNddWS ) // Operação de transporte com TAC-agregado.
  private
    F_NameSpaceAlias: string;
    Fviagens: tviagens; // (E)
    Fadicionais: ttpAdicionalImpressao; // (E)
    Fadicionais_IsSet_: boolean;
    procedure Setadicionais(value:ttpAdicionalImpressao);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property viagens: tviagens read Fviagens; // write Fviagens;
    property adicionais: ttpAdicionalImpressao read Fadicionais write Setadicionais; //Dados adicionais para uso na impressão
    property adicionais_IsSet_:boolean read Fadicionais_IsSet_;
  end;

const
  snpadrao_encerramento = 'padrao';
  snpadrao_encerramento_qtdeCarga = 'qtdeCarga';
  snpadrao_encerramento_adicionais = 'adicionais';

type
  tpadrao_encerramento = class( tBaseNddWS ) // Operação de transporte padrão.
  private
    F_NameSpaceAlias: string;
    FqtdeCarga: string; // (E)
    Fadicionais: ttpAdicionalImpressao; // (E)
    Fadicionais_IsSet_: boolean;
    procedure Setadicionais(value:ttpAdicionalImpressao);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property qtdeCarga: string read FqtdeCarga write FqtdeCarga; //Quantidade da carga em Kg.
    property adicionais: ttpAdicionalImpressao read Fadicionais write Setadicionais; //Dados adicionais para uso na impressão
    property adicionais_IsSet_:boolean read Fadicionais_IsSet_;
  end;

const
  snencerramento = 'encerramento';
  snencerramento_padrao = 'padrao';
  snencerramento_TACagregado = 'TACagregado';

type
  tencerramento = class( tBaseNddWS ) // Dados referentes ao encerramento.
  private
    F_NameSpaceAlias: string;
    Fpadrao: tpadrao_encerramento; // (E)
    Fpadrao_IsSet_: boolean;
    FTACagregado: tTACagregado_encerramento; // (E)
    FTACagregado_IsSet_: boolean;
    procedure Setpadrao(value:tpadrao_encerramento);
    procedure SetTACagregado(value:tTACagregado_encerramento);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property padrao: tpadrao_encerramento read Fpadrao write Setpadrao;
    property padrao_IsSet_:boolean read Fpadrao_IsSet_;
    property TACagregado: tTACagregado_encerramento read FTACagregado write SetTACagregado;
    property TACagregado_IsSet_:boolean read FTACagregado_IsSet_;
  end;

const
  sntpDescontoParcelaAlteracao = 'tpDescontoParcelaAlteracao';
  sntpDescontoParcelaAlteracao_tpDesc = 'tpDesc';
  sntpDescontoParcelaAlteracao_nmDesc = 'nmDesc';
  sntpDescontoParcelaAlteracao_vlrDesc = 'vlrDesc';
  sntpDescontoParcelaAlteracao_dsDesc = 'dsDesc';
  sntpDescontoParcelaAlteracao_rubrica = 'rubrica';

type
  ttpDescontoParcelaAlteracao = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FtpDesc: tbyte; // (E)
    FnmDesc: string; // (E)
    FvlrDesc: string; // (E)
    FvlrDesc_IsSet_: boolean;
    FdsDesc: string; // (E)
    Frubrica: tbyte; // (E)
    Frubrica_IsSet_: boolean;
    procedure SetvlrDesc(value:string);
    procedure SetdsDesc(value:string);
    procedure Setrubrica(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property tpDesc: tbyte read FtpDesc write FtpDesc; //Tipo de desconto, 1 se for descontado no incio da operação ou 2 se for descontado no registro de passagem.
    property nmDesc: string read FnmDesc write FnmDesc; //Nome para o desconto.
    property vlrDesc: string read FvlrDesc write SetvlrDesc; //Valor do desconto quando retido na fonte.
    property vlrDesc_IsSet_:boolean read FvlrDesc_IsSet_;
    property dsDesc: string read FdsDesc write SetdsDesc; //Informações adicionaris para o desconto.
    property rubrica: tbyte read Frubrica write Setrubrica; //Informar qual rubrica o valor se refere. 1 = Frete, 2 = Combustível e 3 = Despesa. Por padrão o desconto não é nas rubricas e sim diretamente na parcela.
    property rubrica_IsSet_:boolean read Frubrica_IsSet_;
  end;

const
  sntpDescontoParcela = 'tpDescontoParcela';
  sntpDescontoParcela_tpDesc = 'tpDesc';
  sntpDescontoParcela_nmDesc = 'nmDesc';
  sntpDescontoParcela_vlrDesc = 'vlrDesc';
  sntpDescontoParcela_dsDesc = 'dsDesc';

type
  ttpDescontoParcela = class( tBaseNddWS ) // Desconto a ser utilizado para cálculo da parcela.
  private
    F_NameSpaceAlias: string;
    FtpDesc: tbyte; // (E)
    FnmDesc: string; // (E)
    FvlrDesc: string; // (E)
    FvlrDesc_IsSet_: boolean;
    FdsDesc: string; // (E)
    FdsDesc_IsSet_: boolean;
    procedure SetvlrDesc(value:string);
    procedure SetdsDesc(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property tpDesc: tbyte read FtpDesc write FtpDesc; //Tipo de desconto, 1 se for descontado no incio da operação ou 2 se for descontado no registro de passagem. Para operações de transporte sem movimentação financeira deve ser utilizado o valor 1.
    property nmDesc: string read FnmDesc write FnmDesc; //Nome para o desconto.
    property vlrDesc: string read FvlrDesc write SetvlrDesc; //Valor do desconto quando retido na fonte
    property vlrDesc_IsSet_:boolean read FvlrDesc_IsSet_;
    property dsDesc: string read FdsDesc write SetdsDesc; //Informações adicionaris para o desconto.
    property dsDesc_IsSet_:boolean read FdsDesc_IsSet_;
  end;

const
  sntpAdicionalParcela = 'tpAdicionalParcela';
  sntpAdicionalParcela_valor = 'valor';
  sntpAdicionalParcela_rubrica = 'rubrica';

type
  ttpAdicionalParcela = class( tBaseNddWS ) // Dados de adicionais das parcelas.
  private
    F_NameSpaceAlias: string;
    Fvalor: string; // (E)
    Frubrica: tbyte; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property valor: string read Fvalor write Fvalor; //Valor a ser acrescido.
    property rubrica: tbyte read Frubrica write Frubrica; //Informar qual rubrica o valor se refere. 1 = Frete, 2 = Combustível e 3 = Despesa
  end;

const
  sndescontos_tpAlterarParcela = 'descontos';
  sndescontos_tpAlterarParcela_desconto = 'desconto';

type
  tdescontos_tpAlterarParcela = class( tBaseNddWS ) // Lista de descontos.
  private
    F_NameSpaceAlias: string;
    Fdesconto: tManagedStringList; // of ttpDescontoParcela(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property desconto: tManagedStringList read Fdesconto write Fdesconto; // of ttpDescontoParcela
  end;

const
  sndescontos_tpParcela = 'descontos';
  sndescontos_tpParcela_desconto = 'desconto';

type
  tdescontos_tpParcela = class( tBaseNddWS ) // Lista de descontos.
  private
    F_NameSpaceAlias: string;
    Fdesconto: tManagedStringList; // of ttpDescontoParcela(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property desconto: tManagedStringList read Fdesconto write Fdesconto; // of ttpDescontoParcela
  end;

const
  snautomatico = 'automatico';
  snautomatico_dataHora = 'dataHora';

type
  tautomatico = class( tBaseNddWS ) // Dados do pagamento automático da parcela.
  private
    F_NameSpaceAlias: string;
    FdataHora: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataHora: string read FdataHora write FdataHora; //Data e hora para o pagamento. AAAA-MM--DD HH:MM:SS
  end;

const
  snmanual = 'manual';
  snmanual_dataPrevisao = 'dataPrevisao';
  snmanual_efetivacao = 'efetivacao';

type
  tmanual = class( tBaseNddWS ) // Dados do pagamento manual da parcela.
  private
    F_NameSpaceAlias: string;
    FdataPrevisao: string; // (E)
    Fefetivacao: tbyte; // (E)
    Fefetivacao_IsSet_: boolean;
    procedure Setefetivacao(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataPrevisao: string read FdataPrevisao write FdataPrevisao; //Data prevista para o pagamento. Padrão AAAA-MM-DD
    property efetivacao: tbyte read Fefetivacao write Setefetivacao; //Define o local para a efetivação do pagamento. Possibilidades: 1 = Posto credenciado, 2 = Centro de Triagem, = = Contratante e 4 = Confirmador. Por padrão a efetivação deve acontecer no posto credenciado.
    property efetivacao_IsSet_:boolean read Fefetivacao_IsSet_;
  end;

const
  sntpTipoPagamento = 'tpTipoPagamento';
  sntpTipoPagamento_manual = 'manual';
  sntpTipoPagamento_automatico = 'automatico';

type
  ttpTipoPagamento = class( tBaseNddWS ) // Define os dados do tipo de pagamento.
  private
    F_NameSpaceAlias: string;
    Fmanual: tmanual; // (E)
    Fmanual_IsSet_: boolean;
    Fautomatico: tautomatico; // (E)
    Fautomatico_IsSet_: boolean;
    procedure Setmanual(value:tmanual);
    procedure Setautomatico(value:tautomatico);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property manual: tmanual read Fmanual write Setmanual;
    property manual_IsSet_:boolean read Fmanual_IsSet_;
    property automatico: tautomatico read Fautomatico write Setautomatico;
    property automatico_IsSet_:boolean read Fautomatico_IsSet_;
  end;

const
  sntpRestricaoPagamento = 'tpRestricaoPagamento';
  sntpRestricaoPagamento_campo = 'campo';
  sntpRestricaoPagamento_valor = 'valor';
  sntpRestricaoPagamento_criterio = 'criterio';
  sntpRestricaoPagamento_conector = 'conector';

type
  ttpRestricaoPagamento = class( tBaseNddWS ) // Define os dados para a restrição de pagamento.
  private
    F_NameSpaceAlias: string;
    Fcampo: tbyte; // (E)
    Fvalor: string; // (E)
    Fcriterio: tbyte; // (E)
    Fcriterio_IsSet_: boolean;
    Fconector: tbyte; // (E)
    Fconector_IsSet_: boolean;
    procedure Setcriterio(value:tbyte);
    procedure Setconector(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property campo: tbyte read Fcampo write Fcampo; //Define o campo para comparação na restrição. Possibilidades: 1 = CNPJ do posto credenciado ou 2 = Data.
    property valor: string read Fvalor write Fvalor; //Valor para comparação com o campo respeitando o critério.
    property criterio: tbyte read Fcriterio write Setcriterio; //Define os critérios para a restrição. Possibilidades: 1 = Igual, 2 = Diferente, 3 = Maior, 4 = Maior ou iguak, 5 = Menor e 6 = Menor ou Igual. Por padrão será utilizado Igual (1).
    property criterio_IsSet_:boolean read Fcriterio_IsSet_;
    property conector: tbyte read Fconector write Setconector; //Define o conector. Possibilidades: 1 = E e 2 = OU. Por padrão será utilizado E (1).
    property conector_IsSet_:boolean read Fconector_IsSet_;
  end;

const
  snrestricoes_tpAlterarParcela = 'restricoes';
  snrestricoes_tpAlterarParcela_restricao = 'restricao';

type
  trestricoes_tpAlterarParcela = class( tBaseNddWS ) // Lista de restrições para que o pagamento da parcela possa ser realizado.
  private
    F_NameSpaceAlias: string;
    Frestricao: tManagedStringList; // of ttpRestricaoPagamento(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property restricao: tManagedStringList read Frestricao write Frestricao; // of ttpRestricaoPagamento
  end;

const
  snrestricoes = 'restricoes';
  snrestricoes_restricao = 'restricao';

type
  trestricoes = class( tBaseNddWS ) // Lista de restrições para que o pagamento da parcela possa ser realizado.
  private
    F_NameSpaceAlias: string;
    Frestricao: tManagedStringList; // of ttpRestricaoPagamento(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property restricao: tManagedStringList read Frestricao write Frestricao; // of ttpRestricaoPagamento
  end;

const
  sntpImpostos = 'tpImpostos';
  sntpImpostos_irrf = 'irrf';
  sntpImpostos_inss = 'inss';
  sntpImpostos_sestsenat = 'sestsenat';

type
  ttpImpostos = class( tBaseNddWS ) // Define os impostos.
  private
    F_NameSpaceAlias: string;
    Firrf: string; // (E)
    Finss: string; // (E)
    Fsestsenat: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property irrf: string read Firrf write Firrf; //Imposto de IRRF.
    property inss: string read Finss write Finss; //Imposto de INSS.
    property sestsenat: string read Fsestsenat write Fsestsenat; //Imposto de SEST.
  end;

const
  snaltValores = 'altValores';
  snaltValores_adicional = 'adicional';
  snaltValores_desconto = 'desconto';
  snaltValores_retencoes = 'retencoes';

type
  taltValores = class( tBaseNddWS ) // Ajuste nos valores da parcela.
  private
    F_NameSpaceAlias: string;
    Fadicional: ttpAdicionalParcela; // (E)
    Fadicional_IsSet_: boolean;
    Fdesconto: ttpDescontoParcelaAlteracao; // (E)
    Fdesconto_IsSet_: boolean;
    Fretencoes: ttpImpostos; // (E)
    Fretencoes_IsSet_: boolean;
    procedure Setadicional(value:ttpAdicionalParcela);
    procedure Setdesconto(value:ttpDescontoParcelaAlteracao);
    procedure Setretencoes(value:ttpImpostos);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property adicional: ttpAdicionalParcela read Fadicional write Setadicional; //Incluir um valor adicional para a parcela.
    property adicional_IsSet_:boolean read Fadicional_IsSet_;
    property desconto: ttpDescontoParcelaAlteracao read Fdesconto write Setdesconto; //Incluir um desconto de valor para a parcela.
    property desconto_IsSet_:boolean read Fdesconto_IsSet_;
    property retencoes: ttpImpostos read Fretencoes write Setretencoes; //Valores de retenções.
    property retencoes_IsSet_:boolean read Fretencoes_IsSet_;
  end;

const
  snajustaParc = 'ajustaParc';
  snajustaParc_nome = 'nome';
  snajustaParc_altData = 'altData';
  snajustaParc_altValores = 'altValores';

type
  tajustaParc = class( tBaseNddWS ) // Ajustar parcela existente na operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    FaltData: taltData; // (E)
    FaltData_IsSet_: boolean;
    FaltValores: taltValores; // (E)
    FaltValores_IsSet_: boolean;
    procedure SetaltData(value:taltData);
    procedure SetaltValores(value:taltValores);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome da parcela ja existente na operação de transporte.
    property altData: taltData read FaltData write SetaltData;
    property altData_IsSet_:boolean read FaltData_IsSet_;
    property altValores: taltValores read FaltValores write SetaltValores;
    property altValores_IsSet_:boolean read FaltValores_IsSet_;
  end;

const
  snpraca_pracas_tpRetornoPedagio = 'praca';
  snpraca_pracas_tpRetornoPedagio_nome = 'nome';
  snpraca_pracas_tpRetornoPedagio_valor = 'valor';
  snpraca_pracas_tpRetornoPedagio_localizacao = 'localizacao';

type
  tpraca_pracas_tpRetornoPedagio = class( tBaseNddWS ) // Praça de pedágio.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    Fvalor: string; // (E)
    Flocalizacao: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome da praça.
    property valor: string read Fvalor write Fvalor; //Valor da específico da praça de pedágio.
    property localizacao: string read Flocalizacao write Flocalizacao; //Localização da praça de pedágio.
  end;

const
  snpracas_tpRetornoPedagio = 'pracas';
  snpracas_tpRetornoPedagio_praca = 'praca';

type
  tpracas_tpRetornoPedagio = class( tBaseNddWS ) // Informações das praças de pedágio.
  private
    F_NameSpaceAlias: string;
    Fpraca: tManagedStringList; // of tpraca_pracas_tpRetornoPedagio(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property praca: tManagedStringList read Fpraca write Fpraca; // of tpraca_pracas_tpRetornoPedagio
  end;

const
  sntpRetornoPedagio = 'tpRetornoPedagio';
  sntpRetornoPedagio_valor = 'valor';
  sntpRetornoPedagio_origem = 'origem';
  sntpRetornoPedagio_destino = 'destino';
  sntpRetornoPedagio_pracas = 'pracas';

type
  ttpRetornoPedagio = class( tBaseNddWS ) // Define os dados de retorno relacionados ao pedágio.
  private
    F_NameSpaceAlias: string;
    Fvalor: string; // (E)
    Forigem: string; // (E)
    Fdestino: string; // (E)
    Fpracas: tpracas_tpRetornoPedagio; // (E)
    Fpracas_IsSet_: boolean;
    procedure Setpracas(value:tpracas_tpRetornoPedagio);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property valor: string read Fvalor write Fvalor; //Valor total do pedágio.
    property origem: string read Forigem write Forigem; //Cidade e estado de origem.
    property destino: string read Fdestino write Fdestino; //Cidade e estado de destino.
    property pracas: tpracas_tpRetornoPedagio read Fpracas write Setpracas;
    property pracas_IsSet_:boolean read Fpracas_IsSet_;
  end;

const
  sntpRetornoValores = 'tpRetornoValores';
  sntpRetornoValores_vlrFrete = 'vlrFrete';
  sntpRetornoValores_vlrDespesas = 'vlrDespesas';
  sntpRetornoValores_vlrCombustivel = 'vlrCombustivel';
  sntpRetornoValores_vlrSaldo = 'vlrSaldo';

type
  ttpRetornoValores = class( tBaseNddWS ) // Define os dados de retorno para os valores.
  private
    F_NameSpaceAlias: string;
    FvlrFrete: string; // (E)
    FvlrDespesas: string; // (E)
    FvlrDespesas_IsSet_: boolean;
    FvlrCombustivel: string; // (E)
    FvlrCombustivel_IsSet_: boolean;
    FvlrSaldo: string; // (E)
    procedure SetvlrDespesas(value:string);
    procedure SetvlrCombustivel(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property vlrFrete: string read FvlrFrete write FvlrFrete; //Valor referente ao frete.
    property vlrDespesas: string read FvlrDespesas write SetvlrDespesas; //Valor referente as despesas.
    property vlrDespesas_IsSet_:boolean read FvlrDespesas_IsSet_;
    property vlrCombustivel: string read FvlrCombustivel write SetvlrCombustivel; //Valor referente ao combustível.
    property vlrCombustivel_IsSet_:boolean read FvlrCombustivel_IsSet_;
    property vlrSaldo: string read FvlrSaldo write FvlrSaldo; //Valor referente ao saldo da operação de transporte.
  end;

const
  sntpDespesas = 'tpDespesas';
  sntpDespesas_vlrDespesas = 'vlrDespesas';
  sntpDespesas_descricao = 'descricao';

type
  ttpDespesas = class( tBaseNddWS ) // Informações de despesas da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FvlrDespesas: string; // (E)
    Fdescricao: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property vlrDespesas: string read FvlrDespesas write FvlrDespesas; //Valor total das despesas.
    property descricao: string read Fdescricao write Fdescricao; //Descrição das despesas que deram origem ao valor.
  end;

const
  sntpValoresSemMF = 'tpValoresSemMF';
  sntpValoresSemMF_vlrFrete = 'vlrFrete';
  sntpValoresSemMF_despesas = 'despesas';
  sntpValoresSemMF_retencoes = 'retencoes';
  sntpValoresSemMF_vlrCombustivel = 'vlrCombustivel';
  sntpValoresSemMF_vlrPedagio = 'vlrPedagio';
  sntpValoresSemMF_desconto = 'desconto';

type
  ttpValoresSemMF = class( tBaseNddWS ) // Informações dos valores da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FvlrFrete: string; // (E)
    FvlrFrete_IsSet_: boolean;
    Fdespesas: ttpDespesas; // (E)
    Fdespesas_IsSet_: boolean;
    Fretencoes: ttpImpostos; // (E)
    Fretencoes_IsSet_: boolean;
    FvlrCombustivel: string; // (E)
    FvlrCombustivel_IsSet_: boolean;
    FvlrPedagio: string; // (E)
    FvlrPedagio_IsSet_: boolean;
    Fdesconto: ttpDescontoSemMF; // (E)
    Fdesconto_IsSet_: boolean;
    procedure SetvlrFrete(value:string);
    procedure Setdespesas(value:ttpDespesas);
    procedure Setretencoes(value:ttpImpostos);
    procedure SetvlrCombustivel(value:string);
    procedure SetvlrPedagio(value:string);
    procedure Setdesconto(value:ttpDescontoSemMF);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property vlrFrete: string read FvlrFrete write SetvlrFrete; //Valor do frete. Este valor é participante do valor total da operação de transporte a ser paga ao transportador.
    property vlrFrete_IsSet_:boolean read FvlrFrete_IsSet_;
    property despesas: ttpDespesas read Fdespesas write Setdespesas; //Despesas a serem levadas em consideração no pagamento das operações de transporte. Este valor é participante do valor total da operação de transporte a ser paga ao transportador.
    property despesas_IsSet_:boolean read Fdespesas_IsSet_;
    property retencoes: ttpImpostos read Fretencoes write Setretencoes; //Retenções de valroes para a operação de transporte.
    property retencoes_IsSet_:boolean read Fretencoes_IsSet_;
    property vlrCombustivel: string read FvlrCombustivel write SetvlrCombustivel; //Valor do combustível. Este valor é participante do valor total da operação de transporte a ser paga ao transportador.
    property vlrCombustivel_IsSet_:boolean read FvlrCombustivel_IsSet_;
    property vlrPedagio: string read FvlrPedagio write SetvlrPedagio; //Valor de vale pedágio a ser pago ao condutor da operação de transporte.
    property vlrPedagio_IsSet_:boolean read FvlrPedagio_IsSet_;
    property desconto: ttpDescontoSemMF read Fdesconto write Setdesconto; //Desconto aplicado a operação de transporte
    property desconto_IsSet_:boolean read Fdesconto_IsSet_;
  end;

const
  snsemMF = 'semMF';
  snsemMF_valores = 'valores';

type
  tsemMF = class( tBaseNddWS ) // Alteração em dados de valores para operação de transporte sem movimentação financeira
  private
    F_NameSpaceAlias: string;
    Fvalores: ttpValoresSemMF; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property valores: ttpValoresSemMF read Fvalores; // write Fvalores; //Valores financeiros a serem alterados
  end;

const
  sndescontos = 'descontos';
  sndescontos_desconto = 'desconto';

type
  tdescontos = class( tBaseNddWS ) // Descontos a serem adicionados na parcela de saldo.
  private
    F_NameSpaceAlias: string;
    Fdesconto: tManagedStringList; // of ttpDescontoParcela(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property desconto: tManagedStringList read Fdesconto write Fdesconto; // of ttpDescontoParcela
  end;

const
  sntpRetornoIdentificacao = 'tpRetornoIdentificacao';
  sntpRetornoIdentificacao_serie = 'serie';
  sntpRetornoIdentificacao_numero = 'numero';
  sntpRetornoIdentificacao_dataEmissao = 'dataEmissao';

type
  ttpRetornoIdentificacao = class( tBaseNddWS ) // Define os dados de identificação para o retorno.
  private
    F_NameSpaceAlias: string;
    Fserie: string; // (E)
    Fserie_IsSet_: boolean;
    Fnumero: string; // (E)
    Fnumero_IsSet_: boolean;
    FdataEmissao: string; // (E)
    FdataEmissao_IsSet_: boolean;
    procedure Setserie(value:string);
    procedure Setnumero(value:string);
    procedure SetdataEmissao(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property serie: string read Fserie write Setserie; //Número de série da operação de transporte,
    property serie_IsSet_:boolean read Fserie_IsSet_;
    property numero: string read Fnumero write Setnumero; //Número da operação de transporte.
    property numero_IsSet_:boolean read Fnumero_IsSet_;
    property dataEmissao: string read FdataEmissao write SetdataEmissao; //Data e hora da emissão  para a operação de transporte.
    property dataEmissao_IsSet_:boolean read FdataEmissao_IsSet_;
  end;

const
  sndependencia = 'dependencia';
  sndependencia_descricao = 'descricao';

type
  tdependencia = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fdescricao: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property descricao: string read Fdescricao write Fdescricao; //Descrição da dependência do documento.
  end;

const
  sndependencias = 'dependencias';
  sndependencias_dependencia = 'dependencia';

type
  tdependencias = class( tBaseNddWS ) // Lista de dependências do documento em questão.
  private
    F_NameSpaceAlias: string;
    Fdependencia: tManagedStringList; // of tdependencia(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dependencia: tManagedStringList read Fdependencia write Fdependencia; // of tdependencia
  end;

const
  sntpDocumento = 'tpDocumento';
  sntpDocumento_tipo = 'tipo';
  sntpDocumento_obrigatorio = 'obrigatorio';
  sntpDocumento_dependencias = 'dependencias';

type
  ttpDocumento = class( tBaseNddWS ) // Documentos de origem da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Ftipo: string; // (E)
    Fobrigatorio: tbyte; // (E)
    Fobrigatorio_IsSet_: boolean;
    Fdependencias: tdependencias; // (E)
    procedure Setobrigatorio(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property tipo: string read Ftipo write Ftipo; //Tipo de documentto.
    property obrigatorio: tbyte read Fobrigatorio write Setobrigatorio; //Indica se o documento é obigatório entregar ele para a coleta. 1 é obrigatório e 2 = não. Caso não for informado este campo o valor padrão será 2.
    property obrigatorio_IsSet_:boolean read Fobrigatorio_IsSet_;
    property dependencias: tdependencias read Fdependencias; // write Fdependencias;
  end;

const
  sndocumentos_tpAlterarParcela = 'documentos';
  sndocumentos_tpAlterarParcela_documento = 'documento';

type
  tdocumentos_tpAlterarParcela = class( tBaseNddWS ) // Lista de documentos a serem coletados no posto credenciado para realização do registro de passagem.
  private
    F_NameSpaceAlias: string;
    Fdocumento: tManagedStringList; // of ttpDocumento(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property documento: tManagedStringList read Fdocumento write Fdocumento; // of ttpDocumento
  end;

const
  sntpAlterarParcela = 'tpAlterarParcela';
  sntpAlterarParcela_nome = 'nome';
  sntpAlterarParcela_tipoPgto = 'tipoPgto';
  sntpAlterarParcela_valorAplicado = 'valorAplicado';
  sntpAlterarParcela_valorReal = 'valorReal';
  sntpAlterarParcela_documentos = 'documentos';
  sntpAlterarParcela_descontos = 'descontos';
  sntpAlterarParcela_restricoes = 'restricoes';
  sntpAlterarParcela_retencoes = 'retencoes';
  sntpAlterarParcela_rubrica = 'rubrica';

type
  ttpAlterarParcela = class( tBaseNddWS ) // Dados referente a alteração de parcela.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    FtipoPgto: ttpTipoPagamento; // (E)
    FvalorAplicado: string; // (E)
    FvalorReal: string; // (E)
    FvalorReal_IsSet_: boolean;
    Fdocumentos: tdocumentos_tpAlterarParcela; // (E)
    Fdocumentos_IsSet_: boolean;
    Fdescontos: tdescontos_tpAlterarParcela; // (E)
    Fdescontos_IsSet_: boolean;
    Frestricoes: trestricoes_tpAlterarParcela; // (E)
    Frestricoes_IsSet_: boolean;
    Fretencoes: ttpImpostos; // (E)
    Fretencoes_IsSet_: boolean;
    Frubrica: tbyte; // (E)
    procedure SetvalorReal(value:string);
    procedure Setdocumentos(value:tdocumentos_tpAlterarParcela);
    procedure Setdescontos(value:tdescontos_tpAlterarParcela);
    procedure Setrestricoes(value:trestricoes_tpAlterarParcela);
    procedure Setretencoes(value:ttpImpostos);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome para apresentação da parcela dentro do sistema.
    property tipoPgto: ttpTipoPagamento read FtipoPgto; // write FtipoPgto; //Define o tipo de pagamento da parcela.
    property valorAplicado: string read FvalorAplicado write FvalorAplicado; //Valor aplicado para a parcela. Não levando em consideração os descontos.
    property valorReal: string read FvalorReal write SetvalorReal; //Valor real para pagamento da parcela. Esta tag deve ser informada quando o valor real é diferente do valor aplicado, neste caso é porque houve descontos nesta parcela. Caso não seja informado, será assumido que é o mesmo valor do aplicado.
    property valorReal_IsSet_:boolean read FvalorReal_IsSet_;
    property documentos: tdocumentos_tpAlterarParcela read Fdocumentos write Setdocumentos;
    property documentos_IsSet_:boolean read Fdocumentos_IsSet_;
    property descontos: tdescontos_tpAlterarParcela read Fdescontos write Setdescontos;
    property descontos_IsSet_:boolean read Fdescontos_IsSet_;
    property restricoes: trestricoes_tpAlterarParcela read Frestricoes write Setrestricoes;
    property restricoes_IsSet_:boolean read Frestricoes_IsSet_;
    property retencoes: ttpImpostos read Fretencoes write Setretencoes; //Valores de retenção.
    property retencoes_IsSet_:boolean read Fretencoes_IsSet_;
    property rubrica: tbyte read Frubrica write Frubrica; //Informar qual rubrica o valor se refere. 1 = Frete, 2 = Combustível e 3 = Despesa
  end;

const
  sndocumentos_tpParcela = 'documentos';
  sndocumentos_tpParcela_documento = 'documento';

type
  tdocumentos_tpParcela = class( tBaseNddWS ) // Lista de documentos a serem coletados no posto credenciado para realização do registro de passagem.
  private
    F_NameSpaceAlias: string;
    Fdocumento: tManagedStringList; // of ttpDocumento(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property documento: tManagedStringList read Fdocumento write Fdocumento; // of ttpDocumento
  end;

const
  sntpParcela = 'tpParcela';
  sntpParcela_nome = 'nome';
  sntpParcela_tipoPgto = 'tipoPgto';
  sntpParcela_valorAplicado = 'valorAplicado';
  sntpParcela_valorReal = 'valorReal';
  sntpParcela_documentos = 'documentos';
  sntpParcela_descontos = 'descontos';
  sntpParcela_restricoes = 'restricoes';

type
  ttpParcela = class( tBaseNddWS ) // Define os dados de parcla para pagamento.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    FtipoPgto: ttpTipoPagamento; // (E)
    FvalorAplicado: string; // (E)
    FvalorReal: string; // (E)
    FvalorReal_IsSet_: boolean;
    Fdocumentos: tdocumentos_tpParcela; // (E)
    Fdocumentos_IsSet_: boolean;
    Fdescontos: tdescontos_tpParcela; // (E)
    Fdescontos_IsSet_: boolean;
    Frestricoes: trestricoes; // (E)
    Frestricoes_IsSet_: boolean;
    procedure SetvalorReal(value:string);
    procedure Setdocumentos(value:tdocumentos_tpParcela);
    procedure Setdescontos(value:tdescontos_tpParcela);
    procedure Setrestricoes(value:trestricoes);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome para apresentação da parcela dentro do sistema.
    property tipoPgto: ttpTipoPagamento read FtipoPgto; // write FtipoPgto; //Define o tipo de pagamento da parcela.
    property valorAplicado: string read FvalorAplicado write FvalorAplicado; //Valor aplicado para a parcela. Não levando em consideração os descontos.
    property valorReal: string read FvalorReal write SetvalorReal; //Valor real para pagamento da parcela. Esta tag deve ser informada quando o valor real é diferente do valor aplicado, neste caso é porque houve descontos nesta parcela. Caso não seja informado, será assumido que é o mesmo valor do aplicado.
    property valorReal_IsSet_:boolean read FvalorReal_IsSet_;
    property documentos: tdocumentos_tpParcela read Fdocumentos write Setdocumentos;
    property documentos_IsSet_:boolean read Fdocumentos_IsSet_;
    property descontos: tdescontos_tpParcela read Fdescontos write Setdescontos;
    property descontos_IsSet_:boolean read Fdescontos_IsSet_;
    property restricoes: trestricoes read Frestricoes write Setrestricoes;
    property restricoes_IsSet_:boolean read Frestricoes_IsSet_;
  end;

const
  snparcelas = 'parcelas';
  snparcelas_parcela = 'parcela';

type
  tparcelas = class( tBaseNddWS ) // Lista de parcelas para pagamento da operação de transporte. As parcelas devem serão definidas para definir a maneira de pagar o valor total (frete + combustivel + despesas - descontos - impostos)
  private
    F_NameSpaceAlias: string;
    Fparcela: tManagedStringList; // of ttpParcela(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property parcela: tManagedStringList read Fparcela write Fparcela; // of ttpParcela
  end;

const
  sninformacoes = 'informacoes';
  sninformacoes_parcelas = 'parcelas';

type
  tinformacoes = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fparcelas: tparcelas; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property parcelas: tparcelas read Fparcelas; // write Fparcelas;
  end;

const
  sntpParcelamento = 'tpParcelamento';
  sntpParcelamento_regraERP = 'regraERP';
  sntpParcelamento_informacoes = 'informacoes';

type
  ttpParcelamento = class( tBaseNddWS ) // Define os dados do parcelamento.
  private
    F_NameSpaceAlias: string;
    FregraERP: string; // (E)
    Finformacoes: tinformacoes; // (E)
    Finformacoes_IsSet_: boolean;
    FregraERP_isSet_: boolean;
    procedure Setinformacoes(value:tinformacoes);
    procedure SetregraERP(const Value: string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property regraERP: string read FregraERP write SetregraERP; //Nome da regra de parcelamento no ERP para a integração.
    property regraERP_isSet_:boolean read FregraERP_isSet_;
    property informacoes: tinformacoes read Finformacoes write Setinformacoes;
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
  end;

const
  snpedagio = 'pedagio';

type
  tpedagio = ttpRetornoPedagio; // Dados refetentes ao pedágio para operações de transporte sem direcionamento de pedágio.

const
  snndot_tpAutorizacaoOT = 'ndot';
  snndot_tpAutorizacaoOT_numero = 'numero';
  snndot_tpAutorizacaoOT_ndotCodVerificador = 'ndotCodVerificador';

type
  tndot_tpAutorizacaoOT = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: string; // (E)
    FndotCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: string read Fnumero write Fnumero; //Número que identifica a operação de transporte sem CIOT.
    property ndotCodVerificador: string read FndotCodVerificador write FndotCodVerificador; //Protocolo de autorização disponibilizado para o NDOT.
  end;

const
  snciot_tpAutorizacaoOT = 'ciot';
  snciot_tpAutorizacaoOT_numero = 'numero';
  snciot_tpAutorizacaoOT_ciotCodVerificador = 'ciotCodVerificador';

type
  tciot_tpAutorizacaoOT = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: string; // (E)
    FciotCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: string read Fnumero write Fnumero; //Código de identificação da operação de transporte.
    property ciotCodVerificador: string read FciotCodVerificador write FciotCodVerificador; //Protocolo de autorização disponibilizado pela ANTT. Será informado XXXX caso seja uma emissão em contingência.
  end;

const
  sntpAutorizacaoOT = 'tpAutorizacaoOT';
  sntpAutorizacaoOT_ciot = 'ciot';
  sntpAutorizacaoOT_ndot = 'ndot';

type
  ttpAutorizacaoOT = class( tBaseNddWS ) // Informações relacionadas a autorização de uma operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fciot: tciot_tpAutorizacaoOT; // (E)
    Fciot_IsSet_: boolean;
    Fndot: tndot_tpAutorizacaoOT; // (E)
    Fndot_IsSet_: boolean;
    procedure Setciot(value:tciot_tpAutorizacaoOT);
    procedure Setndot(value:tndot_tpAutorizacaoOT);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ciot: tciot_tpAutorizacaoOT read Fciot write Setciot;
    property ciot_IsSet_:boolean read Fciot_IsSet_;
    property ndot: tndot_tpAutorizacaoOT read Fndot write Setndot;
    property ndot_IsSet_:boolean read Fndot_IsSet_;
  end;

const
  sntpCabecalhoImpressaoRetorno = 'tpCabecalhoImpressaoRetorno';
  sntpCabecalhoImpressaoRetorno_pontoEmissor = 'pontoEmissor';
  sntpCabecalhoImpressaoRetorno_autorizacao = 'autorizacao';
  sntpCabecalhoImpressaoRetorno_conteudo = 'conteudo';

type
  ttpCabecalhoImpressaoRetorno = class( tBaseNddWS ) // Impressão de documentos
  private
    F_NameSpaceAlias: string;
    FpontoEmissor: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    Fconteudo: tbyte; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property pontoEmissor: string read FpontoEmissor write FpontoEmissor;
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao; //Operação de transporte a ser impressa.
    property conteudo: tbyte read Fconteudo write Fconteudo;
  end;

const
  sntpRetornoEncerramentoOT = 'tpRetornoEncerramentoOT';
  sntpRetornoEncerramentoOT_dataHora = 'dataHora';
  sntpRetornoEncerramentoOT_autorizacao = 'autorizacao';
  sntpRetornoEncerramentoOT_protocoloEnce = 'protocoloEnce';

type
  ttpRetornoEncerramentoOT = class( tBaseNddWS ) // Informações do retorno de encerramento da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FdataHora: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    FprotocoloEnce: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataHora: string read FdataHora write FdataHora; //Data e hora do encerramento.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao;
    property protocoloEnce: string read FprotocoloEnce write FprotocoloEnce; //Protocolo de encerramento da operação de transporte.
  end;

const
  sntpInfEnceOT = 'tpInfEnceOT';
  sntpInfEnceOT_cnpj = 'cnpj';
  sntpInfEnceOT_autorizacao = 'autorizacao';
  sntpInfEnceOT_encerramento = 'encerramento';
  antpInfEnceOT_ID = 'Id';

type
  ttpInfEnceOT = class( tBaseNddWS ) // Informações do encerramento de operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    Fencerramento: tencerramento; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante da operação que se deseja encerrar.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao; //Operação de transporte a ser encerrada.
    property encerramento: tencerramento read Fencerramento; // write Fencerramento;
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  sntpEncerramentoOT = 'tpEncerramentoOT';
  sntpEncerramentoOT_infEnceOT = 'infEnceOT';
  sntpEncerramentoOT_Signature = 'Signature';
  antpEncerramentoOT_versao = 'versao';
  antpEncerramentoOT_token = 'token';

type
  ttpEncerramentoOT = class( tBaseNddWS ) // Encerramento de operação de transporte
  private
    F_NameSpaceAlias: string;
    FinfEnceOT: ttpInfEnceOT; // (E)
    FSignature: tSignature; // (X)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infEnceOT: ttpInfEnceOT read FinfEnceOT; // write FinfEnceOT; //Informações referentes a operação de transporte a ser encerrada.
    property Signature: tSignature read FSignature; // write FSignature;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sntpSolicitarImpressao = 'tpSolicitarImpressao';
  sntpSolicitarImpressao_cnpj = 'cnpj';
  sntpSolicitarImpressao_autorizacao = 'autorizacao';
  sntpSolicitarImpressao_ptEmissor = 'ptEmissor';
  antpSolicitarImpressao_versao = 'versao';
  antpSolicitarImpressao_token = 'token';

type
  ttpSolicitarImpressao = class( tBaseNddWS ) // Solicitar a impressão de uma operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    FptEmissor: string; // (E)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao; //Operação de transporte.
    property ptEmissor: string read FptEmissor write FptEmissor; //Ponto emissor para realizar a impressão.
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sninfPgtoOT = 'infPgtoOT';
  sninfPgtoOT_cnpj = 'cnpj';
  sninfPgtoOT_autorizacao = 'autorizacao';
  sninfPgtoOT_nomeParcela = 'nomeParcela';
  sninfPgtoOT_motivo = 'motivo';
  aninfPgtoOT_ID = 'Id';

type
  tinfPgtoOT = class( tBaseNddWS ) // Informações sobre a operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    FnomeParcela: string; // (E)
    Fmotivo: string; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao; //Dados da autorização para a operação de transporte da qual a parcela será paga.
    property nomeParcela: string read FnomeParcela write FnomeParcela; //Nome da parcela a ser paga.
    property motivo: string read Fmotivo write Fmotivo; //Motivo da solicitação do pagamento imediato.
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  sntpPagamentoImediatoOT = 'tpPagamentoImediatoOT';
  sntpPagamentoImediatoOT_infPgtoOT = 'infPgtoOT';
  sntpPagamentoImediatoOT_Signature = 'Signature';
  antpPagamentoImediatoOT_versao = 'versao';
  antpPagamentoImediatoOT_token = 'token';

type
  ttpPagamentoImediatoOT = class( tBaseNddWS ) // Dados necessários para o pagamento imediato de uma parcela de uma OT.
  private
    F_NameSpaceAlias: string;
    FinfPgtoOT: tinfPgtoOT; // (E)
    //FSignature: tSignature; // (X)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infPgtoOT: tinfPgtoOT read FinfPgtoOT; // write FinfPgtoOT;
    //property Signature: tSignature read FSignature; // write FSignature;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sntpRetornoCancelamento = 'tpRetornoCancelamento';
  sntpRetornoCancelamento_dataHora = 'dataHora';
  sntpRetornoCancelamento_autorizacao = 'autorizacao';
  sntpRetornoCancelamento_protocoloCanc = 'protocoloCanc';

type
  ttpRetornoCancelamento = class( tBaseNddWS ) // Informações sobre o cancelamento.
  private
    F_NameSpaceAlias: string;
    FdataHora: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    FprotocoloCanc: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataHora: string read FdataHora write FdataHora; //Data e hora do cancelamento.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao;
    property protocoloCanc: string read FprotocoloCanc write FprotocoloCanc; //Protocolo de cancelamento disponibilizado pela ANTT.
  end;

const
  sninfCancOT = 'infCancOT';
  sninfCancOT_cnpj = 'cnpj';
  sninfCancOT_autorizacao = 'autorizacao';
  sninfCancOT_motivo = 'motivo';
  aninfCancOT_ID = 'Id';

type
  tinfCancOT = class( tBaseNddWS ) // Informações referentes a operação de transporte a ser cancelada.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    Fmotivo: string; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante da operação que se deseja cancelar.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao; //Operação de transporte a ser cancelada.
    property motivo: string read Fmotivo write Fmotivo; //Motivo pelo qual foi solicitado o cancelamento da operação de transporte.
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  sntpCancelamento = 'tpCancelamento';
  sntpCancelamento_infCancOT = 'infCancOT';
  sntpCancelamento_Signature = 'Signature';
  antpCancelamento_versao = 'versao';
  antpCancelamento_token = 'token';

type
  ttpCancelamento = class( tBaseNddWS ) // Cancelamento da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FinfCancOT: tinfCancOT; // (E)
    FSignature: tSignature; // (X)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infCancOT: tinfCancOT read FinfCancOT; // write FinfCancOT;
    property Signature: tSignature read FSignature; // write FSignature;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sntpEnderecoComIBGE = 'tpEnderecoComIBGE';
  sntpEnderecoComIBGE_UF = 'UF';
  sntpEnderecoComIBGE_codigoMunicipio = 'codigoMunicipio';
  sntpEnderecoComIBGE_bairro = 'bairro';
  sntpEnderecoComIBGE_logradouro = 'logradouro';
  sntpEnderecoComIBGE_numero = 'numero';
  sntpEnderecoComIBGE_CEP = 'CEP';
  sntpEnderecoComIBGE_complemento = 'complemento';

type
  ttpEnderecoComIBGE = class( tBaseNddWS ) // Tipo Dados do Endereço
  private
    F_NameSpaceAlias: string;
    FUF: string; // (E)
    FcodigoMunicipio: string; // (E)
    Fbairro: string; // (E)
    Flogradouro: string; // (E)
    Fnumero: string; // (E)
    FCEP: string; // (E)
    Fcomplemento: string; // (E)
    Fcomplemento_IsSet_: boolean;
    procedure Setcomplemento(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property UF: string read FUF write FUF; //Sigla da UF, , informar EX para operações com o exterior.
    property codigoMunicipio: string read FcodigoMunicipio write FcodigoMunicipio; //Código do município (utilizar a tabela do IBGE), informar 9999999 para operações com o exterior.
    property bairro: string read Fbairro write Fbairro; //Nome do bairro. Informar EXTERIOR caso seja do exterior.
    property logradouro: string read Flogradouro write Flogradouro; //Nome do logradouro. Informar EXTERIOR caso seja do exterior.
    property numero: string read Fnumero write Fnumero; //Número. Informar 0 caso seja do exterior.
    property CEP: string read FCEP write FCEP; //Número do CEP. Informar 00000000 caso seja do exterior.
    property complemento: string read Fcomplemento write Setcomplemento; //Complemento
    property complemento_IsSet_:boolean read Fcomplemento_IsSet_;
  end;

const
  sntpSubcontratado = 'tpSubcontratado';
  sntpSubcontratado_cnpj = 'cnpj';
  sntpSubcontratado_cpf = 'cpf';
  sntpSubcontratado_nome = 'nome';
  sntpSubcontratado_endereco = 'endereco';

type
  ttpSubcontratado = class( tBaseNddWS ) // Informações do subcontratado
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    Fcpf: string; // (E)
    Fcpf_IsSet_: boolean;
    Fnome: string; // (E)
    Fendereco: ttpEnderecoComIBGE; // (E)
    procedure Setcnpj(value:string);
    procedure Setcpf(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Setcnpj; //Número do CNPJ.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
    property cpf: string read Fcpf write Setcpf; //Número do CPF.
    property cpf_IsSet_:boolean read Fcpf_IsSet_;
    property nome: string read Fnome write Fnome; //Razão social ou nome do subcontratado.
    property endereco: ttpEnderecoComIBGE read Fendereco; // write Fendereco; //Informações sobre o endereço do subcontratado.
  end;

const
  sntpDestinatario = 'tpDestinatario';
  sntpDestinatario_cnpj = 'cnpj';
  sntpDestinatario_cpf = 'cpf';
  sntpDestinatario_nome = 'nome';
  sntpDestinatario_endereco = 'endereco';

type
  ttpDestinatario = class( tBaseNddWS ) // Informações do destinatário da carga.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    Fcpf: string; // (E)
    Fcpf_IsSet_: boolean;
    Fnome: string; // (E)
    Fendereco: ttpEnderecoComIBGE; // (E)
    procedure Setcnpj(value:string);
    procedure Setcpf(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Setcnpj; //Número do CNPJ. Informar 0 caso o destinatário seja do exterior.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
    property cpf: string read Fcpf write Setcpf; //Número do CPF. Informar 0 caso o destinatário seja do exterior.
    property cpf_IsSet_:boolean read Fcpf_IsSet_;
    property nome: string read Fnome write Fnome; //Razão social ou nome do destinatário.
    property endereco: ttpEnderecoComIBGE read Fendereco; // write Fendereco; //Informações sobre o endereço do destinatario
  end;

const
  sntpEnderecoSemIBGE = 'tpEnderecoSemIBGE';
  sntpEnderecoSemIBGE_UF = 'UF';
  sntpEnderecoSemIBGE_cidade = 'cidade';
  sntpEnderecoSemIBGE_bairro = 'bairro';
  sntpEnderecoSemIBGE_logradouro = 'logradouro';
  sntpEnderecoSemIBGE_numero = 'numero';
  sntpEnderecoSemIBGE_CEP = 'CEP';
  sntpEnderecoSemIBGE_complemento = 'complemento';

type
  ttpEnderecoSemIBGE = class( tBaseNddWS ) // Tipo Dados do Endereço
  private
    F_NameSpaceAlias: string;
    FUF: string; // (E)
    Fcidade: string; // (E)
    Fbairro: string; // (E)
    Flogradouro: string; // (E)
    Fnumero: string; // (E)
    Fnumero_IsSet_: boolean;
    FCEP: string; // (E)
    FCEP_IsSet_: boolean;
    Fcomplemento: string; // (E)
    Fcomplemento_IsSet_: boolean;
    procedure Setnumero(value:string);
    procedure SetCEP(value:string);
    procedure Setcomplemento(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property UF: string read FUF write FUF; //Sigla da UF, , informar EX para operações com o exterior.
    property cidade: string read Fcidade write Fcidade; //Cidade do endereço.
    property bairro: string read Fbairro write Fbairro; //Nome do bairro. Informar EXTERIOR caso seja do exterior.
    property logradouro: string read Flogradouro write Flogradouro; //Nome do logradouro. Informar EXTERIOR caso seja do exterior.
    property numero: string read Fnumero write Setnumero; //Número.
    property numero_IsSet_:boolean read Fnumero_IsSet_;
    property CEP: string read FCEP write SetCEP; //Número do CEP.
    property CEP_IsSet_:boolean read FCEP_IsSet_;
    property complemento: string read Fcomplemento write Setcomplemento; //Complemento
    property complemento_IsSet_:boolean read Fcomplemento_IsSet_;
  end;

const
  snestabelecimento_pagamentoPedagio = 'estabelecimento';
  snestabelecimento_pagamentoPedagio_cnpj = 'cnpj';
  snestabelecimento_pagamentoPedagio_nome = 'nome';
  snestabelecimento_pagamentoPedagio_endereco = 'endereco';

type
  testabelecimento_pagamentoPedagio = class( tBaseNddWS ) // Estabelecimento onde foi pago o valor do pedágio.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fnome: string; // (E)
    Fendereco: ttpEnderecoSemIBGE; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ do estabelecimento.
    property nome: string read Fnome write Fnome; //Nome do estabelecimento.
    property endereco: ttpEnderecoSemIBGE read Fendereco; // write Fendereco; //Endereço do estabelecimento.
  end;

const
  snpagamentoPedagio = 'pagamentoPedagio';
  snpagamentoPedagio_dataPagamentoPedagio = 'dataPagamentoPedagio';
  snpagamentoPedagio_estabelecimento = 'estabelecimento';

type
  tpagamentoPedagio = class( tBaseNddWS ) // Dados do pagamento do pedágio.
  private
    F_NameSpaceAlias: string;
    FdataPagamentoPedagio: string; // (E)
    Festabelecimento: testabelecimento_pagamentoPedagio; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataPagamentoPedagio: string read FdataPagamentoPedagio write FdataPagamentoPedagio; //Data que foi realizado o pagamento do pedágio.
    property estabelecimento: testabelecimento_pagamentoPedagio read Festabelecimento; // write Festabelecimento;
  end;

const
  snestabelecimento = 'estabelecimento';
  snestabelecimento_cnpj = 'cnpj';
  snestabelecimento_nome = 'nome';
  snestabelecimento_endereco = 'endereco';

type
  testabelecimento = class( tBaseNddWS ) // Estabelecimento onde foi pago o valor do pedágio.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fnome: string; // (E)
    Fendereco: ttpEnderecoSemIBGE; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ do estabelecimento.
    property nome: string read Fnome write Fnome; //Nome do estabelecimento.
    property endereco: ttpEnderecoSemIBGE read Fendereco; // write Fendereco; //Endereço do estabelecimento.
  end;

const
  snpedagio_tpPgto = 'pedagio';
  snpedagio_tpPgto_valorPago = 'valorPago';
  snpedagio_tpPgto_estabelecimento = 'estabelecimento';
  snpedagio_tpPgto_cpfRecebedor = 'cpfRecebedor';

type
  tpedagio_tpPgto = class( tBaseNddWS ) // Pagamento específico de pedágio.
  private
    F_NameSpaceAlias: string;
    FvalorPago: string; // (E)
    Festabelecimento: testabelecimento; // (E)
    FcpfRecebedor: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property valorPago: string read FvalorPago write FvalorPago; //Valor total do pagamento de pedágio.
    property estabelecimento: testabelecimento read Festabelecimento; // write Festabelecimento;
    property cpfRecebedor: string read FcpfRecebedor write FcpfRecebedor; //Número do CPF do condutor/colaborador que recebeu a carga do pedágio.
  end;

const
  sntpRetornoPessoa = 'tpRetornoPessoa';
  sntpRetornoPessoa_cpf = 'cpf';
  sntpRetornoPessoa_cnpj = 'cnpj';
  sntpRetornoPessoa_nome = 'nome';
  sntpRetornoPessoa_endereco = 'endereco';

type
  ttpRetornoPessoa = class( tBaseNddWS ) // Dados de retorno do cadastro de pessoa.
  private
    F_NameSpaceAlias: string;
    Fcpf: string; // (E)
    Fcpf_IsSet_: boolean;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    Fnome: string; // (E)
    Fendereco: ttpEnderecoSemIBGE; // (E)
    procedure Setcpf(value:string);
    procedure Setcnpj(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cpf: string read Fcpf write Setcpf; //CPF da pessoa.
    property cpf_IsSet_:boolean read Fcpf_IsSet_;
    property cnpj: string read Fcnpj write Setcnpj; //CNPJ da pessoa.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
    property nome: string read Fnome write Fnome; //Nome da pessoa.
    property endereco: ttpEnderecoSemIBGE read Fendereco; // write Fendereco; //Endereço da pessoa.
  end;

const
  sntpRetornoPessoaJuridica = 'tpRetornoPessoaJuridica';
  sntpRetornoPessoaJuridica_cnpj = 'cnpj';
  sntpRetornoPessoaJuridica_nome = 'nome';
  sntpRetornoPessoaJuridica_endereco = 'endereco';

type
  ttpRetornoPessoaJuridica = class( tBaseNddWS ) // Dados de retorno do cadastro de pessoa jurídica.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fnome: string; // (E)
    Fendereco: ttpEnderecoSemIBGE; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da pessoa jurídica.
    property nome: string read Fnome write Fnome; //Nome da pessoa juridica.
    property endereco: ttpEnderecoSemIBGE read Fendereco; // write Fendereco; //Endereço da pessoa jurídica.
  end;

const
  snefetivacao = 'efetivacao';
  snefetivacao_postoCredenciado = 'postoCredenciado';
  snefetivacao_centroTriagem = 'centroTriagem';
  snefetivacao_contratante = 'contratante';
  snefetivacao_confirmacaoEletronica = 'confirmacaoEletronica';
  snefetivacao_automatica = 'automatica';

type
  tefetivacao = class( tBaseNddWS ) // Local da efetivação do pagamento.
  private
    F_NameSpaceAlias: string;
    FpostoCredenciado: ttpRetornoPessoaJuridica; // (E)
    FpostoCredenciado_IsSet_: boolean;
    FcentroTriagem: ttpRetornoPessoaJuridica; // (E)
    FcentroTriagem_IsSet_: boolean;
    Fcontratante: ttpRetornoPessoaJuridica; // (E)
    Fcontratante_IsSet_: boolean;
    FconfirmacaoEletronica: ttpRetornoPessoa; // (E)
    FconfirmacaoEletronica_IsSet_: boolean;
    Fautomatica: tautomatica; // (E)
    Fautomatica_IsSet_: boolean;
    procedure SetpostoCredenciado(value:ttpRetornoPessoaJuridica);
    procedure SetcentroTriagem(value:ttpRetornoPessoaJuridica);
    procedure Setcontratante(value:ttpRetornoPessoaJuridica);
    procedure SetconfirmacaoEletronica(value:ttpRetornoPessoa);
    procedure Setautomatica(value:tautomatica);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property postoCredenciado: ttpRetornoPessoaJuridica read FpostoCredenciado write SetpostoCredenciado; //Pagamento realizado devido a um registro de passagem no posto credenciado.
    property postoCredenciado_IsSet_:boolean read FpostoCredenciado_IsSet_;
    property centroTriagem: ttpRetornoPessoaJuridica read FcentroTriagem write SetcentroTriagem; //Pagamento realizado devido a uma triagem de coleta com sucesso no centro de triagem.
    property centroTriagem_IsSet_:boolean read FcentroTriagem_IsSet_;
    property contratante: ttpRetornoPessoaJuridica read Fcontratante write Setcontratante; //Pagamento realizado devido a uma triagem de coleta com sucesso na contratante.
    property contratante_IsSet_:boolean read Fcontratante_IsSet_;
    property confirmacaoEletronica: ttpRetornoPessoa read FconfirmacaoEletronica write SetconfirmacaoEletronica; //Pagamento realizado devido a uma confirmação eletrônica de recebimento da carga.
    property confirmacaoEletronica_IsSet_:boolean read FconfirmacaoEletronica_IsSet_;
    property automatica: tautomatica read Fautomatica write Setautomatica;
    property automatica_IsSet_:boolean read Fautomatica_IsSet_;
  end;

const
  snparcela = 'parcela';
  snparcela_nome = 'nome';
  snparcela_valorPago = 'valorPago';
  snparcela_efetivacao = 'efetivacao';
  snparcela_comentario = 'comentario';

type
  tparcela = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    FvalorPago: string; // (E)
    Fefetivacao: tefetivacao; // (E)
    Fcomentario: string; // (E)
    Fcomentario_IsSet_: boolean;
    procedure Setcomentario(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome da parcela.
    property valorPago: string read FvalorPago write FvalorPago; //Valor do pagamento realizado
    property efetivacao: tefetivacao read Fefetivacao; // write Fefetivacao;
    property comentario: string read Fcomentario write Setcomentario; //Comentário realizado durante a ação que deu origem ao pagamento.
    property comentario_IsSet_:boolean read Fcomentario_IsSet_;
  end;

const
  snparcelas_frete = 'parcelas';
  snparcelas_frete_parcela = 'parcela';

type
  tparcelas_frete = class( tBaseNddWS ) // Parcelas do CIOT envolvidas no pagamento.
  private
    F_NameSpaceAlias: string;
    Fparcela: tManagedStringList; // of tparcela(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property parcela: tManagedStringList read Fparcela write Fparcela; // of tparcela
  end;

const
  snfrete = 'frete';
  snfrete_parcelas = 'parcelas';

type
  tfrete = class( tBaseNddWS ) // Pagamento específico do frete, levando em consideração o combustível e também as despesas.
  private
    F_NameSpaceAlias: string;
    Fparcelas: tparcelas_frete; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property parcelas: tparcelas_frete read Fparcelas; // write Fparcelas;
  end;

const
  sntpPgto = 'tpPgto';
  sntpPgto_autorizacao = 'autorizacao';
  sntpPgto_dataHora = 'dataHora';
  sntpPgto_pedagio = 'pedagio';
  sntpPgto_frete = 'frete';

type
  ttpPgto = class( tBaseNddWS ) // Dados de pagamento realizado.
  private
    F_NameSpaceAlias: string;
    Fautorizacao: ttpAutorizacaoOT; // (E)
    FdataHora: string; // (E)
    Fpedagio: tpedagio_tpPgto; // (E)
    Fpedagio_IsSet_: boolean;
    Ffrete: tfrete; // (E)
    Ffrete_IsSet_: boolean;
    procedure Setpedagio(value:tpedagio_tpPgto);
    procedure Setfrete(value:tfrete);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao; //Identificação da operação de transporte.
    property dataHora: string read FdataHora write FdataHora; //Data e hora que o pagamento foi realizado.
    property pedagio: tpedagio_tpPgto read Fpedagio write Setpedagio;
    property pedagio_IsSet_:boolean read Fpedagio_IsSet_;
    property frete: tfrete read Ffrete write Setfrete;
    property frete_IsSet_:boolean read Ffrete_IsSet_;
  end;

const
  snpgtos = 'pgtos';
  snpgtos_pgto = 'pgto';

type
  tpgtos = class( tBaseNddWS ) // Pagamentos realizados.
  private
    F_NameSpaceAlias: string;
    Fpgto: tManagedStringList; // of ttpPgto(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property pgto: tManagedStringList read Fpgto write Fpgto; // of ttpPgto
  end;

const
  sntpRemetente = 'tpRemetente';
  sntpRemetente_cnpj = 'cnpj';
  sntpRemetente_cpf = 'cpf';
  sntpRemetente_nome = 'nome';
  sntpRemetente_endereco = 'endereco';

type
  ttpRemetente = class( tBaseNddWS ) // Informações do remetente da carga.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    Fcpf: string; // (E)
    Fcpf_IsSet_: boolean;
    Fnome: string; // (E)
    Fendereco: ttpEnderecoComIBGE; // (E)
    procedure Setcnpj(value:string);
    procedure Setcpf(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Setcnpj; //Número do CNPJ. Informar 0 caso o CNPJ seja de remetente do exterior.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
    property cpf: string read Fcpf write Setcpf; //Número do CPF. Informar 0 caso o CPF seja de remetente do exterior.
    property cpf_IsSet_:boolean read Fcpf_IsSet_;
    property nome: string read Fnome write Fnome; //Razão social ou nome do remetente.
    property endereco: ttpEnderecoComIBGE read Fendereco; // write Fendereco; //Informações sobre o endereço do remetente.
  end;

const
  sntpConsignatario = 'tpConsignatario';
  sntpConsignatario_cnpj = 'cnpj';
  sntpConsignatario_cpf = 'cpf';
  sntpConsignatario_nome = 'nome';
  sntpConsignatario_endereco = 'endereco';

type
  ttpConsignatario = class( tBaseNddWS ) // Informações do consignatário da carga.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    Fcpf: string; // (E)
    Fcpf_IsSet_: boolean;
    Fnome: string; // (E)
    Fendereco: ttpEnderecoComIBGE; // (E)
    procedure Setcnpj(value:string);
    procedure Setcpf(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Setcnpj; //Número do CNPJ. Informar 0 caso o consignatário seja do exterior.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
    property cpf: string read Fcpf write Setcpf; //Número do CPF. Informar 0 caso o consignatário seja do exterior.
    property cpf_IsSet_:boolean read Fcpf_IsSet_;
    property nome: string read Fnome write Fnome; //Razão social ou nome do consignatário da carga.
    property endereco: ttpEnderecoComIBGE read Fendereco; // write Fendereco; //Informações sobre o endereço do consignatário.
  end;

const
  sntpContato = 'tpContato';
  sntpContato_nome = 'nome';
  sntpContato_contato = 'contato';

type
  ttpContato = class( tBaseNddWS ) // Informações sobre o contato.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    Fcontato: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome do contato.
    property contato: string read Fcontato write Fcontato; //Informação de contato que pode ser o telefone ou email.
  end;

const
  sndocumentoOriginario = 'documentoOriginario';
  sndocumentoOriginario_tipo = 'tipo';
  sndocumentoOriginario_numero = 'numero';

type
  tdocumentoOriginario = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Ftipo: string; // (E)
    Fnumero: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property tipo: string read Ftipo write Ftipo; //Descrever qual o tipo do documento qu está sendo informado.
    property numero: string read Fnumero write Fnumero; //Descrever qual a numeração do documentos.
  end;

const
  sndocumentosOriginarios = 'documentosOriginarios';
  sndocumentosOriginarios_documentoOriginario = 'documentoOriginario';

type
  tdocumentosOriginarios = class( tBaseNddWS ) // Lista de documentos que deram origem a carga.
  private
    F_NameSpaceAlias: string;
    FdocumentoOriginario: tManagedStringList; // of tdocumentoOriginario(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property documentoOriginario: tManagedStringList read FdocumentoOriginario write FdocumentoOriginario; // of tdocumentoOriginario
  end;

const
  snTACagregado = 'TACagregado';
  snTACagregado_remetente = 'remetente';

type
  tTACagregado = class( tBaseNddWS ) // Operação de transporte com TAC-agregado.
  private
    F_NameSpaceAlias: string;
    Fremetente: ttpRemetente; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property remetente: ttpRemetente read Fremetente; // write Fremetente; //Informações sobre o remetente da carga.
  end;

const
  snpadrao = 'padrao';
  snpadrao_codigoSH = 'codigoSH';
  snpadrao_quantidade = 'quantidade';
  snpadrao_remetente = 'remetente';
  snpadrao_destinatario = 'destinatario';

type
  tpadrao = class( tBaseNddWS ) // Operação de transporte padrão.
  private
    F_NameSpaceAlias: string;
    FcodigoSH: string; // (E)
    Fquantidade: string; // (E)
    Fremetente: ttpRemetente; // (E)
    Fdestinatario: ttpDestinatario; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property codigoSH: string read FcodigoSH write FcodigoSH; //Código do Sistema Harmonizado. Define qual a natureza da carga conforme a tabela de códigos do Sistema Harmonizado de Designação e de Codificação de Mercadorias.
    property quantidade: string read Fquantidade write Fquantidade; //Quantidade da carga em Kg.
    property remetente: ttpRemetente read Fremetente; // write Fremetente; //Informações sobre o remetente da carga.
    property destinatario: ttpDestinatario read Fdestinatario; // write Fdestinatario; //Informações sobre o destinatário da carga.
  end;

const
  sntpCarga = 'tpCarga';
  sntpCarga_padrao = 'padrao';
  sntpCarga_TACagregado = 'TACagregado';
  sntpCarga_consignatario = 'consignatario';
  sntpCarga_proprietarioCarga = 'proprietarioCarga';
  sntpCarga_documentosOriginarios = 'documentosOriginarios';

type
  ttpCarga = class( tBaseNddWS ) // Informações sobre a carga da viagem.
  private
    F_NameSpaceAlias: string;
    Fpadrao: tpadrao; // (E)
    Fpadrao_IsSet_: boolean;
    FTACagregado: tTACagregado; // (E)
    FTACagregado_IsSet_: boolean;
    Fconsignatario: ttpConsignatario; // (E)
    Fconsignatario_IsSet_: boolean;
    FproprietarioCarga: tbyte; // (E)
    FdocumentosOriginarios: tdocumentosOriginarios; // (E)
    FdocumentosOriginarios_IsSet_: boolean;
    procedure Setpadrao(value:tpadrao);
    procedure SetTACagregado(value:tTACagregado);
    procedure Setconsignatario(value:ttpConsignatario);
    procedure SetdocumentosOriginarios(value:tdocumentosOriginarios);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property padrao: tpadrao read Fpadrao write Setpadrao;
    property padrao_IsSet_:boolean read Fpadrao_IsSet_;
    property TACagregado: tTACagregado read FTACagregado write SetTACagregado;
    property TACagregado_IsSet_:boolean read FTACagregado_IsSet_;
    property consignatario: ttpConsignatario read Fconsignatario write Setconsignatario; //Informações sobre o consignatário da carga.
    property consignatario_IsSet_:boolean read Fconsignatario_IsSet_;
    property proprietarioCarga: tbyte read FproprietarioCarga write FproprietarioCarga; //Informa o proprietário da carga. 1 = Remetente, 2 = Destinatário, 3 = Consignatários e 4 = Outro.
    property documentosOriginarios: tdocumentosOriginarios read FdocumentosOriginarios write SetdocumentosOriginarios;
    property documentosOriginarios_IsSet_:boolean read FdocumentosOriginarios_IsSet_;
  end;

const
  sntpCondutor = 'tpCondutor';
  sntpCondutor_nome = 'nome';
  sntpCondutor_identidade = 'identidade';
  sntpCondutor_RNTRCTransportador = 'RNTRCTransportador';
  sntpCondutor_endereco = 'endereco';
  sntpCondutor_CNH = 'CNH';
  sntpCondutor_dataEmissaoCNH = 'dataEmissaoCNH';
  sntpCondutor_dataRenovacaoCNH = 'dataRenovacaoCNH';
  sntpCondutor_telefone = 'telefone';
  sntpCondutor_cartaoId = 'cartaoId';

type
  ttpCondutor = class( tBaseNddWS ) // Informações sobre o condutor.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    Fidentidade: string; // (E)
    FRNTRCTransportador: string; // (E)
    FRNTRCTransportador_IsSet_: boolean;
    Fendereco: ttpEnderecoSemIBGE; // (E)
    FCNH: int64; // (E)
    FCNH_IsSet_: boolean;
    FdataEmissaoCNH: string; // (E)
    FdataEmissaoCNH_IsSet_: boolean;
    FdataRenovacaoCNH: string; // (E)
    FdataRenovacaoCNH_IsSet_: boolean;
    Ftelefone: int64; // (E)
    FcartaoId: int64; // (E)
    FcartaoId_IsSet_: boolean;
    procedure SetRNTRCTransportador(value:string);
    procedure SetCNH(value:int64);
    procedure SetdataEmissaoCNH(value:string);
    procedure SetdataRenovacaoCNH(value:string);
    procedure SetcartaoId(value:int64);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome do condutor.
    property identidade: string read Fidentidade write Fidentidade; //Identidade do condutor.
    property RNTRCTransportador: string read FRNTRCTransportador write SetRNTRCTransportador; //Este campo será obrigatório quando o condutor tiver um cartão a ser vinculado, pois esta ação deverá criar o condutor equiparado.
    property RNTRCTransportador_IsSet_:boolean read FRNTRCTransportador_IsSet_;
    property endereco: ttpEnderecoSemIBGE read Fendereco; // write Fendereco; //Endereço do condutor.
    property CNH: int64 read FCNH write SetCNH; //CNH do condutor.
    property CNH_IsSet_:boolean read FCNH_IsSet_;
    property dataEmissaoCNH: string read FdataEmissaoCNH write SetdataEmissaoCNH; //Data de emissão da CNH.
    property dataEmissaoCNH_IsSet_:boolean read FdataEmissaoCNH_IsSet_;
    property dataRenovacaoCNH: string read FdataRenovacaoCNH write SetdataRenovacaoCNH; //Data de renovação da CNH.
    property dataRenovacaoCNH_IsSet_:boolean read FdataRenovacaoCNH_IsSet_;
    property telefone: int64 read Ftelefone write Ftelefone; //Telefone celular do condutor.
    property cartaoId: int64 read FcartaoId write SetcartaoId; //Este será o identificador do cartão que foi entregue ao condutor e será realizado o vínculo na processadora.
    property cartaoId_IsSet_:boolean read FcartaoId_IsSet_;
  end;

const
  sninfCondutor = 'infCondutor';
  sninfCondutor_cpf = 'cpf';
  sninfCondutor_informacoes = 'informacoes';

type
  tinfCondutor = class( tBaseNddWS ) // Dados do condutor
  private
    F_NameSpaceAlias: string;
    Fcpf: string; // (E)
    Finformacoes: ttpCondutor; // (E)
    Finformacoes_IsSet_: boolean;
    procedure Setinformacoes(value:ttpCondutor);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cpf: string read Fcpf write Fcpf; //Número do CPF do condutor.
    property informacoes: ttpCondutor read Finformacoes write Setinformacoes; //Informações do condutor.
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
  end;

const
  sncondutor_alteracao = 'condutor';
  sncondutor_alteracao_tipo = 'tipo';
  sncondutor_alteracao_infCondutor = 'infCondutor';

type
  tcondutor_alteracao = class( tBaseNddWS ) // Dados do condutor
  private
    F_NameSpaceAlias: string;
    Ftipo: tbyte; // (E)
    FinfCondutor: tinfCondutor; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property tipo: tbyte read Ftipo write Ftipo; //Tipo da operação que esta sendo realizada. 1 – Adição de condutor, 2 – Remoção de condutor.
    property infCondutor: tinfCondutor read FinfCondutor; // write FinfCondutor;
  end;

const
  sntpVeiculo = 'tpVeiculo';
  sntpVeiculo_modelo = 'modelo';
  sntpVeiculo_kmLitroModelo = 'kmLitroModelo';
  sntpVeiculo_tipo = 'tipo';
  sntpVeiculo_kmLitroVeiculo = 'kmLitroVeiculo';
  sntpVeiculo_RNTRCTransportador = 'RNTRCTransportador';

type
  ttpVeiculo = class( tBaseNddWS ) // Informações sobre o veículo.
  private
    F_NameSpaceAlias: string;
    Fmodelo: string; // (E)
    FkmLitroModelo: string; // (E)
    FkmLitroModelo_IsSet_: boolean;
    Ftipo: tbyte; // (E)
    FkmLitroVeiculo: string; // (E)
    FkmLitroVeiculo_IsSet_: boolean;
    FRNTRCTransportador: string; // (E)
    procedure SetkmLitroModelo(value:string);
    procedure SetkmLitroVeiculo(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property modelo: string read Fmodelo write Fmodelo; //Modelo do veículo.
    property kmLitroModelo: string read FkmLitroModelo write SetkmLitroModelo; //KM por litro do modelo.
    property kmLitroModelo_IsSet_:boolean read FkmLitroModelo_IsSet_;
    property tipo: tbyte read Ftipo write Ftipo; //Tipo do veículo. Informar 1 = Tração ou 2 = Reboque.
    property kmLitroVeiculo: string read FkmLitroVeiculo write SetkmLitroVeiculo; //KM por litro do veículo.
    property kmLitroVeiculo_IsSet_:boolean read FkmLitroVeiculo_IsSet_;
    property RNTRCTransportador: string read FRNTRCTransportador write FRNTRCTransportador; //RNTRC do transportador responsável.
  end;

const
  snveiculo_veiculos_TACagregado_ANTT = 'veiculo';
  snveiculo_veiculos_TACagregado_ANTT_placa = 'placa';
  snveiculo_veiculos_TACagregado_ANTT_informacoes = 'informacoes';

type
  tveiculo_veiculos_TACagregado_ANTT = class( tBaseNddWS ) // Dados do veículo
  private
    F_NameSpaceAlias: string;
    Fplaca: string; // (E)
    Finformacoes: ttpVeiculo; // (E)
    Finformacoes_IsSet_: boolean;
    procedure Setinformacoes(value:ttpVeiculo);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property placa: string read Fplaca write Fplaca; //Placa do veículo
    property informacoes: ttpVeiculo read Finformacoes write Setinformacoes; //Informações sobre o veículo.
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
  end;

const
  snveiculos_TACagregado_ANTT = 'veiculos';
  snveiculos_TACagregado_ANTT_veiculo = 'veiculo';

type
  tveiculos_TACagregado_ANTT = class( tBaseNddWS ) // Veículos responsáveis pelo transporte.
  private
    F_NameSpaceAlias: string;
    Fveiculo: tManagedStringList; // of tveiculo_veiculos_TACagregado_ANTT(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property veiculo: tManagedStringList read Fveiculo write Fveiculo; // of tveiculo_veiculos_TACagregado_ANTT
  end;

const
  snTACagregado_ANTT = 'TACagregado';
  snTACagregado_ANTT_veiculos = 'veiculos';
  snTACagregado_ANTT_categoriaPedagio = 'categoriaPedagio';

type
  tTACagregado_ANTT = class( tBaseNddWS ) // Alterações da operação de transporte com TAC-agregado. Até 72 horas após a data de término.
  private
    F_NameSpaceAlias: string;
    Fveiculos: tveiculos_TACagregado_ANTT; // (E)
    Fveiculos_IsSet_: boolean;
    FcategoriaPedagio: integer; // (E)
    FcategoriaPedagio_IsSet_: boolean;
    procedure Setveiculos(value:tveiculos_TACagregado_ANTT);
    procedure SetcategoriaPedagio(value:integer);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property veiculos: tveiculos_TACagregado_ANTT read Fveiculos write Setveiculos;
    property veiculos_IsSet_:boolean read Fveiculos_IsSet_;
    property categoriaPedagio: integer read FcategoriaPedagio write SetcategoriaPedagio; //Se a rota estiver utilizando o  roteirizador é necessário informar qual a categoria para calculo de pedágio. Valor padrão é 0 = Isento
    property categoriaPedagio_IsSet_:boolean read FcategoriaPedagio_IsSet_;
  end;

const
  snveiculo_veiculos_depois24hrs = 'veiculo';
  snveiculo_veiculos_depois24hrs_placa = 'placa';
  snveiculo_veiculos_depois24hrs_informacoes = 'informacoes';

type
  tveiculo_veiculos_depois24hrs = class( tBaseNddWS ) // Dados do veículo
  private
    F_NameSpaceAlias: string;
    Fplaca: string; // (E)
    Finformacoes: ttpVeiculo; // (E)
    Finformacoes_IsSet_: boolean;
    procedure Setinformacoes(value:ttpVeiculo);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property placa: string read Fplaca write Fplaca; //Placa do veículo
    property informacoes: ttpVeiculo read Finformacoes write Setinformacoes; //Informações sobre o veículo.
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
  end;

const
  snveiculos_depois24hrs = 'veiculos';
  snveiculos_depois24hrs_veiculo = 'veiculo';

type
  tveiculos_depois24hrs = class( tBaseNddWS ) // Veículos responsáveis pelo transporte.
  private
    F_NameSpaceAlias: string;
    Fveiculo: tManagedStringList; // of tveiculo_veiculos_depois24hrs(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property veiculo: tManagedStringList read Fveiculo write Fveiculo; // of tveiculo_veiculos_depois24hrs
  end;

const
  sndepois24hrs = 'depois24hrs';
  sndepois24hrs_veiculos = 'veiculos';
  sndepois24hrs_categoriaPedagio = 'categoriaPedagio';

type
  tdepois24hrs = class( tBaseNddWS ) // Prazo final para alterações na ANTT.
  private
    F_NameSpaceAlias: string;
    Fveiculos: tveiculos_depois24hrs; // (E)
    Fveiculos_IsSet_: boolean;
    FcategoriaPedagio: integer; // (E)
    FcategoriaPedagio_IsSet_: boolean;
    procedure Setveiculos(value:tveiculos_depois24hrs);
    procedure SetcategoriaPedagio(value:integer);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property veiculos: tveiculos_depois24hrs read Fveiculos write Setveiculos;
    property veiculos_IsSet_:boolean read Fveiculos_IsSet_;
    property categoriaPedagio: integer read FcategoriaPedagio write SetcategoriaPedagio; //Se a rota estiver utilizando o  roteirizador é necessário informar qual a categoria para calculo de pedágio. Valor padrão é 0 = Isento
    property categoriaPedagio_IsSet_:boolean read FcategoriaPedagio_IsSet_;
  end;

const
  snveiculo_veiculos_ate24hrs = 'veiculo';
  snveiculo_veiculos_ate24hrs_placa = 'placa';
  snveiculo_veiculos_ate24hrs_informacoes = 'informacoes';

type
  tveiculo_veiculos_ate24hrs = class( tBaseNddWS ) // Dados do veículo
  private
    F_NameSpaceAlias: string;
    Fplaca: string; // (E)
    Finformacoes: ttpVeiculo; // (E)
    Finformacoes_IsSet_: boolean;
    procedure Setinformacoes(value:ttpVeiculo);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property placa: string read Fplaca write Fplaca; //Placa do veículo
    property informacoes: ttpVeiculo read Finformacoes write Setinformacoes; //Informações sobre o veículo.
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
  end;

const
  snveiculos_ate24hrs = 'veiculos';
  snveiculos_ate24hrs_veiculo = 'veiculo';

type
  tveiculos_ate24hrs = class( tBaseNddWS ) // Veículos responsáveis pelo transporte. Deve ser enviado toda a lista de veículos.
  private
    F_NameSpaceAlias: string;
    Fveiculo: tManagedStringList; // of tveiculo_veiculos_ate24hrs(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property veiculo: tManagedStringList read Fveiculo write Fveiculo; // of tveiculo_veiculos_ate24hrs
  end;

const
  snequiparado = 'equiparado';
  snequiparado_cnpj = 'cnpj';
  snequiparado_inscEstadual = 'inscEstadual';

type
  tequiparado = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    FinscEstadual: string; // (E)
    FinscEstadual_IsSet_: boolean;
    procedure SetinscEstadual(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ do transportador.
    property inscEstadual: string read FinscEstadual write SetinscEstadual; //Inscrição estadual do transportador.
    property inscEstadual_IsSet_:boolean read FinscEstadual_IsSet_;
  end;

const
  sntac = 'tac';
  sntac_cpf = 'cpf';
  sntac_identidade = 'identidade';

type
  ttac = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fcpf: string; // (E)
    Fidentidade: string; // (E)
    Fidentidade_IsSet_: boolean;
    procedure Setidentidade(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cpf: string read Fcpf write Fcpf; //CPF do transportador.
    property identidade: string read Fidentidade write Setidentidade; //Identidade do transportador.
    property identidade_IsSet_:boolean read Fidentidade_IsSet_;
  end;

const
  snide_tpTransportador = 'ide';
  snide_tpTransportador_tac = 'tac';
  snide_tpTransportador_equiparado = 'equiparado';

type
  tide_tpTransportador = class( tBaseNddWS ) // Identificação do transportador.
  private
    F_NameSpaceAlias: string;
    Ftac: ttac; // (E)
    Ftac_IsSet_: boolean;
    Fequiparado: tequiparado; // (E)
    Fequiparado_IsSet_: boolean;
    procedure Settac(value:ttac);
    procedure Setequiparado(value:tequiparado);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property tac: ttac read Ftac write Settac;
    property tac_IsSet_:boolean read Ftac_IsSet_;
    property equiparado: tequiparado read Fequiparado write Setequiparado;
    property equiparado_IsSet_:boolean read Fequiparado_IsSet_;
  end;

const
  sntpTransportador = 'tpTransportador';
  sntpTransportador_ide = 'ide';
  sntpTransportador_nome = 'nome';
  sntpTransportador_endereco = 'endereco';
  sntpTransportador_telefone = 'telefone';
  sntpTransportador_cartaoId = 'cartaoId';
  sntpTransportador_email = 'email';

type
  ttpTransportador = class( tBaseNddWS ) // Informações sobre o transportador.
  private
    F_NameSpaceAlias: string;
    Fide: tide_tpTransportador; // (E)
    Fnome: string; // (E)
    Fendereco: ttpEnderecoSemIBGE; // (E)
    Ftelefone: int64; // (E)
    FcartaoId: int64; // (E)
    FcartaoId_IsSet_: boolean;
    Femail: string; // (E)
    Femail_IsSet_: boolean;
    procedure SetcartaoId(value:int64);
    procedure Setemail(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ide: tide_tpTransportador read Fide; // write Fide;
    property nome: string read Fnome write Fnome; //Nome do transportador.
    property endereco: ttpEnderecoSemIBGE read Fendereco; // write Fendereco; //Endereco do transportador.
    property telefone: int64 read Ftelefone write Ftelefone; //Telefone celular do transporador.
    property cartaoId: int64 read FcartaoId write SetcartaoId; //Identificador doc artão a ser vinculado com o transportador.
    property cartaoId_IsSet_:boolean read FcartaoId_IsSet_;
    property email: string read Femail write Setemail; //Email de contato do transportador.
    property email_IsSet_:boolean read Femail_IsSet_;
  end;

const
  sntpAlterarCarga = 'tpAlterarCarga';
  sntpAlterarCarga_codigoSH = 'codigoSH';
  sntpAlterarCarga_quantidade = 'quantidade';

type
  ttpAlterarCarga = class( tBaseNddWS ) // Informações sobre a alteração de carga da viagem.
  private
    F_NameSpaceAlias: string;
    FcodigoSH: string; // (E)
    Fquantidade: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property codigoSH: string read FcodigoSH write FcodigoSH; //Código do Sistema Harmonizado. Define qual a natureza da carga conforme a tabela de códigos do Sistema Harmonizado de Designação e de Codificação de Mercadorias.
    property quantidade: string read Fquantidade write Fquantidade; //Quantidade da carga em Kg.
  end;

const
  snate24hrs = 'ate24hrs';
  snate24hrs_validade = 'validade';
  snate24hrs_carga = 'carga';
  snate24hrs_veiculos = 'veiculos';
  snate24hrs_categoriaPedagio = 'categoriaPedagio';
  snate24hrs_rota = 'rota';

type
  tate24hrs = class( tBaseNddWS ) // Prazo inicial para alteraçãos na ANTT.
  private
    F_NameSpaceAlias: string;
    Fvalidade: tvalidade; // (E)
    Fvalidade_IsSet_: boolean;
    Fcarga: ttpAlterarCarga; // (E)
    Fcarga_IsSet_: boolean;
    Fveiculos: tveiculos_ate24hrs; // (E)
    Fveiculos_IsSet_: boolean;
    FcategoriaPedagio: integer; // (E)
    FcategoriaPedagio_IsSet_: boolean;
    Frota: ttpRota; // (E)
    Frota_IsSet_: boolean;
    procedure Setvalidade(value:tvalidade);
    procedure Setcarga(value:ttpAlterarCarga);
    procedure Setveiculos(value:tveiculos_ate24hrs);
    procedure SetcategoriaPedagio(value:integer);
    procedure Setrota(value:ttpRota);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property validade: tvalidade read Fvalidade write Setvalidade;
    property validade_IsSet_:boolean read Fvalidade_IsSet_;
    property carga: ttpAlterarCarga read Fcarga write Setcarga; //Dados referente a carga da viagem.
    property carga_IsSet_:boolean read Fcarga_IsSet_;
    property veiculos: tveiculos_ate24hrs read Fveiculos write Setveiculos;
    property veiculos_IsSet_:boolean read Fveiculos_IsSet_;
    property categoriaPedagio: integer read FcategoriaPedagio write SetcategoriaPedagio; //Se a rota estiver utilizando o  roteirizador é necessário informar qual a categoria para calculo de pedágio. Valor padrão é 0 = Isento
    property categoriaPedagio_IsSet_:boolean read FcategoriaPedagio_IsSet_;
    property rota: ttpRota read Frota write Setrota; //Dados da rota.
    property rota_IsSet_:boolean read Frota_IsSet_;
  end;

const
  snpadrao_ANTT = 'padrao';
  snpadrao_ANTT_ate24hrs = 'ate24hrs';
  snpadrao_ANTT_depois24hrs = 'depois24hrs';

type
  tpadrao_ANTT = class( tBaseNddWS ) // Alterações da operação de transporte padrão.
  private
    F_NameSpaceAlias: string;
    Fate24hrs: tate24hrs; // (E)
    Fate24hrs_IsSet_: boolean;
    Fdepois24hrs: tdepois24hrs; // (E)
    Fdepois24hrs_IsSet_: boolean;
    procedure Setate24hrs(value:tate24hrs);
    procedure Setdepois24hrs(value:tdepois24hrs);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ate24hrs: tate24hrs read Fate24hrs write Setate24hrs;
    property ate24hrs_IsSet_:boolean read Fate24hrs_IsSet_;
    property depois24hrs: tdepois24hrs read Fdepois24hrs write Setdepois24hrs;
    property depois24hrs_IsSet_:boolean read Fdepois24hrs_IsSet_;
  end;

const
  snANTT = 'ANTT';
  snANTT_padrao = 'padrao';
  snANTT_TACagregado = 'TACagregado';

type
  tANTT = class( tBaseNddWS ) // Alteração que diz respeito a dados que a ANTT tem conhecimento.
  private
    F_NameSpaceAlias: string;
    Fpadrao: tpadrao_ANTT; // (E)
    Fpadrao_IsSet_: boolean;
    FTACagregado: tTACagregado_ANTT; // (E)
    FTACagregado_IsSet_: boolean;
    procedure Setpadrao(value:tpadrao_ANTT);
    procedure SetTACagregado(value:tTACagregado_ANTT);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property padrao: tpadrao_ANTT read Fpadrao write Setpadrao;
    property padrao_IsSet_:boolean read Fpadrao_IsSet_;
    property TACagregado: tTACagregado_ANTT read FTACagregado write SetTACagregado;
    property TACagregado_IsSet_:boolean read FTACagregado_IsSet_;
  end;

const
  snconfirmador = 'confirmador';
  snconfirmador_cnpj = 'cnpj';
  snconfirmador_cpf = 'cpf';

type
  tconfirmador = class( tBaseNddWS ) // Informa o confirmador de recebimento da(s) carga(s).
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    Fcpf: string; // (E)
    Fcpf_IsSet_: boolean;
    procedure Setcnpj(value:string);
    procedure Setcpf(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Setcnpj; //Número do CNPJ.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
    property cpf: string read Fcpf write Setcpf; //Número do CPF.
    property cpf_IsSet_:boolean read Fcpf_IsSet_;
  end;

const
  sndocumentos = 'documentos';
  sndocumentos_documento = 'documento';

type
  tdocumentos = class( tBaseNddWS ) // Documentos da quitação.
  private
    F_NameSpaceAlias: string;
    Fdocumento: tManagedStringList; // of ttpDocumento(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property documento: tManagedStringList read Fdocumento write Fdocumento; // of ttpDocumento
  end;

const
  snquitacao = 'quitacao';
  snquitacao_documentos = 'documentos';
  snquitacao_entrega = 'entrega';

type
  tquitacao = class( tBaseNddWS ) // Coleção de documentos que deram origem a operação de transporte. Os documentos serão inseridos na parcela de saldo.
  private
    F_NameSpaceAlias: string;
    Fdocumentos: tdocumentos; // (E)
    Fentrega: string; // (E)
    Fentrega_IsSet_: boolean;
    procedure Setentrega(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property documentos: tdocumentos read Fdocumentos; // write Fdocumentos;
    property entrega: string read Fentrega write Setentrega; //CNPJ de entrega dos documentos de quitação. Por padrão os docmentos são enviados ao endereço do ponto emissor (emitente).
    property entrega_IsSet_:boolean read Fentrega_IsSet_;
  end;

const
  snveiculo = 'veiculo';
  snveiculo_placa = 'placa';
  snveiculo_informacoes = 'informacoes';

type
  tveiculo = class( tBaseNddWS ) // Dados do veículo
  private
    F_NameSpaceAlias: string;
    Fplaca: string; // (E)
    Finformacoes: ttpVeiculo; // (E)
    Finformacoes_IsSet_: boolean;
    procedure Setinformacoes(value:ttpVeiculo);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property placa: string read Fplaca write Fplaca; //Placa do veículo
    property informacoes: ttpVeiculo read Finformacoes write Setinformacoes; //Informações do veículo.
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
  end;

const
  snveiculos = 'veiculos';
  snveiculos_veiculo = 'veiculo';

type
  tveiculos = class( tBaseNddWS ) // Veículos responsáveis pelo transporte.
  private
    F_NameSpaceAlias: string;
    Fveiculo: tManagedStringList; // of tveiculo(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property veiculo: tManagedStringList read Fveiculo write Fveiculo; // of tveiculo
  end;

const
  sncondutor = 'condutor';
  sncondutor_cpf = 'cpf';
  sncondutor_informacoes = 'informacoes';

type
  tcondutor = class( tBaseNddWS ) // Dados do condutor
  private
    F_NameSpaceAlias: string;
    Fcpf: string; // (E)
    Finformacoes: ttpCondutor; // (E)
    Finformacoes_IsSet_: boolean;
    procedure Setinformacoes(value:ttpCondutor);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cpf: string read Fcpf write Fcpf; //Número do CPF do condutor.
    property informacoes: ttpCondutor read Finformacoes write Setinformacoes; //Informações do condutor.
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
  end;

const
  sncondutores = 'condutores';
  sncondutores_condutor = 'condutor';

type
  tcondutores = class( tBaseNddWS ) // Dados dos condutores
  private
    F_NameSpaceAlias: string;
    Fcondutor: tManagedStringList; // of tcondutor(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property condutor: tManagedStringList read Fcondutor write Fcondutor; // of tcondutor
  end;

const
  sncontatos = 'contatos';
  sncontatos_contato = 'contato';

type
  tcontatos = class( tBaseNddWS ) // Contatos a serem adicionados a operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcontato: tManagedStringList; // of ttpContato(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property contato: tManagedStringList read Fcontato write Fcontato; // of ttpContato
  end;

const
  snide = 'ide';
  snide_cnpj = 'cnpj';
  snide_numero = 'numero';
  snide_serie = 'serie';
  snide_ptEmissor = 'ptEmissor';
  snide_dtInicio = 'dtInicio';
  snide_dtFim = 'dtFim';
  snide_contrato = 'contrato';

type
  tide = class( tBaseNddWS ) // Dados de identificação da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fnumero: string; // (E)
    Fserie: string; // (E)
    FptEmissor: string; // (E)
    FdtInicio: string; // (E)
    FdtInicio_IsSet_: boolean;
    FdtFim: string; // (E)
    FdtFim_IsSet_: boolean;
    Fcontrato: string; // (E)
    Fcontrato_IsSet_: boolean;
    procedure SetdtInicio(value:string);
    procedure SetdtFim(value:string);
    procedure Setcontrato(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //Cnpj da contratante responsável pela operação de transporte.
    property numero: string read Fnumero write Fnumero; //Número para a operação de transporte.
    property serie: string read Fserie write Fserie; //Série da operação de transporte.
    property ptEmissor: string read FptEmissor write FptEmissor; //Ponto emissor responsável pela operação de transporte.
    property dtInicio: string read FdtInicio write SetdtInicio; //Data de inicio da viagem. Não deve ser informada pra OT com TAC_agregado. Padrão: AAAA-MM-DD
    property dtInicio_IsSet_:boolean read FdtInicio_IsSet_;
    property dtFim: string read FdtFim write SetdtFim; //Data de término da viagem. Se não for informada, será definido a data final como 30 dias após a data de início. Padrão: AAAA-MM-DD
    property dtFim_IsSet_:boolean read FdtFim_IsSet_;
    property contrato: string read Fcontrato write Setcontrato; //Informar o número do contrato entre o transportador e a contratante.
    property contrato_IsSet_:boolean read Fcontrato_IsSet_;
  end;

const
  snndop = 'ndop';
  snndop_numero = 'numero';
  snndop_ndopCodVerificador = 'ndopCodVerificador';

type
  tndop = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FndopCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Número que identifica a operação de pagamento.
    property ndopCodVerificador: string read FndopCodVerificador write FndopCodVerificador; //Protocolo de autorização disponibilizado para o NDOP.
  end;

const
  snndot = 'ndot';
  snndot_numero = 'numero';
  snndot_ndotCodVerificador = 'ndotCodVerificador';

type
  tndot = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FndotCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Número que identifica a operação de transporte sem CIOT.
    property ndotCodVerificador: string read FndotCodVerificador write FndotCodVerificador; //Protocolo de autorização disponibilizado para o NDOT.
  end;

const
  snciot = 'ciot';
  snciot_numero = 'numero';
  snciot_ciotCodVerificador = 'ciotCodVerificador';

type
  tciot = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fnumero: int64; // (E)
    FciotCodVerificador: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property numero: int64 read Fnumero write Fnumero; //Código de identificação da operação de transporte.
    property ciotCodVerificador: string read FciotCodVerificador write FciotCodVerificador; //Protocolo de autorização disponibilizado pela ANTT. Será informado XXXX caso seja uma emissão em contingência.
  end;

const
  sntpAutorizacaoImpressao = 'tpAutorizacaoImpressao';
  sntpAutorizacaoImpressao_ciot = 'ciot';
  sntpAutorizacaoImpressao_ndot = 'ndot';
  sntpAutorizacaoImpressao_ndop = 'ndop';

type
  ttpAutorizacaoImpressao = class( tBaseNddWS ) // Informações relacionadas a autorização de uma operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fciot: tciot; // (E)
    Fciot_IsSet_: boolean;
    Fndot: tndot; // (E)
    Fndot_IsSet_: boolean;
    Fndop: tndop; // (E)
    Fndop_IsSet_: boolean;
    procedure Setciot(value:tciot);
    procedure Setndot(value:tndot);
    procedure Setndop(value:tndop);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ciot: tciot read Fciot write Setciot;
    property ciot_IsSet_:boolean read Fciot_IsSet_;
    property ndot: tndot read Fndot write Setndot;
    property ndot_IsSet_:boolean read Fndot_IsSet_;
    property ndop: tndop read Fndop write Setndop;
    property ndop_IsSet_:boolean read Fndop_IsSet_;
  end;

const
  sntpCabecalhoImpressao = 'tpCabecalhoImpressao';
  sntpCabecalhoImpressao_pontoEmissor = 'pontoEmissor';
  sntpCabecalhoImpressao_documentosImprimir = 'documentosImprimir';
  sntpCabecalhoImpressao_autorizacao = 'autorizacao';
  sntpCabecalhoImpressao_conteudo = 'conteudo';

type
  ttpCabecalhoImpressao = class( tBaseNddWS ) // Impressão de documentos
  private
    F_NameSpaceAlias: string;
    FpontoEmissor: string; // (E)
    FdocumentosImprimir: tbyte; // (E)
    Fautorizacao: ttpAutorizacaoImpressao; // (E)
    Fconteudo: ttbPadraoImpressaoCompleto; // (E)
    Fconteudo_IsSet_: boolean;
    procedure Setconteudo(value:ttbPadraoImpressaoCompleto);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property pontoEmissor: string read FpontoEmissor write FpontoEmissor;
    property documentosImprimir: tbyte read FdocumentosImprimir write FdocumentosImprimir; //1 - DOT, 2 - Documentos adicionais, 3 - DOT e Documentos adicionais, 4 - NDOP
    property autorizacao: ttpAutorizacaoImpressao read Fautorizacao; // write Fautorizacao; //Operação de transporte a ser impressa.
    property conteudo: ttbPadraoImpressaoCompleto read Fconteudo write Setconteudo;
    property conteudo_IsSet_:boolean read Fconteudo_IsSet_;
  end;

const
  snimpressao_tpRetornoImpressaoDocumentos = 'impressao';
  snimpressao_tpRetornoImpressaoDocumentos_cabecalho = 'cabecalho';
  snimpressao_tpRetornoImpressaoDocumentos_status = 'status';
  snimpressao_tpRetornoImpressaoDocumentos_descricaoErro = 'descricaoErro';

type
  timpressao_tpRetornoImpressaoDocumentos = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fcabecalho: ttpCabecalhoImpressao; // (E)
    Fstatus: tbyte; // (E)
    FdescricaoErro: string; // (E)
    FdescricaoErro_IsSet_: boolean;
    procedure SetdescricaoErro(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cabecalho: ttpCabecalhoImpressao read Fcabecalho; // write Fcabecalho;
    property status: tbyte read Fstatus write Fstatus;
    property descricaoErro: string read FdescricaoErro write SetdescricaoErro; //Mensagem de erro
    property descricaoErro_IsSet_:boolean read FdescricaoErro_IsSet_;
  end;

const
  snformulario = 'formulario';
  snformulario_cabecalho = 'cabecalho';
  snformulario_impressaoDOT = 'impressaoDOT';
  snformulario_impressaoDocumentosAdicionais = 'impressaoDocumentosAdicionais';

type
  tformulario = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fcabecalho: ttpCabecalhoImpressao; // (E)
    FimpressaoDOT: ttbPadraoImpressao; // (E)
    FimpressaoDOT_IsSet_: boolean;
    FimpressaoDocumentosAdicionais: ttbPadraoImpressao; // (E)
    FimpressaoDocumentosAdicionais_IsSet_: boolean;
    procedure SetimpressaoDOT(value:ttbPadraoImpressao);
    procedure SetimpressaoDocumentosAdicionais(value:ttbPadraoImpressao);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cabecalho: ttpCabecalhoImpressao read Fcabecalho; // write Fcabecalho;
    property impressaoDOT: ttbPadraoImpressao read FimpressaoDOT write SetimpressaoDOT;
    property impressaoDOT_IsSet_:boolean read FimpressaoDOT_IsSet_;
    property impressaoDocumentosAdicionais: ttbPadraoImpressao read FimpressaoDocumentosAdicionais write SetimpressaoDocumentosAdicionais;
    property impressaoDocumentosAdicionais_IsSet_:boolean read FimpressaoDocumentosAdicionais_IsSet_;
  end;

const
  sntpinfImpressaoDocumentos = 'tpinfImpressaoDocumentos';
  sntpinfImpressaoDocumentos_cnpj = 'cnpj';
  sntpinfImpressaoDocumentos_cabecalho = 'cabecalho';
  sntpinfImpressaoDocumentos_formulario = 'formulario';
  antpinfImpressaoDocumentos_ID = 'Id';

type
  ttpinfImpressaoDocumentos = class( tBaseNddWS ) // Informações da impressão de documentos.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fcabecalho: ttpCabecalhoFormularioImpressao; // (E)
    Fformulario: tManagedStringList; // of tformulario(E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante da qual os documentos a serem impressos pertencem.
    property cabecalho: ttpCabecalhoFormularioImpressao read Fcabecalho; // write Fcabecalho;
    property formulario: tManagedStringList read Fformulario write Fformulario; // of tformulario
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  snimpressao = 'impressao';
  snimpressao_infImpressaoDocumentos = 'infImpressaoDocumentos';
  snimpressao_Signature = 'Signature';

type
  timpressao = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FinfImpressaoDocumentos: ttpinfImpressaoDocumentos; // (E)
    FSignature: tSignature; // (X)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infImpressaoDocumentos: ttpinfImpressaoDocumentos read FinfImpressaoDocumentos; // write FinfImpressaoDocumentos; //Informações referentes a impressao de documentos.
    property Signature: tSignature read FSignature; // write FSignature;
  end;

const
  sntpImpressaoDocumentos = 'tpImpressaoDocumentos';
  sntpImpressaoDocumentos_impressao = 'impressao';
  antpImpressaoDocumentos_versao = 'versao';
  antpImpressaoDocumentos_token = 'token';

type
  ttpImpressaoDocumentos = class( tBaseNddWS ) // Impressão de documentos
  private
    F_NameSpaceAlias: string;
    Fimpressao: timpressao; // (E)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property impressao: timpressao read Fimpressao; // write Fimpressao;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sntpCartaoObrigatorioColaborador = 'tpCartaoObrigatorioColaborador';
  sntpCartaoObrigatorioColaborador_cartaoId = 'cartaoId';
  sntpCartaoObrigatorioColaborador_gestoraCartao = 'gestoraCartao';

type
  ttpCartaoObrigatorioColaborador = class( tBaseNddWS ) // Informações sobre o cartão do colaborador.
  private
    F_NameSpaceAlias: string;
    FcartaoId: int64; // (E)
    FgestoraCartao: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cartaoId: int64 read FcartaoId write FcartaoId; //Este será o identificador do cartão que foi entregue ao colaborador e será realizado o vínculo.
    property gestoraCartao: string read FgestoraCartao write FgestoraCartao; //Gestora de cartão do cartão entregue ao colaborador, no caso de vinculo será utilizada esta gestora de cartão para realizar o vinculo do cartão.
  end;

const
  sntpCartaoColaborador = 'tpCartaoColaborador';
  sntpCartaoColaborador_cartaoId = 'cartaoId';
  sntpCartaoColaborador_gestoraCartao = 'gestoraCartao';

type
  ttpCartaoColaborador = class( tBaseNddWS ) // Informações sobre o cartão do colaborador.
  private
    F_NameSpaceAlias: string;
    FcartaoId: int64; // (E)
    FcartaoId_IsSet_: boolean;
    FgestoraCartao: string; // (E)
    FgestoraCartao_IsSet_: boolean;
    procedure SetcartaoId(value:int64);
    procedure SetgestoraCartao(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cartaoId: int64 read FcartaoId write SetcartaoId; //Este será o identificador do cartão que foi entregue ao colaborador e será realizado o vínculo.
    property cartaoId_IsSet_:boolean read FcartaoId_IsSet_;
    property gestoraCartao: string read FgestoraCartao write SetgestoraCartao; //Gestora de cartão do cartão entregue ao colaborador, no caso de vinculo será utilizada esta gestora de cartão para realizar o vinculo do cartão.
    property gestoraCartao_IsSet_:boolean read FgestoraCartao_IsSet_;
  end;

const
  sntpColaborador = 'tpColaborador';
  sntpColaborador_nome = 'nome';
  sntpColaborador_identidade = 'identidade';
  sntpColaborador_endereco = 'endereco';
  sntpColaborador_telefone = 'telefone';

type
  ttpColaborador = class( tBaseNddWS ) // Informações sobre o colaborador.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    Fidentidade: string; // (E)
    Fendereco: ttpEnderecoSemIBGE; // (E)
    Ftelefone: int64; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome do colaborador.
    property identidade: string read Fidentidade write Fidentidade; //Identidade do colaborador.
    property endereco: ttpEnderecoSemIBGE read Fendereco; // write Fendereco; //Endereço do colaborador.
    property telefone: int64 read Ftelefone write Ftelefone; //Telefone celular do colaborador.
  end;

const
  sncolaborador_tpInfRetornoOperacaoPagamento = 'colaborador';
  sncolaborador_tpInfRetornoOperacaoPagamento_cpf = 'cpf';
  sncolaborador_tpInfRetornoOperacaoPagamento_informacoes = 'informacoes';
  sncolaborador_tpInfRetornoOperacaoPagamento_cartao = 'cartao';

type
  tcolaborador_tpInfRetornoOperacaoPagamento = class( tBaseNddWS ) // Informações do colaborador que esta recebendo o pagamento.
  private
    F_NameSpaceAlias: string;
    Fcpf: string; // (E)
    Finformacoes: ttpColaborador; // (E)
    Finformacoes_IsSet_: boolean;
    Fcartao: ttpCartaoObrigatorioColaborador; // (E)
    Fcartao_IsSet_: boolean;
    procedure Setinformacoes(value:ttpColaborador);
    procedure Setcartao(value:ttpCartaoObrigatorioColaborador);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cpf: string read Fcpf write Fcpf; //Número do Cpf do colaborador.
    property informacoes: ttpColaborador read Finformacoes write Setinformacoes; //Informações para cadastro de colaborador.
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
    property cartao: ttpCartaoObrigatorioColaborador read Fcartao write Setcartao; //Informações para vinculo de cartão com o colaborador.
    property cartao_IsSet_:boolean read Fcartao_IsSet_;
  end;

const
  sntpInfRetornoOperacaoPagamento = 'tpInfRetornoOperacaoPagamento';
  sntpInfRetornoOperacaoPagamento_ide = 'ide';
  sntpInfRetornoOperacaoPagamento_colaborador = 'colaborador';
  sntpInfRetornoOperacaoPagamento_rota = 'rota';
  sntpInfRetornoOperacaoPagamento_pagamento = 'pagamento';
  sntpInfRetornoOperacaoPagamento_categoriaPedagio = 'categoriaPedagio';
  antpInfRetornoOperacaoPagamento_ID = 'Id';
  antpInfRetornoOperacaoPagamento_token = 'token';

type
  ttpInfRetornoOperacaoPagamento = class( tBaseNddWS ) // Consulta do resumo da operação de pagametno.
  private
    F_NameSpaceAlias: string;
    Fide: tide_tpInfRetornoOperacaoPagamento; // (E)
    Fcolaborador: tcolaborador_tpInfRetornoOperacaoPagamento; // (E)
    Frota: ttpRota; // (E)
    Frota_IsSet_: boolean;
    Fpagamento: tpagamento_tpInfRetornoOperacaoPagamento; // (E)
    FcategoriaPedagio: integer; // (E)
    FcategoriaPedagio_IsSet_: boolean;
    FID: string; // (A)
    FID_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setrota(value:ttpRota);
    procedure SetcategoriaPedagio(value:integer);
    procedure SetID(value:string);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ide: tide_tpInfRetornoOperacaoPagamento read Fide; // write Fide;
    property colaborador: tcolaborador_tpInfRetornoOperacaoPagamento read Fcolaborador; // write Fcolaborador;
    property rota: ttpRota read Frota write Setrota; //Define a rota da viagem.
    property rota_IsSet_:boolean read Frota_IsSet_;
    property pagamento: tpagamento_tpInfRetornoOperacaoPagamento read Fpagamento; // write Fpagamento;
    property categoriaPedagio: integer read FcategoriaPedagio write SetcategoriaPedagio; //Se a rota estiver utilizando o  roteirizador é necessário informar qual a categoria para calculo de pedágio. Valor padrão é 0 = Isento
    property categoriaPedagio_IsSet_:boolean read FcategoriaPedagio_IsSet_;
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sncolaborador = 'colaborador';
  sncolaborador_cpf = 'cpf';
  sncolaborador_informacoes = 'informacoes';
  sncolaborador_cartao = 'cartao';

type
  tcolaborador = class( tBaseNddWS ) // Informações do colaborador que esta recebendo o pagamento.
  private
    F_NameSpaceAlias: string;
    Fcpf: string; // (E)
    Finformacoes: ttpColaborador; // (E)
    Finformacoes_IsSet_: boolean;
    Fcartao: ttpCartaoObrigatorioColaborador; // (E)
    Fcartao_IsSet_: boolean;
    procedure Setinformacoes(value:ttpColaborador);
    procedure Setcartao(value:ttpCartaoObrigatorioColaborador);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cpf: string read Fcpf write Fcpf; //Número do Cpf do colaborador.
    property informacoes: ttpColaborador read Finformacoes write Setinformacoes; //Informações para cadastro de colaborador.
    property informacoes_IsSet_:boolean read Finformacoes_IsSet_;
    property cartao: ttpCartaoObrigatorioColaborador read Fcartao write Setcartao; //Informações para vinculo de cartão com o colaborador.
    property cartao_IsSet_:boolean read Fcartao_IsSet_;
  end;

const
  sntpInfOperacaoPagamento = 'tpInfOperacaoPagamento';
  sntpInfOperacaoPagamento_ide = 'ide';
  sntpInfOperacaoPagamento_colaborador = 'colaborador';
  sntpInfOperacaoPagamento_rota = 'rota';
  sntpInfOperacaoPagamento_pagamento = 'pagamento';
  sntpInfOperacaoPagamento_categoriaPedagio = 'categoriaPedagio';
  antpInfOperacaoPagamento_ID = 'Id';
  antpInfOperacaoPagamento_impAuto = 'impAuto';

type
  ttpInfOperacaoPagamento = class( tBaseNddWS ) // Consulta do resumo da operação de pagametno.
  private
    F_NameSpaceAlias: string;
    Fide: tide_tpInfOperacaoPagamento; // (E)
    Fcolaborador: tcolaborador; // (E)
    Frota: ttpRota; // (E)
    Frota_IsSet_: boolean;
    Fpagamento: tpagamento; // (E)
    FcategoriaPedagio: integer; // (E)
    FcategoriaPedagio_IsSet_: boolean;
    FID: string; // (A)
    FID_IsSet_: boolean;
    FimpAuto: tbyte; // (A)
    FimpAuto_IsSet_: boolean;
    procedure Setrota(value:ttpRota);
    procedure SetcategoriaPedagio(value:integer);
    procedure SetID(value:string);
    procedure SetimpAuto(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ide: tide_tpInfOperacaoPagamento read Fide; // write Fide;
    property colaborador: tcolaborador read Fcolaborador; // write Fcolaborador;
    property rota: ttpRota read Frota write Setrota; //Define a rota da viagem.
    property rota_IsSet_:boolean read Frota_IsSet_;
    property pagamento: tpagamento read Fpagamento; // write Fpagamento;
    property categoriaPedagio: integer read FcategoriaPedagio write SetcategoriaPedagio; //Se a rota estiver utilizando o  roteirizador é necessário informar qual a categoria para calculo de pedágio. Valor padrão é 0 = Isento
    property categoriaPedagio_IsSet_:boolean read FcategoriaPedagio_IsSet_;
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
    property impAuto: tbyte read FimpAuto write SetimpAuto;
    property impAuto_IsSet_:boolean read FimpAuto_IsSet_;
  end;

const
  sntpOperacaoPagamento = 'tpOperacaoPagamento';
  sntpOperacaoPagamento_infOperacaoPagamento = 'infOperacaoPagamento';
  sntpOperacaoPagamento_Signature = 'Signature';
  antpOperacaoPagamento_versao = 'versao';
  antpOperacaoPagamento_token = 'token';

type
  ttpOperacaoPagamento = class( tBaseNddWS ) // Consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FinfOperacaoPagamento: ttpInfOperacaoPagamento; // (E)
    FSignature: tSignature; // (X)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infOperacaoPagamento: ttpInfOperacaoPagamento read FinfOperacaoPagamento; // write FinfOperacaoPagamento; //Informações da operação de pagamento.
    property Signature: tSignature read FSignature; // write FSignature;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sntpMensagem = 'tpMensagem';
  sntpMensagem_codigo = 'codigo';
  sntpMensagem_mensagem = 'mensagem';
  sntpMensagem_observacao = 'observacao';

type
  ttpMensagem = class( tBaseNddWS ) // Tipo complexo que contém o código a descrição de uma mensagem
  private
    F_NameSpaceAlias: string;
    Fmensagem: string; // (E)
    FCodigo: string;
    Fobservacao: string; // (E)
    Fobservacao_IsSet_: boolean;
    procedure Setobservacao(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property codigo: string read Fcodigo write Fcodigo; //Codigo da mensagem sendo retornada
    property mensagem: string read Fmensagem write Fmensagem; //Descrição da mensagem
    property observacao: string read Fobservacao write Setobservacao; //Observacao sobre  a mensagem. Nesta observação é que serão apresentados informações mais técnicas do que está acontecendo
    property observacao_IsSet_:boolean read Fobservacao_IsSet_;
  end;

const
  sntpRetornoConsultaANTTDetalhe = 'tpRetornoConsultaANTTDetalhe';
  sntpRetornoConsultaANTTDetalhe_mensagem = 'mensagem';
  sntpRetornoConsultaANTTDetalhe_nomeTransportador = 'nomeTransportador';
  sntpRetornoConsultaANTTDetalhe_situacaoRNTRC = 'situacaoRNTRC';
  sntpRetornoConsultaANTTDetalhe_situacaoTransportador = 'situacaoTransportador';
  sntpRetornoConsultaANTTDetalhe_veiculosTransportador = 'veiculosTransportador';

type
  ttpRetornoConsultaANTTDetalhe = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fmensagem: ttpMensagem; // (E)
    FnomeTransportador: string; // (E)
    FnomeTransportador_IsSet_: boolean;
    FsituacaoRNTRC: tbyte; // (E)
    FsituacaoRNTRC_IsSet_: boolean;
    FsituacaoTransportador: tsituacaoTransportador; // (E)
    FsituacaoTransportador_IsSet_: boolean;
    FveiculosTransportador: tveiculosTransportador; // (E)
    FveiculosTransportador_IsSet_: boolean;
    procedure SetnomeTransportador(value:string);
    procedure SetsituacaoRNTRC(value:tbyte);
    procedure SetsituacaoTransportador(value:tsituacaoTransportador);
    procedure SetveiculosTransportador(value:tveiculosTransportador);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: ttpMensagem read Fmensagem; // write Fmensagem; //Observação da consulta.
    property nomeTransportador: string read FnomeTransportador write SetnomeTransportador; //Nome cadastrado do transportador na ANTT.
    property nomeTransportador_IsSet_:boolean read FnomeTransportador_IsSet_;
    property situacaoRNTRC: tbyte read FsituacaoRNTRC write SetsituacaoRNTRC; //Situação do RNTRC, sendo 1 = ativo e 2 = não ativo.
    property situacaoRNTRC_IsSet_:boolean read FsituacaoRNTRC_IsSet_;
    property situacaoTransportador: tsituacaoTransportador read FsituacaoTransportador write SetsituacaoTransportador;
    property situacaoTransportador_IsSet_:boolean read FsituacaoTransportador_IsSet_;
    property veiculosTransportador: tveiculosTransportador read FveiculosTransportador write SetveiculosTransportador;
    property veiculosTransportador_IsSet_:boolean read FveiculosTransportador_IsSet_;
  end;

const
  snconsultaANTT = 'consultaANTT';
  snconsultaANTT_envioConsultaANTT = 'envioConsultaANTT';
  snconsultaANTT_retornoConsultaANTT = 'retornoConsultaANTT';

type
  tconsultaANTT = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FenvioConsultaANTT: ttpEnvioConsultaANTTDetalhe; // (E)
    FretornoConsultaANTT: ttpRetornoConsultaANTTDetalhe; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property envioConsultaANTT: ttpEnvioConsultaANTTDetalhe read FenvioConsultaANTT; // write FenvioConsultaANTT;
    property retornoConsultaANTT: ttpRetornoConsultaANTTDetalhe read FretornoConsultaANTT; // write FretornoConsultaANTT;
  end;

const
  snconsultasANTT = 'consultasANTT';
  snconsultasANTT_consultaANTT = 'consultaANTT';

type
  tconsultasANTT = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FconsultaANTT: tManagedStringList; // of tconsultaANTT(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property consultaANTT: tManagedStringList read FconsultaANTT write FconsultaANTT; // of tconsultaANTT
  end;

const
  snmensagens_tpRetornoConsultaANTT = 'mensagens';
  snmensagens_tpRetornoConsultaANTT_mensagem = 'mensagem';

type
  tmensagens_tpRetornoConsultaANTT = class( tBaseNddWS ) // Lista das mensagens de erro.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  sntpRetornoConsultaANTT = 'tpRetornoConsultaANTT';
  sntpRetornoConsultaANTT_mensagens = 'mensagens';
  sntpRetornoConsultaANTT_consultasANTT = 'consultasANTT';

type
  ttpRetornoConsultaANTT = class( tBaseNddWS ) // Retorno da consulta de informações da ANTT.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpRetornoConsultaANTT; // (E)
    Fmensagens_IsSet_: boolean;
    FconsultasANTT: tconsultasANTT; // (E)
    FconsultasANTT_IsSet_: boolean;
    procedure Setmensagens(value:tmensagens_tpRetornoConsultaANTT);
    procedure SetconsultasANTT(value:tconsultasANTT);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpRetornoConsultaANTT read Fmensagens write Setmensagens;
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property consultasANTT: tconsultasANTT read FconsultasANTT write SetconsultasANTT;
    property consultasANTT_IsSet_:boolean read FconsultasANTT_IsSet_;
  end;

const
  snmensagens_tpDetalheRetornoCancelarOperacaoPagamento = 'mensagens';
  snmensagens_tpDetalheRetornoCancelarOperacaoPagamento_mensagem = 'mensagem';

type
  tmensagens_tpDetalheRetornoCancelarOperacaoPagamento = class( tBaseNddWS ) // Lista das mensagens de erro de negócio.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  sntpDetalheRetornoCancelarOperacaoPagamento = 'tpDetalheRetornoCancelarOperacaoPagamento';
  sntpDetalheRetornoCancelarOperacaoPagamento_mensagens = 'mensagens';
  sntpDetalheRetornoCancelarOperacaoPagamento_statusPagamentoValor = 'statusPagamentoValor';
  sntpDetalheRetornoCancelarOperacaoPagamento_statusPagamentoPedagio = 'statusPagamentoPedagio';
  sntpDetalheRetornoCancelarOperacaoPagamento_dataCancelamento = 'dataCancelamento';

type
  ttpDetalheRetornoCancelarOperacaoPagamento = class( tBaseNddWS ) // Retorno do cancelamento de operações de pagamento.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpDetalheRetornoCancelarOperacaoPagamento; // (E)
    FstatusPagamentoValor: tbyte; // (E)
    FstatusPagamentoValor_IsSet_: boolean;
    FstatusPagamentoPedagio: tbyte; // (E)
    FstatusPagamentoPedagio_IsSet_: boolean;
    FdataCancelamento: string; // (E)
    FdataCancelamento_IsSet_: boolean;
    procedure SetstatusPagamentoValor(value:tbyte);
    procedure SetstatusPagamentoPedagio(value:tbyte);
    procedure SetdataCancelamento(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpDetalheRetornoCancelarOperacaoPagamento read Fmensagens; // write Fmensagens;
    property statusPagamentoValor: tbyte read FstatusPagamentoValor write SetstatusPagamentoValor; //Status do pagamento de valor da operação de pagamento. Aberto = 0, Pago = 1, Cancelado = 2, Erro = 3.
    property statusPagamentoValor_IsSet_:boolean read FstatusPagamentoValor_IsSet_;
    property statusPagamentoPedagio: tbyte read FstatusPagamentoPedagio write SetstatusPagamentoPedagio; //Status do pagamento de pedágio da  operação de pagamento. Aberto = 0, Pago = 1, Cancelado = 2, Erro = 3.
    property statusPagamentoPedagio_IsSet_:boolean read FstatusPagamentoPedagio_IsSet_;
    property dataCancelamento: string read FdataCancelamento write SetdataCancelamento; //Data do cancelamento.
    property dataCancelamento_IsSet_:boolean read FdataCancelamento_IsSet_;
  end;

const
  snmensagens_tpRetornoCancelarOperacaoPagamento = 'mensagens';
  snmensagens_tpRetornoCancelarOperacaoPagamento_mensagem = 'mensagem';

type
  tmensagens_tpRetornoCancelarOperacaoPagamento = class( tBaseNddWS ) // Lista das mensagens de erro.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  sntpRetornoCancelarOperacaoPagamento = 'tpRetornoCancelarOperacaoPagamento';
  sntpRetornoCancelarOperacaoPagamento_mensagens = 'mensagens';
  sntpRetornoCancelarOperacaoPagamento_envioCancelarOperacaoPagamento = 'envioCancelarOperacaoPagamento';
  sntpRetornoCancelarOperacaoPagamento_retCancelarOperacaoPagamento = 'retCancelarOperacaoPagamento';

type
  ttpRetornoCancelarOperacaoPagamento = class( tBaseNddWS ) // Retorno do cancelamento de operações de pagamento.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpRetornoCancelarOperacaoPagamento; // (E)
    Fmensagens_IsSet_: boolean;
    FenvioCancelarOperacaoPagamento: ttpInfRetornoCancelarOperacaoPagamento; // (E)
    FenvioCancelarOperacaoPagamento_IsSet_: boolean;
    FretCancelarOperacaoPagamento: ttpDetalheRetornoCancelarOperacaoPagamento; // (E)
    FretCancelarOperacaoPagamento_IsSet_: boolean;
    procedure Setmensagens(value:tmensagens_tpRetornoCancelarOperacaoPagamento);
    procedure SetenvioCancelarOperacaoPagamento(value:ttpInfRetornoCancelarOperacaoPagamento);
    procedure SetretCancelarOperacaoPagamento(value:ttpDetalheRetornoCancelarOperacaoPagamento);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpRetornoCancelarOperacaoPagamento read Fmensagens write Setmensagens;
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property envioCancelarOperacaoPagamento: ttpInfRetornoCancelarOperacaoPagamento read FenvioCancelarOperacaoPagamento write SetenvioCancelarOperacaoPagamento; //Informações do envio do cancelamento da operação de pagamento.
    property envioCancelarOperacaoPagamento_IsSet_:boolean read FenvioCancelarOperacaoPagamento_IsSet_;
    property retCancelarOperacaoPagamento: ttpDetalheRetornoCancelarOperacaoPagamento read FretCancelarOperacaoPagamento write SetretCancelarOperacaoPagamento; //Informações do retorno do cancelamento de operações de pagamento.
    property retCancelarOperacaoPagamento_IsSet_:boolean read FretCancelarOperacaoPagamento_IsSet_;
  end;

const
  snmensagens_tpRetornoConsultaOperacaoPagamento = 'mensagens';
  snmensagens_tpRetornoConsultaOperacaoPagamento_mensagem = 'mensagem';

type
  tmensagens_tpRetornoConsultaOperacaoPagamento = class( tBaseNddWS ) // Lista das mensagens de erro.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  snmensagens_tpRetornoOperacaoPagamentoDetalhe = 'mensagens';
  snmensagens_tpRetornoOperacaoPagamentoDetalhe_mensagem = 'mensagem';

type
  tmensagens_tpRetornoOperacaoPagamentoDetalhe = class( tBaseNddWS ) // Lista das mensagens de erro de negócio.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  sntpRetornoOperacaoPagamentoDetalhe = 'tpRetornoOperacaoPagamentoDetalhe';
  sntpRetornoOperacaoPagamentoDetalhe_mensagens = 'mensagens';
  sntpRetornoOperacaoPagamentoDetalhe_autorizacao = 'autorizacao';
  sntpRetornoOperacaoPagamentoDetalhe_pedagio = 'pedagio';
  sntpRetornoOperacaoPagamentoDetalhe_saldo = 'saldo';
  sntpRetornoOperacaoPagamentoDetalhe_statusPagamentoValor = 'statusPagamentoValor';
  sntpRetornoOperacaoPagamentoDetalhe_statusPagamentoPedagio = 'statusPagamentoPedagio';

type
  ttpRetornoOperacaoPagamentoDetalhe = class( tBaseNddWS ) // Consulta do resumo da operação de pagametno.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpRetornoOperacaoPagamentoDetalhe; // (E)
    Fautorizacao: tautorizacao_tpRetornoOperacaoPagamentoDetalhe; // (E)
    Fautorizacao_IsSet_: boolean;
    Fpedagio: tpedagio_tpRetornoOperacaoPagamentoDetalhe; // (E)
    Fpedagio_IsSet_: boolean;
    Fsaldo: tsaldo_tpRetornoOperacaoPagamentoDetalhe; // (E)
    Fsaldo_IsSet_: boolean;
    FstatusPagamentoValor: tbyte; // (E)
    FstatusPagamentoValor_IsSet_: boolean;
    FstatusPagamentoPedagio: tbyte; // (E)
    FstatusPagamentoPedagio_IsSet_: boolean;
    procedure Setautorizacao(value:tautorizacao_tpRetornoOperacaoPagamentoDetalhe);
    procedure Setpedagio(value:tpedagio_tpRetornoOperacaoPagamentoDetalhe);
    procedure Setsaldo(value:tsaldo_tpRetornoOperacaoPagamentoDetalhe);
    procedure SetstatusPagamentoValor(value:tbyte);
    procedure SetstatusPagamentoPedagio(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpRetornoOperacaoPagamentoDetalhe read Fmensagens; // write Fmensagens;
    property autorizacao: tautorizacao_tpRetornoOperacaoPagamentoDetalhe read Fautorizacao write Setautorizacao;
    property autorizacao_IsSet_:boolean read Fautorizacao_IsSet_;
    property pedagio: tpedagio_tpRetornoOperacaoPagamentoDetalhe read Fpedagio write Setpedagio;
    property pedagio_IsSet_:boolean read Fpedagio_IsSet_;
    property saldo: tsaldo_tpRetornoOperacaoPagamentoDetalhe read Fsaldo write Setsaldo;
    property saldo_IsSet_:boolean read Fsaldo_IsSet_;
    property statusPagamentoValor: tbyte read FstatusPagamentoValor write SetstatusPagamentoValor; //Status do pagamento de valor da operação de pagamento. Aberto = 0, Pago = 1, Cancelado = 2, Erro = 3.
    property statusPagamentoValor_IsSet_:boolean read FstatusPagamentoValor_IsSet_;
    property statusPagamentoPedagio: tbyte read FstatusPagamentoPedagio write SetstatusPagamentoPedagio; //Status do pagamento de pedágio da  operação de pagamento. Aberto = 0, Pago = 1, Cancelado = 2, Erro = 3.
    property statusPagamentoPedagio_IsSet_:boolean read FstatusPagamentoPedagio_IsSet_;
  end;

const
  snmensagens_tpDetalheRetornoOperacaoPagamento = 'mensagens';
  snmensagens_tpDetalheRetornoOperacaoPagamento_mensagem = 'mensagem';

type
  tmensagens_tpDetalheRetornoOperacaoPagamento = class( tBaseNddWS ) // Lista das mensagens de erro de negócio.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  sntpDetalheRetornoOperacaoPagamento = 'tpDetalheRetornoOperacaoPagamento';
  sntpDetalheRetornoOperacaoPagamento_mensagens = 'mensagens';
  sntpDetalheRetornoOperacaoPagamento_autorizacao = 'autorizacao';
  sntpDetalheRetornoOperacaoPagamento_dataPagamento = 'dataPagamento';
  sntpDetalheRetornoOperacaoPagamento_valorPagamento = 'valorPagamento';
  sntpDetalheRetornoOperacaoPagamento_pedagio = 'pedagio';
  sntpDetalheRetornoOperacaoPagamento_saldo = 'saldo';
  sntpDetalheRetornoOperacaoPagamento_pagamentoPedagio = 'pagamentoPedagio';
  sntpDetalheRetornoOperacaoPagamento_statusPagamentoValor = 'statusPagamentoValor';
  sntpDetalheRetornoOperacaoPagamento_statusPagamentoPedagio = 'statusPagamentoPedagio';
  sntpDetalheRetornoOperacaoPagamento_gestoraCartao = 'gestoraCartao';

type
  ttpDetalheRetornoOperacaoPagamento = class( tBaseNddWS ) // Consulta do resumo da operação de pagametno.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpDetalheRetornoOperacaoPagamento; // (E)
    Fautorizacao: tautorizacao_tpDetalheRetornoOperacaoPagamento; // (E)
    Fautorizacao_IsSet_: boolean;
    FdataPagamento: string; // (E)
    FdataPagamento_IsSet_: boolean;
    FvalorPagamento: string; // (E)
    FvalorPagamento_IsSet_: boolean;
    Fpedagio: tpedagio_tpDetalheRetornoOperacaoPagamento; // (E)
    Fpedagio_IsSet_: boolean;
    Fsaldo: tsaldo_tpDetalheRetornoOperacaoPagamento; // (E)
    Fsaldo_IsSet_: boolean;
    FpagamentoPedagio: tpagamentoPedagio; // (E)
    FpagamentoPedagio_IsSet_: boolean;
    FstatusPagamentoValor: tbyte; // (E)
    FstatusPagamentoValor_IsSet_: boolean;
    FstatusPagamentoPedagio: tbyte; // (E)
    FstatusPagamentoPedagio_IsSet_: boolean;
    FgestoraCartao: string; // (E)
    FgestoraCartao_IsSet_: boolean;
    procedure Setautorizacao(value:tautorizacao_tpDetalheRetornoOperacaoPagamento);
    procedure SetdataPagamento(value:string);
    procedure SetvalorPagamento(value:string);
    procedure Setpedagio(value:tpedagio_tpDetalheRetornoOperacaoPagamento);
    procedure Setsaldo(value:tsaldo_tpDetalheRetornoOperacaoPagamento);
    procedure SetpagamentoPedagio(value:tpagamentoPedagio);
    procedure SetstatusPagamentoValor(value:tbyte);
    procedure SetstatusPagamentoPedagio(value:tbyte);
    procedure SetgestoraCartao(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpDetalheRetornoOperacaoPagamento read Fmensagens; // write Fmensagens;
    property autorizacao: tautorizacao_tpDetalheRetornoOperacaoPagamento read Fautorizacao write Setautorizacao;
    property autorizacao_IsSet_:boolean read Fautorizacao_IsSet_;
    property dataPagamento: string read FdataPagamento write SetdataPagamento; //Data do pagamento.
    property dataPagamento_IsSet_:boolean read FdataPagamento_IsSet_;
    property valorPagamento: string read FvalorPagamento write SetvalorPagamento; //Valor que foi pago.
    property valorPagamento_IsSet_:boolean read FvalorPagamento_IsSet_;
    property pedagio: tpedagio_tpDetalheRetornoOperacaoPagamento read Fpedagio write Setpedagio;
    property pedagio_IsSet_:boolean read Fpedagio_IsSet_;
    property saldo: tsaldo_tpDetalheRetornoOperacaoPagamento read Fsaldo write Setsaldo;
    property saldo_IsSet_:boolean read Fsaldo_IsSet_;
    property pagamentoPedagio: tpagamentoPedagio read FpagamentoPedagio write SetpagamentoPedagio;
    property pagamentoPedagio_IsSet_:boolean read FpagamentoPedagio_IsSet_;
    property statusPagamentoValor: tbyte read FstatusPagamentoValor write SetstatusPagamentoValor; //Status do pagamento de valor da operação de pagamento. Aberto = 0, Pago = 1, Cancelado = 2, Erro = 3.
    property statusPagamentoValor_IsSet_:boolean read FstatusPagamentoValor_IsSet_;
    property statusPagamentoPedagio: tbyte read FstatusPagamentoPedagio write SetstatusPagamentoPedagio; //Status do pagamento de pedágio da  operação de pagamento. Aberto = 0, Pago = 1, Cancelado = 2, Erro = 3.
    property statusPagamentoPedagio_IsSet_:boolean read FstatusPagamentoPedagio_IsSet_;
    property gestoraCartao: string read FgestoraCartao write SetgestoraCartao; //Indica a gestora de cartões da operação de pagamento.
    property gestoraCartao_IsSet_:boolean read FgestoraCartao_IsSet_;
  end;

const
  sntpRetornoConsultaOperacaoPagamento = 'tpRetornoConsultaOperacaoPagamento';
  sntpRetornoConsultaOperacaoPagamento_mensagens = 'mensagens';
  sntpRetornoConsultaOperacaoPagamento_envioConsultaOperacaoPagamento = 'envioConsultaOperacaoPagamento';
  sntpRetornoConsultaOperacaoPagamento_retConsultaOperacaoPagamento = 'retConsultaOperacaoPagamento';

type
  ttpRetornoConsultaOperacaoPagamento = class( tBaseNddWS ) // Retorno da consulta da operação de pagamento.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpRetornoConsultaOperacaoPagamento; // (E)
    Fmensagens_IsSet_: boolean;
    FenvioConsultaOperacaoPagamento: ttpInfConsultaOperacaoPagamento; // (E)
    FenvioConsultaOperacaoPagamento_IsSet_: boolean;
    FretConsultaOperacaoPagamento: ttpDetalheRetornoOperacaoPagamento; // (E)
    FretConsultaOperacaoPagamento_IsSet_: boolean;
    procedure Setmensagens(value:tmensagens_tpRetornoConsultaOperacaoPagamento);
    procedure SetenvioConsultaOperacaoPagamento(value:ttpInfConsultaOperacaoPagamento);
    procedure SetretConsultaOperacaoPagamento(value:ttpDetalheRetornoOperacaoPagamento);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpRetornoConsultaOperacaoPagamento read Fmensagens write Setmensagens;
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property envioConsultaOperacaoPagamento: ttpInfConsultaOperacaoPagamento read FenvioConsultaOperacaoPagamento write SetenvioConsultaOperacaoPagamento; //Informações do envio da consulta da operação de pagamento.
    property envioConsultaOperacaoPagamento_IsSet_:boolean read FenvioConsultaOperacaoPagamento_IsSet_;
    property retConsultaOperacaoPagamento: ttpDetalheRetornoOperacaoPagamento read FretConsultaOperacaoPagamento write SetretConsultaOperacaoPagamento;
    property retConsultaOperacaoPagamento_IsSet_:boolean read FretConsultaOperacaoPagamento_IsSet_;
  end;

const
  snpagamento_tpRetornoOperacaoPagamento = 'pagamento';
  snpagamento_tpRetornoOperacaoPagamento_envioOperacaoPagamento = 'envioOperacaoPagamento';
  snpagamento_tpRetornoOperacaoPagamento_retornoOperacaoPagamento = 'retornoOperacaoPagamento';
  anpagamento_tpRetornoOperacaoPagamento_impAuto = 'impAuto';

type
  tpagamento_tpRetornoOperacaoPagamento = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FenvioOperacaoPagamento: ttpInfRetornoOperacaoPagamento; // (E)
    FretornoOperacaoPagamento: ttpRetornoOperacaoPagamentoDetalhe; // (E)
    FretornoOperacaoPagamento_IsSet_: boolean;
    FimpAuto: tbyte; // (A)
    FimpAuto_IsSet_: boolean;
    procedure SetretornoOperacaoPagamento(value:ttpRetornoOperacaoPagamentoDetalhe);
    procedure SetimpAuto(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property envioOperacaoPagamento: ttpInfRetornoOperacaoPagamento read FenvioOperacaoPagamento; // write FenvioOperacaoPagamento;
    property retornoOperacaoPagamento: ttpRetornoOperacaoPagamentoDetalhe read FretornoOperacaoPagamento write SetretornoOperacaoPagamento;
    property retornoOperacaoPagamento_IsSet_:boolean read FretornoOperacaoPagamento_IsSet_;
    property impAuto: tbyte read FimpAuto write SetimpAuto;
    property impAuto_IsSet_:boolean read FimpAuto_IsSet_;
  end;

const
  snmensagens_tpRetornoOperacaoPagamento = 'mensagens';
  snmensagens_tpRetornoOperacaoPagamento_mensagem = 'mensagem';

type
  tmensagens_tpRetornoOperacaoPagamento = class( tBaseNddWS ) // Lista das mensagens de erro.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  sntpRetornoOperacaoPagamento = 'tpRetornoOperacaoPagamento';
  sntpRetornoOperacaoPagamento_mensagens = 'mensagens';
  sntpRetornoOperacaoPagamento_pagamento = 'pagamento';

type
  ttpRetornoOperacaoPagamento = class( tBaseNddWS ) // Retorno da consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpRetornoOperacaoPagamento; // (E)
    Fmensagens_IsSet_: boolean;
    Fpagamento: tpagamento_tpRetornoOperacaoPagamento; // (E)
    Fpagamento_IsSet_: boolean;
    procedure Setmensagens(value:tmensagens_tpRetornoOperacaoPagamento);
    procedure Setpagamento(value:tpagamento_tpRetornoOperacaoPagamento);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpRetornoOperacaoPagamento read Fmensagens write Setmensagens;
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property pagamento: tpagamento_tpRetornoOperacaoPagamento read Fpagamento write Setpagamento;
    property pagamento_IsSet_:boolean read Fpagamento_IsSet_;
  end;

const
  sninfConsulta = 'infConsulta';
  sninfConsulta_mensagem = 'mensagem';
  sninfConsulta_nomeColaborador = 'nomeColaborador';
  sninfConsulta_cpfColaborador = 'cpfColaborador';
  sninfConsulta_dataEntregaCartao = 'dataEntregaCartao';
  sninfConsulta_cartaoId = 'cartaoId';
  sninfConsulta_gestoraCartao = 'gestoraCartao';
  sninfConsulta_saldo = 'saldo';

type
  tinfConsulta = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fmensagem: ttpMensagem; // (E)
    FnomeColaborador: string; // (E)
    FnomeColaborador_IsSet_: boolean;
    FcpfColaborador: string; // (E)
    FcpfColaborador_IsSet_: boolean;
    FdataEntregaCartao: string; // (E)
    FdataEntregaCartao_IsSet_: boolean;
    FcartaoId: int64; // (E)
    FcartaoId_IsSet_: boolean;
    FgestoraCartao: string; // (E)
    FgestoraCartao_IsSet_: boolean;
    Fsaldo: tsaldo; // (E)
    Fsaldo_IsSet_: boolean;
    procedure SetnomeColaborador(value:string);
    procedure SetcpfColaborador(value:string);
    procedure SetdataEntregaCartao(value:string);
    procedure SetcartaoId(value:int64);
    procedure SetgestoraCartao(value:string);
    procedure Setsaldo(value:tsaldo);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: ttpMensagem read Fmensagem; // write Fmensagem; //Observação da consulta.
    property nomeColaborador: string read FnomeColaborador write SetnomeColaborador; //Nome do colaborador vinculado ao cartão.
    property nomeColaborador_IsSet_:boolean read FnomeColaborador_IsSet_;
    property cpfColaborador: string read FcpfColaborador write SetcpfColaborador; //Cpf do colaborador vinculado ao cartão.
    property cpfColaborador_IsSet_:boolean read FcpfColaborador_IsSet_;
    property dataEntregaCartao: string read FdataEntregaCartao write SetdataEntregaCartao; //Data que foi entregue o cartão para o colaborador.
    property dataEntregaCartao_IsSet_:boolean read FdataEntregaCartao_IsSet_;
    property cartaoId: int64 read FcartaoId write SetcartaoId; //Identificador do cartão.
    property cartaoId_IsSet_:boolean read FcartaoId_IsSet_;
    property gestoraCartao: string read FgestoraCartao write SetgestoraCartao; //Gestora de cartão do cartão do cartão.
    property gestoraCartao_IsSet_:boolean read FgestoraCartao_IsSet_;
    property saldo: tsaldo read Fsaldo write Setsaldo;
    property saldo_IsSet_:boolean read Fsaldo_IsSet_;
  end;

const
  snretornoConsulta = 'retornoConsulta';
  snretornoConsulta_infConsulta = 'infConsulta';

type
  tretornoConsulta = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FinfConsulta: tManagedStringList; // of tinfConsulta(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infConsulta: tManagedStringList read FinfConsulta write FinfConsulta; // of tinfConsulta
  end;

const
  snmensagens_tpRetornoConsultaSaldoCartaoFrota = 'mensagens';
  snmensagens_tpRetornoConsultaSaldoCartaoFrota_mensagem = 'mensagem';

type
  tmensagens_tpRetornoConsultaSaldoCartaoFrota = class( tBaseNddWS ) // Lista das mensagens de erro.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  sntpRetornoConsultaSaldoCartaoFrota = 'tpRetornoConsultaSaldoCartaoFrota';
  sntpRetornoConsultaSaldoCartaoFrota_mensagens = 'mensagens';
  sntpRetornoConsultaSaldoCartaoFrota_envioConsulta = 'envioConsulta';
  sntpRetornoConsultaSaldoCartaoFrota_retornoConsulta = 'retornoConsulta';

type
  ttpRetornoConsultaSaldoCartaoFrota = class( tBaseNddWS ) // Retorno da consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpRetornoConsultaSaldoCartaoFrota; // (E)
    Fmensagens_IsSet_: boolean;
    FenvioConsulta: tenvioConsulta; // (E)
    FretornoConsulta: tretornoConsulta; // (E)
    FretornoConsulta_IsSet_: boolean;
    procedure Setmensagens(value:tmensagens_tpRetornoConsultaSaldoCartaoFrota);
    procedure SetretornoConsulta(value:tretornoConsulta);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpRetornoConsultaSaldoCartaoFrota read Fmensagens write Setmensagens;
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property envioConsulta: tenvioConsulta read FenvioConsulta; // write FenvioConsulta;
    property retornoConsulta: tretornoConsulta read FretornoConsulta write SetretornoConsulta;
    property retornoConsulta_IsSet_:boolean read FretornoConsulta_IsSet_;
  end;

const
  snmensagens_tpRetornoConsultaResumoOT = 'mensagens';
  snmensagens_tpRetornoConsultaResumoOT_mensagem = 'mensagem';

type
  tmensagens_tpRetornoConsultaResumoOT = class( tBaseNddWS ) // Lista das mensagens de erro.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  snmensagens = 'mensagens';
  snmensagens_mensagem = 'mensagem';

type
  tmensagens = class( tBaseNddWS ) // Lista das mensagens de erro.
  private
    F_NameSpaceAlias: string;
    Fmensagem: tManagedStringList; // of ttpMensagem(E)
  public
    class function CreateFromXmlString( s: string): tmensagens;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: tManagedStringList read Fmensagem write Fmensagem; // of ttpMensagem
  end;

const
  sntpRetornoPadrao = 'tpRetornoPadrao';
  sntpRetornoPadrao_mensagem = 'mensagem';
  antpRetornoPadrao_versao = 'versao';

type
  ttpRetornoPadrao = class( tBaseNddWS ) // Retorno padrão.
  private
    F_NameSpaceAlias: string;
    Fmensagem: ttpMensagem; // (E)
    Fversao: t; // (A)
    Fversao_IsSet_: boolean;
    procedure Setversao(value:t);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagem: ttpMensagem read Fmensagem; // write Fmensagem;
    property versao: t read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
  end;

const
  sntpMensagemErro = 'tpMensagemErro';
  sntpMensagemErro_descricao = 'Descricao';

type
  ttpMensagemErro = class( tBaseNddWS ) // Lista das mensagens de erro.
  private
    F_NameSpaceAlias: string;
    Fdescricao: tManagedStringList; // of ttpString(E)
  public
    class function CreateFromXmlString( s: string): ttpMensagemErro;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property descricao: tManagedStringList read Fdescricao write Fdescricao; // of ttpString
  end;

const
  sntpRetornoConfiguracao = 'tpRetornoConfiguracao';
  sntpRetornoConfiguracao_cnpj = 'cnpj';
  sntpRetornoConfiguracao_mensagens = 'mensagens';
  sntpRetornoConfiguracao_impressao = 'impressao';
  sntpRetornoConfiguracao_configuracao = 'configuracao';

type
  ttpRetornoConfiguracao = class( tBaseNddWS ) // Informações do retorno da impressão de documentos.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fmensagens: ttpMensagemErro; // (E)
    Fmensagens_IsSet_: boolean;
    Fimpressao: tManagedStringList; // of timpressao_tpRetornoConfiguracao(E)
    Fconfiguracao: tconfiguracao; // (E)
    procedure Setmensagens(value:ttpMensagemErro);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante.
    property mensagens: ttpMensagemErro read Fmensagens write Setmensagens; //Lista das mensagens de erro.
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property impressao: tManagedStringList read Fimpressao write Fimpressao; // of timpressao_tpRetornoConfiguracao
    property configuracao: tconfiguracao read Fconfiguracao; // write Fconfiguracao;
  end;

const
  sntpRetornoImpressaoDocumentos = 'tpRetornoImpressaoDocumentos';
  sntpRetornoImpressaoDocumentos_cnpj = 'cnpj';
  sntpRetornoImpressaoDocumentos_mensagens = 'mensagens';
  sntpRetornoImpressaoDocumentos_impressao = 'impressao';

type
  ttpRetornoImpressaoDocumentos = class( tBaseNddWS ) // Informações do retorno da impressão de documentos.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fmensagens: ttpMensagemErro; // (E)
    Fmensagens_IsSet_: boolean;
    Fimpressao: tManagedStringList; // of timpressao_tpRetornoImpressaoDocumentos(E)
    procedure Setmensagens(value:ttpMensagemErro);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante.
    property mensagens: ttpMensagemErro read Fmensagens write Setmensagens; //Lista das mensagens de erro.
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property impressao: tManagedStringList read Fimpressao write Fimpressao; // of timpressao_tpRetornoImpressaoDocumentos
  end;

const
  sntpRetornoConsultaImpressaoDocumentos = 'tpRetornoConsultaImpressaoDocumentos';
  sntpRetornoConsultaImpressaoDocumentos_mensagens = 'mensagens';
  sntpRetornoConsultaImpressaoDocumentos_infImpressao = 'infImpressao';

type
  ttpRetornoConsultaImpressaoDocumentos = class( tBaseNddWS ) // Retorno do encerramento da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: ttpMensagemErro; // (E)
    Fmensagens_IsSet_: boolean;
    FinfImpressao: ttpRetornoImpressaoDocumentos; // (E)
    FinfImpressao_IsSet_: boolean;
    procedure Setmensagens(value:ttpMensagemErro);
    procedure SetinfImpressao(value:ttpRetornoImpressaoDocumentos);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: ttpMensagemErro read Fmensagens write Setmensagens; //Lista das mensagens de erro.
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property infImpressao: ttpRetornoImpressaoDocumentos read FinfImpressao write SetinfImpressao; //Dados referentes a impressao de documentos.
    property infImpressao_IsSet_:boolean read FinfImpressao_IsSet_;
  end;

const
  sntpRetornoConsultaEncerramentoOT = 'tpRetornoConsultaEncerramentoOT';
  sntpRetornoConsultaEncerramentoOT_mensagens = 'mensagens';
  sntpRetornoConsultaEncerramentoOT_encerramento = 'encerramento';

type
  ttpRetornoConsultaEncerramentoOT = class( tBaseNddWS ) // Retorno do encerramento da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: ttpMensagemErro; // (E)
    Fmensagens_IsSet_: boolean;
    Fencerramento: ttpRetornoEncerramentoOT; // (E)
    Fencerramento_IsSet_: boolean;
    procedure Setmensagens(value:ttpMensagemErro);
    procedure Setencerramento(value:ttpRetornoEncerramentoOT);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: ttpMensagemErro read Fmensagens write Setmensagens; //Lista das mensagens de erro.
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property encerramento: ttpRetornoEncerramentoOT read Fencerramento write Setencerramento; //Dados referentes ao encerramento.
    property encerramento_IsSet_:boolean read Fencerramento_IsSet_;
  end;

const
  sntpRetornoConsultaPgtos = 'tpRetornoConsultaPgtos';
  sntpRetornoConsultaPgtos_mensagens = 'mensagens';
  sntpRetornoConsultaPgtos_pgtos = 'pgtos';

type
  ttpRetornoConsultaPgtos = class( tBaseNddWS ) // Retorno das consultas de pagementos realizados.
  private
    F_NameSpaceAlias: string;
    Fmensagens: ttpMensagemErro; // (E)
    Fmensagens_IsSet_: boolean;
    Fpgtos: tpgtos; // (E)
    Fpgtos_IsSet_: boolean;
    procedure Setmensagens(value:ttpMensagemErro);
    procedure Setpgtos(value:tpgtos);
  public
    class function CreateFromXmlString( s: string): ttpRetornoConsultaPgtos;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: ttpMensagemErro read Fmensagens write Setmensagens; //Lista das mensagens de erro.
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property pgtos: tpgtos read Fpgtos write Setpgtos;
    property pgtos_IsSet_:boolean read Fpgtos_IsSet_;
  end;

const
  sntpRetornoPagamentoImediato = 'tpRetornoPagamentoImediato';
  sntpRetornoPagamentoImediato_mensagens = 'mensagens';
  sntpRetornoPagamentoImediato_cnpj = 'cnpj';
  sntpRetornoPagamentoImediato_autorizacao = 'autorizacao';
  sntpRetornoPagamentoImediato_nomeParcela = 'nomeParcela';

type
  ttpRetornoPagamentoImediato = class( tBaseNddWS ) // Retorno da alteração de operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: ttpMensagemErro; // (E)
    Fmensagens_IsSet_: boolean;
    Fcnpj: string; // (E)
    Fcnpj_IsSet_: boolean;
    Fautorizacao: ttpAutorizacaoOT; // (E)
    Fautorizacao_IsSet_: boolean;
    FnomeParcela: string; // (E)
    FnomeParcela_IsSet_: boolean;
    procedure Setmensagens(value:ttpMensagemErro);
    procedure Setcnpj(value:string);
    procedure Setautorizacao(value:ttpAutorizacaoOT);
    procedure SetnomeParcela(value:string);
  public
    class function CreateFromXmlString(s: string): ttpRetornoPagamentoImediato;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: ttpMensagemErro read Fmensagens write Setmensagens;
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property cnpj: string read Fcnpj write Setcnpj; //CNPJ da contratante.
    property cnpj_IsSet_:boolean read Fcnpj_IsSet_;
    property autorizacao: ttpAutorizacaoOT read Fautorizacao write Setautorizacao; //Identificação da operação de transporte.
    property autorizacao_IsSet_:boolean read Fautorizacao_IsSet_;
    property nomeParcela: string read FnomeParcela write SetnomeParcela; //Nome da parcela a ser paga.
    property nomeParcela_IsSet_:boolean read FnomeParcela_IsSet_;
  end;

const
  sntpRetornoConsultaCancelamento = 'tpRetornoConsultaCancelamento';
  sntpRetornoConsultaCancelamento_mensagens = 'mensagens';
  sntpRetornoConsultaCancelamento_cancelamento = 'cancelamento';

type
  ttpRetornoConsultaCancelamento = class( tBaseNddWS ) // Retorno do cancelamento da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: ttpMensagemErro; // (E)
    Fmensagens_IsSet_: boolean;
    Fcancelamento: ttpRetornoCancelamento; // (E)
    Fcancelamento_IsSet_: boolean;
    procedure Setmensagens(value:ttpMensagemErro);
    procedure Setcancelamento(value:ttpRetornoCancelamento);
  public
    class function CreateFromXmlString( s: string): ttpRetornoConsultaCancelamento;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: ttpMensagemErro read Fmensagens write Setmensagens; //Lista das mensagens de erro.
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property cancelamento: ttpRetornoCancelamento read Fcancelamento write Setcancelamento; //Dados referentes ao cancelamento.
    property cancelamento_IsSet_:boolean read Fcancelamento_IsSet_;
  end;

const
  sntpDirecionamentoPedagio = 'tpDirecionamentoPedagio';
  sntpDirecionamentoPedagio_pedagioERP = 'pedagioERP';
  sntpDirecionamentoPedagio_cpf = 'cpf';
  sntpDirecionamentoPedagio_valor = 'valor';
  sntpDirecionamentoPedagio_rota = 'rota';
  sntpDirecionamentoPedagio_categoriaPedagio = 'categoriaPedagio';

type
  ttpDirecionamentoPedagio = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FpedagioERP: string; // (E)
    Fcpf: string; // (E)
    Fvalor: string; // (E)
    Fvalor_IsSet_: boolean;
    Frota: ttpRota; // (E)
    FcategoriaPedagio: integer; // (E)
    procedure Setvalor(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property pedagioERP: string read FpedagioERP write FpedagioERP; //Identificador do direcionamento de pedágio.
    property cpf: string read Fcpf write Fcpf; //Número do CPF do condutor.
    property valor: string read Fvalor write Setvalor; //O valor do pedágio a ser pago para o condutor. Caso utilizar o calculo via roterizador este campo não deve ser informado.
    property valor_IsSet_:boolean read Fvalor_IsSet_;
    property rota: ttpRota read Frota; // write Frota; //Define a rora do direcionamento de pedágio.
    property categoriaPedagio: integer read FcategoriaPedagio write FcategoriaPedagio; //Se a rota estiver utilizando o  roteirizador é necessário informar qual a categoria para calculo de pedágio. Valor padrão é 0 = Isento
  end;

const
  sndirecionamento_pedagio_financeiro = 'direcionamento';
  sndirecionamento_pedagio_financeiro_adicionar = 'adicionar';
  sndirecionamento_pedagio_financeiro_remover = 'remover';

type
  tdirecionamento_pedagio_financeiro = class( tBaseNddWS ) // Dados para alteração de direcionamento de pedágio para condutor
  private
    F_NameSpaceAlias: string;
    Fadicionar: ttpDirecionamentoPedagio; // (E)
    Fadicionar_IsSet_: boolean;
    Fremover: tremover; // (E)
    Fremover_IsSet_: boolean;
    procedure Setadicionar(value:ttpDirecionamentoPedagio);
    procedure Setremover(value:tremover);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property adicionar: ttpDirecionamentoPedagio read Fadicionar write Setadicionar; //Informações para adicionar um novo direcionamento de pedágio.
    property adicionar_IsSet_:boolean read Fadicionar_IsSet_;
    property remover: tremover read Fremover write Setremover;
    property remover_IsSet_:boolean read Fremover_IsSet_;
  end;

const
  snpedagio_financeiro = 'pedagio';
  snpedagio_financeiro_valor = 'valor';
  snpedagio_financeiro_direcionamento = 'direcionamento';

type
  tpedagio_financeiro = class( tBaseNddWS ) // Atualizar o valor de pedagio da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fvalor: string; // (E)
    Fvalor_IsSet_: boolean;
    Fdirecionamento: tdirecionamento_pedagio_financeiro; // (E)
    Fdirecionamento_IsSet_: boolean;
    procedure Setvalor(value:string);
    procedure Setdirecionamento(value:tdirecionamento_pedagio_financeiro);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property valor: string read Fvalor write Setvalor; //Informar o novo valor total do pedágio. Apenas para operações de transporte sem direcionamento de pedágio.
    property valor_IsSet_:boolean read Fvalor_IsSet_;
    property direcionamento: tdirecionamento_pedagio_financeiro read Fdirecionamento write Setdirecionamento;
    property direcionamento_IsSet_:boolean read Fdirecionamento_IsSet_;
  end;

const
  snfinanceiro = 'financeiro';
  snfinanceiro_novaParc = 'novaParc';
  snfinanceiro_ajustaParc = 'ajustaParc';
  snfinanceiro_pedagio = 'pedagio';

type
  tfinanceiro = class( tBaseNddWS ) // Alteração em dados que envolvem o fluxo financeiro.
  private
    F_NameSpaceAlias: string;
    FnovaParc: ttpAlterarParcela; // (E)
    FnovaParc_IsSet_: boolean;
    FajustaParc: tajustaParc; // (E)
    FajustaParc_IsSet_: boolean;
    Fpedagio: tpedagio_financeiro; // (E)
    Fpedagio_IsSet_: boolean;
    procedure SetnovaParc(value:ttpAlterarParcela);
    procedure SetajustaParc(value:tajustaParc);
    procedure Setpedagio(value:tpedagio_financeiro);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property novaParc: ttpAlterarParcela read FnovaParc write SetnovaParc; //Inclusão de nova parcela para a operação de transporte.
    property novaParc_IsSet_:boolean read FnovaParc_IsSet_;
    property ajustaParc: tajustaParc read FajustaParc write SetajustaParc;
    property ajustaParc_IsSet_:boolean read FajustaParc_IsSet_;
    property pedagio: tpedagio_financeiro read Fpedagio write Setpedagio;
    property pedagio_IsSet_:boolean read Fpedagio_IsSet_;
  end;

const
  snalteracao = 'alteracao';
  snalteracao_ANTT = 'ANTT';
  snalteracao_financeiro = 'financeiro';
  snalteracao_adicionais = 'adicionais';
  snalteracao_semMF = 'semMF';
  snalteracao_condutor = 'condutor';

type
  talteracao = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FANTT: tANTT; // (E)
    FANTT_IsSet_: boolean;
    Ffinanceiro: tfinanceiro; // (E)
    Ffinanceiro_IsSet_: boolean;
    Fadicionais: ttpAdicionalImpressao; // (E)
    Fadicionais_IsSet_: boolean;
    FsemMF: tsemMF; // (E)
    FsemMF_IsSet_: boolean;
    Fcondutor: tcondutor_alteracao; // (E)
    Fcondutor_IsSet_: boolean;
    procedure SetANTT(value:tANTT);
    procedure Setfinanceiro(value:tfinanceiro);
    procedure Setadicionais(value:ttpAdicionalImpressao);
    procedure SetsemMF(value:tsemMF);
    procedure Setcondutor(value:tcondutor_alteracao);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ANTT: tANTT read FANTT write SetANTT;
    property ANTT_IsSet_:boolean read FANTT_IsSet_;
    property financeiro: tfinanceiro read Ffinanceiro write Setfinanceiro;
    property financeiro_IsSet_:boolean read Ffinanceiro_IsSet_;
    property adicionais: ttpAdicionalImpressao read Fadicionais write Setadicionais; //Dados adicionais para uso na impressão
    property adicionais_IsSet_:boolean read Fadicionais_IsSet_;
    property semMF: tsemMF read FsemMF write SetsemMF;
    property semMF_IsSet_:boolean read FsemMF_IsSet_;
    property condutor: tcondutor_alteracao read Fcondutor write Setcondutor;
    property condutor_IsSet_:boolean read Fcondutor_IsSet_;
  end;

const
  snalteracoes = 'alteracoes';
  snalteracoes_alteracao = 'alteracao';

type
  talteracoes = class( tBaseNddWS ) // Lista de alterações a serem feitas na operação de transporte.
  private
    F_NameSpaceAlias: string;
    Falteracao: tManagedStringList; // of talteracao(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property alteracao: tManagedStringList read Falteracao write Falteracao; // of talteracao
  end;

const
  sninfOT_tpAlteraOT = 'infOT';
  sninfOT_tpAlteraOT_cnpj = 'cnpj';
  sninfOT_tpAlteraOT_autorizacao = 'autorizacao';
  sninfOT_tpAlteraOT_alteracoes = 'alteracoes';
  sninfOT_tpAlteraOT_motivo = 'motivo';
  aninfOT_tpAlteraOT_ID = 'Id';

type
  tinfOT_tpAlteraOT = class( tBaseNddWS ) // Informações sobre a operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fcnpj: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    Falteracoes: talteracoes; // (E)
    Fmotivo: string; // (E)
    FID: string; // (A)
    FID_IsSet_: boolean;
    procedure SetID(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property cnpj: string read Fcnpj write Fcnpj; //CNPJ da contratante da operação que se deseja altear.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao; //Dados da autorização para a operação de transporte a ser alterada.
    property alteracoes: talteracoes read Falteracoes; // write Falteracoes;
    property motivo: string read Fmotivo write Fmotivo; //Descrever o motivo da alteração.
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
  end;

const
  sntpAlteraOT = 'tpAlteraOT';
  sntpAlteraOT_infOT = 'infOT';
  sntpAlteraOT_Signature = 'Signature';

type
  ttpAlteraOT = class( tBaseNddWS ) // Dados necessários para a alteração de uma OT.
  private
    F_NameSpaceAlias: string;
    FinfOT: tinfOT_tpAlteraOT; // (E)
    FSignature: tSignature; // (X)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infOT: tinfOT_tpAlteraOT read FinfOT; // write FinfOT;
    property Signature: tSignature read FSignature; // write FSignature;
  end;

const
  sntpAlteracaoOT = 'tpAlteracaoOT';
  sntpAlteracaoOT_OT = 'OT';
  antpAlteracaoOT_versao = 'versao';
  antpAlteracaoOT_token = 'token';

type
  ttpAlteracaoOT = class( tBaseNddWS ) // Alteração de operação de transporte.
  private
    F_NameSpaceAlias: string;
    FOT: ttpAlteraOT; // (E)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property OT: ttpAlteraOT read FOT; // write FOT;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sndirecionamentosPedagio = 'direcionamentosPedagio';
  sndirecionamentosPedagio_direcionamento = 'direcionamento';

type
  tdirecionamentosPedagio = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    Fdirecionamento: tManagedStringList; // of ttpDirecionamentoPedagio(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property direcionamento: tManagedStringList read Fdirecionamento write Fdirecionamento; // of ttpDirecionamentoPedagio
  end;

const
  sntpValores = 'tpValores';
  sntpValores_vlrFrete = 'vlrFrete';
  sntpValores_despesas = 'despesas';
  sntpValores_parcelamento = 'parcelamento';
  sntpValores_retencoes = 'retencoes';
  sntpValores_tipoRateio = 'tipoRateio';
  sntpValores_descontos = 'descontos';
  sntpValores_vlrCombustivel = 'vlrCombustivel';
  sntpValores_vlrPedagio = 'vlrPedagio';
  sntpValores_direcionamentosPedagio = 'direcionamentosPedagio';

type
  ttpValores = class( tBaseNddWS ) // Informações dos valores da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FvlrFrete: string; // (E)
    Fdespesas: ttpDespesas; // (E)
    Fdespesas_IsSet_: boolean;
    Fparcelamento: ttpParcelamento; // (E)
    Fparcelamento_IsSet_: boolean;
    Fretencoes: ttpImpostos; // (E)
    FtipoRateio: tbyte; // (E)
    Fdescontos: tdescontos; // (E)
    Fdescontos_IsSet_: boolean;
    FvlrCombustivel: string; // (E)
    FvlrCombustivel_IsSet_: boolean;
    FvlrPedagio: string; // (E)
    FvlrPedagio_IsSet_: boolean;
    FdirecionamentosPedagio: tdirecionamentosPedagio; // (E)
    FdirecionamentosPedagio_IsSet_: boolean;
    procedure Setdespesas(value:ttpDespesas);
    procedure Setparcelamento(value:ttpParcelamento);
    procedure Setdescontos(value:tdescontos);
    procedure SetvlrCombustivel(value:string);
    procedure SetvlrPedagio(value:string);
    procedure SetdirecionamentosPedagio(value:tdirecionamentosPedagio);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property vlrFrete: string read FvlrFrete write FvlrFrete; //Valor do frete. Este valor é participante do valor total da operação de transporte a ser paga ao transportador.
    property despesas: ttpDespesas read Fdespesas write Setdespesas; //Despesas a serem levadas em consideração no pagamento das operações de transporte. Este valor é participante do valor total da operação de transporte a ser paga ao transportador.
    property despesas_IsSet_:boolean read Fdespesas_IsSet_;
    property parcelamento: ttpParcelamento read Fparcelamento write Setparcelamento; //Define os dados de parcelamento para pagar a operação de transporte. Opcional para o caso do Contratante não gerir seus pagamentos pelo nddCargo
    property parcelamento_IsSet_:boolean read Fparcelamento_IsSet_;
    property retencoes: ttpImpostos read Fretencoes; // write Fretencoes; //Retenções de valroes para a operação de transporte.
    property tipoRateio: tbyte read FtipoRateio write FtipoRateio; //Determina o tipo de raterio das retenções da operação de transporte. 1 = Primeira, 2 = Última, 3 = Todas e 4 = Não reter.
    property descontos: tdescontos read Fdescontos write Setdescontos;
    property descontos_IsSet_:boolean read Fdescontos_IsSet_;
    property vlrCombustivel: string read FvlrCombustivel write SetvlrCombustivel; //Valor do combustível. Este valor é participante do valor total da operação de transporte a ser paga ao transportador.
    property vlrCombustivel_IsSet_:boolean read FvlrCombustivel_IsSet_;
    property vlrPedagio: string read FvlrPedagio write SetvlrPedagio; //Valor de vale pedágio a ser pago ao condutor da operação de transporte.
    property vlrPedagio_IsSet_:boolean read FvlrPedagio_IsSet_;
    property direcionamentosPedagio: tdirecionamentosPedagio read FdirecionamentosPedagio write SetdirecionamentosPedagio;
    property direcionamentosPedagio_IsSet_:boolean read FdirecionamentosPedagio_IsSet_;
  end;

const
  sntransp = 'transp';
  sntransp_rntrc = 'rntrc';
  sntransp_infTransportador = 'infTransportador';
  sntransp_gestoraCartao = 'gestoraCartao';
  sntransp_subcontratado = 'subcontratado';
  sntransp_rota = 'rota';
  sntransp_condutores = 'condutores';
  sntransp_veiculos = 'veiculos';
  sntransp_valores = 'valores';
  sntransp_categoriaPedagio = 'categoriaPedagio';

type
  ttransp = class( tBaseNddWS ) // Definições de elementos ligados ao transporte
  private
    F_NameSpaceAlias: string;
    Frntrc: string; // (E)
    FinfTransportador: ttpTransportador; // (E)
    FinfTransportador_IsSet_: boolean;
    FgestoraCartao: string; // (E)
    FgestoraCartao_IsSet_: boolean;
    Fsubcontratado: ttpSubcontratado; // (E)
    Fsubcontratado_IsSet_: boolean;
    Frota: ttpRota; // (E)
    Frota_IsSet_: boolean;
    Fcondutores: tcondutores; // (E)
    Fcondutores_IsSet_: boolean;
    Fveiculos: tveiculos; // (E)
    Fvalores: ttpValores; // (E)
    FcategoriaPedagio: integer; // (E)
    FcategoriaPedagio_IsSet_: boolean;
    procedure SetinfTransportador(value:ttpTransportador);
    procedure SetgestoraCartao(value:string);
    procedure Setsubcontratado(value:ttpSubcontratado);
    procedure Setrota(value:ttpRota);
    procedure Setcondutores(value:tcondutores);
    procedure SetcategoriaPedagio(value:integer);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property rntrc: string read Frntrc write Frntrc; //Contratado responsável pela prestação de serviço e que receberá os valores do frete.
    property infTransportador: ttpTransportador read FinfTransportador write SetinfTransportador; //Informações do transportador.
    property infTransportador_IsSet_:boolean read FinfTransportador_IsSet_;
    property gestoraCartao: string read FgestoraCartao write SetgestoraCartao; //Código de identificação da gestora de cartão que será usada para o pagamento desta. Este campo é opcional porque não precisa ser informado quando a operação for sem movimentação financeira para parcelas e pedágio.
    property gestoraCartao_IsSet_:boolean read FgestoraCartao_IsSet_;
    property subcontratado: ttpSubcontratado read Fsubcontratado write Setsubcontratado; //Informações referentes ao subcontratado, se existirem.
    property subcontratado_IsSet_:boolean read Fsubcontratado_IsSet_;
    property rota: ttpRota read Frota write Setrota; //Define a rora da operação de transporte.
    property rota_IsSet_:boolean read Frota_IsSet_;
    property condutores: tcondutores read Fcondutores write Setcondutores;
    property condutores_IsSet_:boolean read Fcondutores_IsSet_;
    property veiculos: tveiculos read Fveiculos; // write Fveiculos;
    property valores: ttpValores read Fvalores; // write Fvalores; //Valores do controle de viagem. Para operações de transporte sem movimentação financeira o desconto será considerado como um desconto de frete e esta valor não alterará o valor informado no frete.
    property categoriaPedagio: integer read FcategoriaPedagio write SetcategoriaPedagio; //Se a rota estiver utilizando o  roteirizador é necessário informar qual a categoria para calculo de pedágio. Valor padrão é 0 = Isento
    property categoriaPedagio_IsSet_:boolean read FcategoriaPedagio_IsSet_;
  end;

const
  sninfOT = 'infOT';
  sninfOT_ide = 'ide';
  sninfOT_carga = 'carga';
  sninfOT_contatos = 'contatos';
  sninfOT_transp = 'transp';
  sninfOT_quitacao = 'quitacao';
  sninfOT_adicionais = 'adicionais';
  sninfOT_confirmador = 'confirmador';
  aninfOT_ID = 'Id';
  aninfOT_gerPgtoFin = 'gerPgtoFin';
  aninfOT_gerPgtoPedagio = 'gerPgtoPedagio';
  aninfOT_impAuto = 'impAuto';
  aninfOT_tipoOp = 'tipoOp';
  aninfOT_utilizaDirecionamentoPedagio = 'utilizaDirecionamentoPedagio';

type
  tinfOT = class( tBaseNddWS ) // Informações sobre a operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fide: tide; // (E)
    Fcarga: ttpCarga; // (E)
    Fcontatos: tcontatos; // (E)
    Fcontatos_IsSet_: boolean;
    Ftransp: ttransp; // (E)
    Fquitacao: tquitacao; // (E)
    Fquitacao_IsSet_: boolean;
    Fadicionais: ttpAdicionalImpressao; // (E)
    Fadicionais_IsSet_: boolean;
    Fconfirmador: tconfirmador; // (E)
    Fconfirmador_IsSet_: boolean;
    FID: string; // (A)
    FID_IsSet_: boolean;
    FgerPgtoFin: tbyte; // (A)
    FgerPgtoFin_IsSet_: boolean;
    FgerPgtoPedagio: tbyte; // (A)
    FgerPgtoPedagio_IsSet_: boolean;
    FimpAuto: tbyte; // (A)
    FimpAuto_IsSet_: boolean;
    FtipoOp: tbyte; // (A)
    FtipoOp_IsSet_: boolean;
    FutilizaDirecionamentoPedagio: tbyte; // (A)
    FutilizaDirecionamentoPedagio_IsSet_: boolean;
    procedure Setcontatos(value:tcontatos);
    procedure Setquitacao(value:tquitacao);
    procedure Setadicionais(value:ttpAdicionalImpressao);
    procedure Setconfirmador(value:tconfirmador);
    procedure SetID(value:string);
    procedure SetgerPgtoFin(value:tbyte);
    procedure SetgerPgtoPedagio(value:tbyte);
    procedure SetimpAuto(value:tbyte);
    procedure SettipoOp(value:tbyte);
    procedure SetutilizaDirecionamentoPedagio(value:tbyte);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property ide: tide read Fide; // write Fide;
    property carga: ttpCarga read Fcarga; // write Fcarga; //Dados da carga que indica o tipo da viagem, podendo ser lotação ou fracionada.
    property contatos: tcontatos read Fcontatos write Setcontatos;
    property contatos_IsSet_:boolean read Fcontatos_IsSet_;
    property transp: ttransp read Ftransp; // write Ftransp;
    property quitacao: tquitacao read Fquitacao write Setquitacao;
    property quitacao_IsSet_:boolean read Fquitacao_IsSet_;
    property adicionais: ttpAdicionalImpressao read Fadicionais write Setadicionais; //Dados adicionais para uso na impressão
    property adicionais_IsSet_:boolean read Fadicionais_IsSet_;
    property confirmador: tconfirmador read Fconfirmador write Setconfirmador;
    property confirmador_IsSet_:boolean read Fconfirmador_IsSet_;
    property ID: string read FID write SetID;
    property ID_IsSet_:boolean read FID_IsSet_;
    property gerPgtoFin: tbyte read FgerPgtoFin write SetgerPgtoFin;
    property gerPgtoFin_IsSet_:boolean read FgerPgtoFin_IsSet_;
    property gerPgtoPedagio: tbyte read FgerPgtoPedagio write SetgerPgtoPedagio;
    property gerPgtoPedagio_IsSet_:boolean read FgerPgtoPedagio_IsSet_;
    property impAuto: tbyte read FimpAuto write SetimpAuto;
    property impAuto_IsSet_:boolean read FimpAuto_IsSet_;
    property tipoOp: tbyte read FtipoOp write SettipoOp;
    property tipoOp_IsSet_:boolean read FtipoOp_IsSet_;
    property utilizaDirecionamentoPedagio: tbyte read FutilizaDirecionamentoPedagio write SetutilizaDirecionamentoPedagio;
    property utilizaDirecionamentoPedagio_IsSet_:boolean read FutilizaDirecionamentoPedagio_IsSet_;
  end;

const
  sntpOT = 'tpOT';
  sntpOT_infOT = 'infOT';
  sntpOT_Signature = 'Signature';

type
  ttpOT = class( tBaseNddWS ) // Operação de transporte.
  private
    F_NameSpaceAlias: string;
    FinfOT: tinfOT; // (E)
    FSignature: tSignature; // (X)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infOT: tinfOT read FinfOT; // write FinfOT;
    property Signature: tSignature read FSignature; // write FSignature;
  end;

const
  snoperacoes = 'operacoes';
  snoperacoes_OT = 'OT';

type
  toperacoes = class( tBaseNddWS ) // Lista de operações de transporte a serem processadas.
  private
    F_NameSpaceAlias: string;
    FOT: tManagedStringList; // of ttpOT(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property OT: tManagedStringList read FOT write FOT; // of ttpOT
  end;

const
  sntpLoteOT = 'tpLoteOT';
  sntpLoteOT_operacoes = 'operacoes';
  antpLoteOT_versao = 'versao';
  antpLoteOT_token = 'token';

type
  ttpLoteOT = class( tBaseNddWS ) // Lote de operações de transporte.
  private
    F_NameSpaceAlias: string;
    Foperacoes: toperacoes; // (E)
    Fversao: ttoken; // (A)
    Fversao_IsSet_: boolean;
    Ftoken: string; // (A)
    Ftoken_IsSet_: boolean;
    procedure Setversao(value:ttoken);
    procedure Settoken(value:string);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property operacoes: toperacoes read Foperacoes; // write Foperacoes;
    property versao: ttoken read Fversao write Setversao;
    property versao_IsSet_:boolean read Fversao_IsSet_;
    property token: string read Ftoken write Settoken;
    property token_IsSet_:boolean read Ftoken_IsSet_;
  end;

const
  sndirecionamento_tpResumoDirecionamentosPedagio = 'direcionamento';
  sndirecionamento_tpResumoDirecionamentosPedagio_pedagioERP = 'pedagioERP';
  sndirecionamento_tpResumoDirecionamentosPedagio_cpf = 'cpf';
  sndirecionamento_tpResumoDirecionamentosPedagio_rotaERP = 'rotaERP';
  sndirecionamento_tpResumoDirecionamentosPedagio_valor = 'valor';
  sndirecionamento_tpResumoDirecionamentosPedagio_origem = 'origem';
  sndirecionamento_tpResumoDirecionamentosPedagio_destino = 'destino';
  sndirecionamento_tpResumoDirecionamentosPedagio_status = 'status';
  sndirecionamento_tpResumoDirecionamentosPedagio_categoriaPedagio = 'categoriaPedagio';

type
  tdirecionamento_tpResumoDirecionamentosPedagio = class( tBaseNddWS ) // Informações do direcionamento de pedágio.
  private
    F_NameSpaceAlias: string;
    FpedagioERP: string; // (E)
    Fcpf: string; // (E)
    FrotaERP: string; // (E)
    Fvalor: string; // (E)
    Forigem: string; // (E)
    Fdestino: string; // (E)
    Fstatus: tbyte; // (E)
    FcategoriaPedagio: integer; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property pedagioERP: string read FpedagioERP write FpedagioERP; //Identificador do direcionamento de pedágio.
    property cpf: string read Fcpf write Fcpf; //Número do CPF do condutor.
    property rotaERP: string read FrotaERP write FrotaERP; //Nome da rota no ERP utilizado no direcionamento.
    property valor: string read Fvalor write Fvalor; //Valor total do pedágio direcionado.
    property origem: string read Forigem write Forigem; //Cidade e estado de origem.
    property destino: string read Fdestino write Fdestino; //Cidade e estado de destino.
    property status: tbyte read Fstatus write Fstatus; //Status do pagamento do pedágio.
    property categoriaPedagio: integer read FcategoriaPedagio write FcategoriaPedagio; //Categoria do pedágio utilizada no direcionamento.
  end;

const
  sntpResumoDirecionamentosPedagio = 'tpResumoDirecionamentosPedagio';
  sntpResumoDirecionamentosPedagio_direcionamento = 'direcionamento';

type
  ttpResumoDirecionamentosPedagio = class( tBaseNddWS ) // Informações para direcionamento de pedágio.
  private
    F_NameSpaceAlias: string;
    Fdirecionamento: tManagedStringList; // of tdirecionamento_tpResumoDirecionamentosPedagio(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property direcionamento: tManagedStringList read Fdirecionamento write Fdirecionamento; // of tdirecionamento_tpResumoDirecionamentosPedagio
  end;

const
  sntpInfRetornoConsultaResumoOT = 'tpInfRetornoConsultaResumoOT';
  sntpInfRetornoConsultaResumoOT_dataHora = 'dataHora';
  sntpInfRetornoConsultaResumoOT_ide = 'ide';
  sntpInfRetornoConsultaResumoOT_autorizacao = 'autorizacao';
  sntpInfRetornoConsultaResumoOT_avisoTransportador = 'avisoTransportador';
  sntpInfRetornoConsultaResumoOT_valores = 'valores';
  sntpInfRetornoConsultaResumoOT_pedagio = 'pedagio';
  sntpInfRetornoConsultaResumoOT_direcionamentosPedagio = 'direcionamentosPedagio';
  sntpInfRetornoConsultaResumoOT_parcelas = 'parcelas';
  sntpInfRetornoConsultaResumoOT_condutores = 'condutores';

type
  ttpInfRetornoConsultaResumoOT = class( tBaseNddWS ) // Informações do retorno da consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FdataHora: string; // (E)
    Fide: tide_tpInfRetornoConsultaResumoOT; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    FavisoTransportador: string; // (E)
    FavisoTransportador_IsSet_: boolean;
    Fvalores: ttpRetornoValores; // (E)
    Fpedagio: tpedagio_tpInfRetornoConsultaResumoOT; // (E)
    Fpedagio_IsSet_: boolean;
    FdirecionamentosPedagio: ttpResumoDirecionamentosPedagio; // (E)
    FdirecionamentosPedagio_IsSet_: boolean;
    Fparcelas: tparcelas_tpInfRetornoConsultaResumoOT; // (E)
    Fparcelas_IsSet_: boolean;
    Fcondutores: tcondutores_tpInfRetornoConsultaResumoOT; // (E)
    Fcondutores_IsSet_: boolean;
    procedure SetavisoTransportador(value:string);
    procedure Setpedagio(value:tpedagio_tpInfRetornoConsultaResumoOT);
    procedure SetdirecionamentosPedagio(value:ttpResumoDirecionamentosPedagio);
    procedure Setparcelas(value:tparcelas_tpInfRetornoConsultaResumoOT);
    procedure Setcondutores(value:tcondutores_tpInfRetornoConsultaResumoOT);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataHora: string read FdataHora write FdataHora; //Data e hora do retorno das informações
    property ide: tide_tpInfRetornoConsultaResumoOT read Fide; // write Fide;
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao;
    property avisoTransportador: string read FavisoTransportador write SetavisoTransportador; //Aviso ao transportador disponibilizado pela ANTT ou Administradora de meios de pagamento
    property avisoTransportador_IsSet_:boolean read FavisoTransportador_IsSet_;
    property valores: ttpRetornoValores read Fvalores; // write Fvalores;
    property pedagio: tpedagio_tpInfRetornoConsultaResumoOT read Fpedagio write Setpedagio;
    property pedagio_IsSet_:boolean read Fpedagio_IsSet_;
    property direcionamentosPedagio: ttpResumoDirecionamentosPedagio read FdirecionamentosPedagio write SetdirecionamentosPedagio; //Informações de pedágio para operações de transporte com direcionamento de pedágio.
    property direcionamentosPedagio_IsSet_:boolean read FdirecionamentosPedagio_IsSet_;
    property parcelas: tparcelas_tpInfRetornoConsultaResumoOT read Fparcelas write Setparcelas;
    property parcelas_IsSet_:boolean read Fparcelas_IsSet_;
    property condutores: tcondutores_tpInfRetornoConsultaResumoOT read Fcondutores write Setcondutores;
    property condutores_IsSet_:boolean read Fcondutores_IsSet_;
  end;

const
  sntpRetornoConsultaResumoOT = 'tpRetornoConsultaResumoOT';
  sntpRetornoConsultaResumoOT_mensagens = 'mensagens';
  sntpRetornoConsultaResumoOT_envioConsultaResumoOT = 'envioConsultaResumoOT';
  sntpRetornoConsultaResumoOT_retConsultaResumoOT = 'retConsultaResumoOT';

type
  ttpRetornoConsultaResumoOT = class( tBaseNddWS ) // Retorno da consulta do resumo da operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens_tpRetornoConsultaResumoOT; // (E)
    Fmensagens_IsSet_: boolean;
    FenvioConsultaResumoOT: ttpInfConsultaResumoOT; // (E)
    FenvioConsultaResumoOT_IsSet_: boolean;
    FretConsultaResumoOT: ttpInfRetornoConsultaResumoOT; // (E)
    FretConsultaResumoOT_IsSet_: boolean;
    procedure Setmensagens(value:tmensagens_tpRetornoConsultaResumoOT);
    procedure SetenvioConsultaResumoOT(value:ttpInfConsultaResumoOT);
    procedure SetretConsultaResumoOT(value:ttpInfRetornoConsultaResumoOT);
  public
    class function CreateFromXmlString( s: string): ttpRetornoConsultaResumoOT;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpRetornoConsultaResumoOT read Fmensagens write Setmensagens;
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property envioConsultaResumoOT: ttpInfConsultaResumoOT read FenvioConsultaResumoOT write SetenvioConsultaResumoOT; //Informações do envio da consulta de resumo da operação de transporte.
    property envioConsultaResumoOT_IsSet_:boolean read FenvioConsultaResumoOT_IsSet_;
    property retConsultaResumoOT: ttpInfRetornoConsultaResumoOT read FretConsultaResumoOT write SetretConsultaResumoOT;
    property retConsultaResumoOT_IsSet_:boolean read FretConsultaResumoOT_IsSet_;
  end;

const
  snpraca = 'praca';
  snpraca_nome = 'nome';
  snpraca_valor = 'valor';
  snpraca_localizacao = 'localizacao';

type
  tpraca = class( tBaseNddWS ) // Praça de pedágio.
  private
    F_NameSpaceAlias: string;
    Fnome: string; // (E)
    Fvalor: string; // (E)
    Flocalizacao: string; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property nome: string read Fnome write Fnome; //Nome da praça.
    property valor: string read Fvalor write Fvalor; //Valor da específico da praça de pedágio.
    property localizacao: string read Flocalizacao write Flocalizacao; //Localização da praça de pedágio.
  end;

const
  snpracas = 'pracas';
  snpracas_praca = 'praca';

type
  tpracas = class( tBaseNddWS ) // Informações das praças de pedágio.
  private
    F_NameSpaceAlias: string;
    Fpraca: tManagedStringList; // of tpraca(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property praca: tManagedStringList read Fpraca write Fpraca; // of tpraca
  end;

const
  sndirecionamento = 'direcionamento';
  sndirecionamento_pedagioERP = 'pedagioERP';
  sndirecionamento_cpf = 'cpf';
  sndirecionamento_rotaERP = 'rotaERP';
  sndirecionamento_valor = 'valor';
  sndirecionamento_origem = 'origem';
  sndirecionamento_destino = 'destino';
  sndirecionamento_pracas = 'pracas';
  sndirecionamento_status = 'status';
  sndirecionamento_categoriaPedagio = 'categoriaPedagio';

type
  tdirecionamento = class( tBaseNddWS ) // Informações do direcionamento de pedágio.
  private
    F_NameSpaceAlias: string;
    FpedagioERP: string; // (E)
    Fcpf: string; // (E)
    FrotaERP: string; // (E)
    Fvalor: string; // (E)
    Forigem: string; // (E)
    Fdestino: string; // (E)
    Fpracas: tpracas; // (E)
    Fpracas_IsSet_: boolean;
    Fstatus: tbyte; // (E)
    FcategoriaPedagio: integer; // (E)
    procedure Setpracas(value:tpracas);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property pedagioERP: string read FpedagioERP write FpedagioERP; //Identificador do direcionamento de pedágio.
    property cpf: string read Fcpf write Fcpf; //Número do CPF do condutor.
    property rotaERP: string read FrotaERP write FrotaERP; //Nome da rota no ERP utilizado no direcionamento.
    property valor: string read Fvalor write Fvalor; //Valor total do pedágio direcionado.
    property origem: string read Forigem write Forigem; //Cidade e estado de origem.
    property destino: string read Fdestino write Fdestino; //Cidade e estado de destino.
    property pracas: tpracas read Fpracas write Setpracas;
    property pracas_IsSet_:boolean read Fpracas_IsSet_;
    property status: tbyte read Fstatus write Fstatus; //Status do pagamento do pedágio.
    property categoriaPedagio: integer read FcategoriaPedagio write FcategoriaPedagio; //Categoria do pedágio utilizada no direcionamento.
  end;

const
  sntpDirecionamentosPedagio = 'tpDirecionamentosPedagio';
  sntpDirecionamentosPedagio_direcionamento = 'direcionamento';

type
  ttpDirecionamentosPedagio = class( tBaseNddWS ) // Informações para direcionamento de pedágio.
  private
    F_NameSpaceAlias: string;
    Fdirecionamento: tManagedStringList; // of tdirecionamento(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property direcionamento: tManagedStringList read Fdirecionamento write Fdirecionamento; // of tdirecionamento
  end;

const
  sntpRetornoConsultaAlteracao = 'tpRetornoConsultaAlteracao';
  sntpRetornoConsultaAlteracao_dataHora = 'dataHora';
  sntpRetornoConsultaAlteracao_autorizacao = 'autorizacao';
  sntpRetornoConsultaAlteracao_ide = 'ide';
  sntpRetornoConsultaAlteracao_valores = 'valores';
  sntpRetornoConsultaAlteracao_pedagio = 'pedagio';
  sntpRetornoConsultaAlteracao_direcionamentosPedagio = 'direcionamentosPedagio';

type
  ttpRetornoConsultaAlteracao = class( tBaseNddWS ) // Dados de retorno da alteração.
  private
    F_NameSpaceAlias: string;
    FdataHora: string; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    Fide: ttpRetornoIdentificacao; // (E)
    Fvalores: ttpRetornoValores; // (E)
    Fpedagio: ttpRetornoPedagio; // (E)
    Fpedagio_IsSet_: boolean;
    FdirecionamentosPedagio: ttpDirecionamentosPedagio; // (E)
    FdirecionamentosPedagio_IsSet_: boolean;
    procedure Setpedagio(value:ttpRetornoPedagio);
    procedure SetdirecionamentosPedagio(value:ttpDirecionamentosPedagio);
  public
    class function CreateFromXmlString( s: string): ttpRetornoConsultaAlteracao;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property dataHora: string read FdataHora write FdataHora; //Data e hora da alteração.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao; // write Fautorizacao; //Identificação da operação de transporte.
    property ide: ttpRetornoIdentificacao read Fide; // write Fide; //Dados para identificação da operação de transporte.
    property valores: ttpRetornoValores read Fvalores; // write Fvalores; //Valores refetente a operação de transporte.
    property pedagio: ttpRetornoPedagio read Fpedagio write Setpedagio; //Informações de pedágio para operação de transporte sem redirecionamento de pedágio.
    property pedagio_IsSet_:boolean read Fpedagio_IsSet_;
    property direcionamentosPedagio: ttpDirecionamentosPedagio read FdirecionamentosPedagio write SetdirecionamentosPedagio; //Informações de pedágio para operações de transporte com direcionamento de pedágio.
    property direcionamentosPedagio_IsSet_:boolean read FdirecionamentosPedagio_IsSet_;
  end;

const
  sntpRetornoAlteracao = 'tpRetornoAlteracao';
  sntpRetornoAlteracao_mensagens = 'mensagens';
  sntpRetornoAlteracao_alteracao = 'alteracao';

type
  ttpRetornoAlteracao = class( tBaseNddWS ) // Retorno da alteração de operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: tmensagens; // (E)
    Fmensagens_IsSet_: boolean;
    Falteracao: ttpRetornoConsultaAlteracao; // (E)
    Falteracao_IsSet_: boolean;
    procedure Setmensagens(value:tmensagens);
    procedure Setalteracao(value:ttpRetornoConsultaAlteracao);
  public
    class function CreateFromXmlString( s: string): ttpRetornoAlteracao;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens read Fmensagens write Setmensagens;
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property alteracao: ttpRetornoConsultaAlteracao read Falteracao write Setalteracao;
    property alteracao_IsSet_:boolean read Falteracao_IsSet_;
  end;

const
  sninfOT_tpRetornoOT = 'infOT';
  sninfOT_tpRetornoOT_mensagem = 'mensagem';
  sninfOT_tpRetornoOT_dataHora = 'dataHora';
  sninfOT_tpRetornoOT_ide = 'ide';
  sninfOT_tpRetornoOT_autorizacao = 'autorizacao';
  sninfOT_tpRetornoOT_avisoTransportador = 'avisoTransportador';
  sninfOT_tpRetornoOT_valores = 'valores';
  sninfOT_tpRetornoOT_pedagio = 'pedagio';
  sninfOT_tpRetornoOT_direcionamentosPedagio = 'direcionamentosPedagio';
  sninfOT_tpRetornoOT_mensagems = 'mensagens';

type
  tinfOT_tpRetornoOT = class( tBaseNddWS ) // Informações sobre a operação de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagem: ttpMensagem; // (E)
    FdataHora: string; // (E)
    Fide: ttpRetornoIdentificacao; // (E)
    Fautorizacao: ttpAutorizacaoOT; // (E)
    Fautorizacao_IsSet_: boolean;
    FavisoTransportador: string; // (E)
    FavisoTransportador_IsSet_: boolean;
    Fvalores: ttpRetornoValores; // (E)
    Fvalores_IsSet_: boolean;
    Fpedagio: tpedagio; // (E)
    Fpedagio_IsSet_: boolean;
    FdirecionamentosPedagio: ttpDirecionamentosPedagio; // (E)
    FdirecionamentosPedagio_IsSet_: boolean;
    Fmensagems: tmensagens_tpRetornoConsultaANTT;
    procedure Setautorizacao(value:ttpAutorizacaoOT);
    procedure SetavisoTransportador(value:string);
    procedure Setvalores(value:ttpRetornoValores);
    procedure Setpedagio(value:tpedagio);
    procedure SetdirecionamentosPedagio(value:ttpDirecionamentosPedagio);
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: tmensagens_tpRetornoConsultaANTT read Fmensagems; // write Fmensagems; //Mensagems de retorno
    property mensagem: ttpMensagem read Fmensagem; // write Fmensagem; //Mensagem de retorno
    property dataHora: string read FdataHora write FdataHora; //Data e hora do retorno das informações
    property ide: ttpRetornoIdentificacao read Fide; // write Fide; //Dados para identificação da operação de transporte.
    property autorizacao: ttpAutorizacaoOT read Fautorizacao write Setautorizacao; //Dados de autorização para a operação de transporte.
    property autorizacao_IsSet_:boolean read Fautorizacao_IsSet_;
    property avisoTransportador: string read FavisoTransportador write SetavisoTransportador; //Aviso ao transportador disponibilizado pela ANTT ou Administradora de meios de pagamento
    property avisoTransportador_IsSet_:boolean read FavisoTransportador_IsSet_;
    property valores: ttpRetornoValores read Fvalores write Setvalores; //Valores refetente a operação de transporte.
    property valores_IsSet_:boolean read Fvalores_IsSet_;
    property pedagio: tpedagio read Fpedagio write Setpedagio;
    property pedagio_IsSet_:boolean read Fpedagio_IsSet_;
    property direcionamentosPedagio: ttpDirecionamentosPedagio read FdirecionamentosPedagio write SetdirecionamentosPedagio; //Dados de pedágio para operações de transporte com direcionamento de pedágio.
    property direcionamentosPedagio_IsSet_:boolean read FdirecionamentosPedagio_IsSet_;
  end;

const
  sntpRetornoOT = 'tpRetornoOT';
  sntpRetornoOT_infOT = 'infOT';

type
  ttpRetornoOT = class( tBaseNddWS ) // Retorno da operação de transporte.
  private
    F_NameSpaceAlias: string;
    FinfOT: tinfOT_tpRetornoOT; // (E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property infOT: tinfOT_tpRetornoOT read FinfOT; // write FinfOT;
  end;

const
  snoperacoes_tpRetornoConsultaLoteOT = 'operacoes';
  snoperacoes_tpRetornoConsultaLoteOT_OT = 'OT';

type
  toperacoes_tpRetornoConsultaLoteOT = class( tBaseNddWS )
  private
    F_NameSpaceAlias: string;
    FOT: tManagedStringList; // of ttpRetornoOT(E)
  public
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property OT: tManagedStringList read FOT write FOT; // of ttpRetornoOT
  end;

const
  sntpRetornoConsultaLoteOT = 'tpRetornoConsultaLoteOT';
  sntpRetornoConsultaLoteOT_mensagens = 'mensagens';
  sntpRetornoConsultaLoteOT_operacoes = 'operacoes';

type
  ttpRetornoConsultaLoteOT = class( tBaseNddWS ) // Retorno da consulta de lote de operações de transporte.
  private
    F_NameSpaceAlias: string;
    Fmensagens: ttpMensagemErro; // (E)
    Fmensagens_IsSet_: boolean;
    Foperacoes: toperacoes_tpRetornoConsultaLoteOT; // (E)
    Foperacoes_IsSet_: boolean;
    procedure Setmensagens(value:ttpMensagemErro);
    procedure Setoperacoes(value:toperacoes_tpRetornoConsultaLoteOT);
  public
    class function CreateFromXmlString( s: string): ttpRetornoConsultaLoteOT;
    constructor Create; overload;
    constructor Create(aRoot:tJanXMLNode2); overload;
    destructor Destroy; override;
    function GetAsString: string;
    class function _nsURI_:string;
    procedure Save(aNode:tJanXMLNode2);
    property _NameSpaceAlias: string read F_NameSpaceAlias write F_NameSpaceAlias;
    property mensagens: ttpMensagemErro read Fmensagens write Setmensagens; //Lista das mensagens de erro.
    property mensagens_IsSet_:boolean read Fmensagens_IsSet_;
    property operacoes: toperacoes_tpRetornoConsultaLoteOT read Foperacoes write Setoperacoes;
    property operacoes_IsSet_:boolean read Foperacoes_IsSet_;
  end;

type
  tpagamentoOT_envio = class(ttpConsultaPgtos) //Consulta dos pagamentos realizados para as operações de transporte.
  end;
  tconsultarStatusOT_envio = class(ttpConsultaResumoOT)
  end;
  tpagamentoImediatoOT_envio = class(ttpPagamentoImediatoOT)
  end;

implementation
uses
  Windows,
  SysUtils,
  mylib;


const
  thisNamespaceURI = 'http://www.nddigital.com.br/nddcargo';
  defNamespaceAlias = '';

var
   tBaseNddWS_class_var_Refs : TStringList;
   CritSect : TRTLCriticalSection;

{ tveiculo_veiculosTransportador }

function tveiculo_veiculosTransportador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculo_veiculosTransportador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculo_veiculosTransportador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tveiculo_veiculosTransportador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculo_veiculosTransportador_placa) then
      placa :=  xn.text // string
    else if (sn = snveiculo_veiculosTransportador_situacao) then
      situacao :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculo_veiculosTransportador.Destroy;
begin
  inherited;
end; // destructor ...

procedure tveiculo_veiculosTransportador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculo_veiculosTransportador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculo_veiculosTransportador_placa));
  xn.text := Fplaca;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculo_veiculosTransportador_situacao));
  xn.text := Fsituacao;
end; // procedure save

{ tveiculosTransportador }

function tveiculosTransportador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculosTransportador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculosTransportador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fveiculo := tManagedStringlist.Create;
end; // constructor ...

constructor tveiculosTransportador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aveiculo: tveiculo;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculosTransportador_veiculo)
      and ((thisURI='') or (tveiculo._nsURI_ = thisURI)) then
    begin
      aveiculo := tveiculo.Create(xn);
      Fveiculo.AddObject('?', aveiculo);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculosTransportador.Destroy;
begin
  Fveiculo.Free;
  inherited;
end; // destructor ...

procedure tveiculosTransportador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculosTransportador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "veiculo" is tManagedStringlist
  if Assigned(Fveiculo) then
    for i:=0 to Fveiculo.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculosTransportador_veiculo));
      tveiculo_veiculosTransportador(Fveiculo.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tsituacaoTransportador }

function tsituacaoTransportador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tsituacaoTransportador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tsituacaoTransportador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tsituacaoTransportador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snsituacaoTransportador_dataValidadeRNTRC) then
      dataValidadeRNTRC :=  xn.text // string
    else if (sn = snsituacaoTransportador_categoria) then
      categoria :=  xn.text // string
    else if (sn = snsituacaoTransportador_equiparado) then
      equiparado :=  xn.text // tbyte
    else if (sn = snsituacaoTransportador_cadastradonddCargo) then
      cadastradonddCargo :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tsituacaoTransportador.Destroy;
begin
  inherited;
end; // destructor ...

procedure tsituacaoTransportador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'situacaoTransportador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsituacaoTransportador_dataValidadeRNTRC));
  xn.text := FdataValidadeRNTRC;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsituacaoTransportador_categoria));
  xn.text := Fcategoria;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsituacaoTransportador_equiparado));
  xn.text := Fequiparado;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsituacaoTransportador_cadastradonddCargo));
  xn.text := FcadastradonddCargo;
end; // procedure save

{ tveiculo_veiculos_tpConsultaANTTVeiculosTransportador }

function tveiculo_veiculos_tpConsultaANTTVeiculosTransportador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculo_veiculos_tpConsultaANTTVeiculosTransportador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculo_veiculos_tpConsultaANTTVeiculosTransportador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tveiculo_veiculos_tpConsultaANTTVeiculosTransportador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculo_veiculos_tpConsultaANTTVeiculosTransportador_placa) then
      placa :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculo_veiculos_tpConsultaANTTVeiculosTransportador.Destroy;
begin
  inherited;
end; // destructor ...

procedure tveiculo_veiculos_tpConsultaANTTVeiculosTransportador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculo_veiculos_tpConsultaANTTVeiculosTransportador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculo_veiculos_tpConsultaANTTVeiculosTransportador_placa));
  xn.text := Fplaca;
end; // procedure save

{ tveiculos_tpConsultaANTTVeiculosTransportador }

function tveiculos_tpConsultaANTTVeiculosTransportador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculos_tpConsultaANTTVeiculosTransportador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculos_tpConsultaANTTVeiculosTransportador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fveiculo := tManagedStringlist.Create;
end; // constructor ...

constructor tveiculos_tpConsultaANTTVeiculosTransportador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aveiculo: tveiculo;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculos_tpConsultaANTTVeiculosTransportador_veiculo)
      and ((thisURI='') or (tveiculo._nsURI_ = thisURI)) then
    begin
      aveiculo := tveiculo.Create(xn);
      Fveiculo.AddObject('?', aveiculo);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculos_tpConsultaANTTVeiculosTransportador.Destroy;
begin
  Fveiculo.Free;
  inherited;
end; // destructor ...

procedure tveiculos_tpConsultaANTTVeiculosTransportador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculos_tpConsultaANTTVeiculosTransportador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "veiculo" is tManagedStringlist
  if Assigned(Fveiculo) then
    for i:=0 to Fveiculo.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculos_tpConsultaANTTVeiculosTransportador_veiculo));
      tveiculo_veiculos_tpConsultaANTTVeiculosTransportador(Fveiculo.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpConsultaANTTVeiculosTransportador }

function ttpConsultaANTTVeiculosTransportador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsultaANTTVeiculosTransportador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsultaANTTVeiculosTransportador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fveiculos := tveiculos_tpConsultaANTTVeiculosTransportador.Create;
end; // constructor ...

constructor ttpConsultaANTTVeiculosTransportador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsultaANTTVeiculosTransportador_RNTRC) then
      RNTRC :=  xn.text // string
    else if (sn = sntpConsultaANTTVeiculosTransportador_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntpConsultaANTTVeiculosTransportador_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpConsultaANTTVeiculosTransportador_veiculos)
      and ((thisURI='') or (tveiculos._nsURI_ = thisURI)) then
      Fveiculos := tveiculos_tpConsultaANTTVeiculosTransportador.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsultaANTTVeiculosTransportador.Destroy;
begin
  Fveiculos.Free;
  inherited;
end; // destructor ...

procedure ttpConsultaANTTVeiculosTransportador.Setcpf(value:string);
begin
  Fcpf := value;
  Fcpf_IsSet_ := value<>'';
end;

procedure ttpConsultaANTTVeiculosTransportador.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := value<>'';
end;

procedure ttpConsultaANTTVeiculosTransportador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpConsultaANTTVeiculosTransportador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaANTTVeiculosTransportador_RNTRC));
  xn.text := FRNTRC;
  if cpf_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaANTTVeiculosTransportador_cpf));
    xn.text := Fcpf;
  end;
  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaANTTVeiculosTransportador_cnpj));
    xn.text := Fcnpj;
  end;
  if Assigned(Fveiculos) then
  begin
    xn := aNode.addChildByName(sntpConsultaANTTVeiculosTransportador_veiculos);
    Fveiculos.Save(xn);
  end;
end; // procedure save

{ ttpConsultaANTTSituacaoTransporador }

function ttpConsultaANTTSituacaoTransporador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsultaANTTSituacaoTransporador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsultaANTTSituacaoTransporador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpConsultaANTTSituacaoTransporador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsultaANTTSituacaoTransporador_RNTRC) then
      RNTRC :=  xn.text // string
    else if (sn = sntpConsultaANTTSituacaoTransporador_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntpConsultaANTTSituacaoTransporador_cnpj) then
      cnpj :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsultaANTTSituacaoTransporador.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpConsultaANTTSituacaoTransporador.Setcpf(value:string);
begin
  Fcpf := value;
  Fcpf_IsSet_ := value<>'';
end;

procedure ttpConsultaANTTSituacaoTransporador.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := value<>'';
end;

procedure ttpConsultaANTTSituacaoTransporador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpConsultaANTTSituacaoTransporador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaANTTSituacaoTransporador_RNTRC));
  xn.text := FRNTRC;
  if cpf_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaANTTSituacaoTransporador_cpf));
    xn.text := Fcpf;
  end;
  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaANTTSituacaoTransporador_cnpj));
    xn.text := Fcnpj;
  end;
end; // procedure save

{ ttpEnvioConsultaANTTDetalhe }

function ttpEnvioConsultaANTTDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpEnvioConsultaANTTDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpEnvioConsultaANTTDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpEnvioConsultaANTTDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpEnvioConsultaANTTDetalhe_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpEnvioConsultaANTTDetalhe_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpEnvioConsultaANTTDetalhe_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpEnvioConsultaANTTDetalhe_situacaoTransportador) then
      situacaoTransportador := ttpConsultaANTTSituacaoTransporador.Create(xn)
    else if (sn = sntpEnvioConsultaANTTDetalhe_veiculosTransportador) then
      veiculosTransportador := ttpConsultaANTTVeiculosTransportador.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpEnvioConsultaANTTDetalhe.Destroy;
begin
  if assigned(FsituacaoTransportador) then  FsituacaoTransportador.free;
  if assigned(FveiculosTransportador) then  FveiculosTransportador.free;
  inherited;
end; // destructor ...

procedure ttpEnvioConsultaANTTDetalhe.SetsituacaoTransportador(value:ttpConsultaANTTSituacaoTransporador);
begin
  FsituacaoTransportador := value;
  FsituacaoTransportador_IsSet_ := true;
end;

procedure ttpEnvioConsultaANTTDetalhe.SetveiculosTransportador(value:ttpConsultaANTTVeiculosTransportador);
begin
  FveiculosTransportador := value;
  FveiculosTransportador_IsSet_ := true;
end;

procedure ttpEnvioConsultaANTTDetalhe.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpEnvioConsultaANTTDetalhe.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := value<>'';
end;

procedure ttpEnvioConsultaANTTDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpEnvioConsultaANTTDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpEnvioConsultaANTTDetalhe_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpEnvioConsultaANTTDetalhe_token] := Ftoken;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnvioConsultaANTTDetalhe_cnpj));
  xn.text := Fcnpj;
  if Assigned(FsituacaoTransportador) then
  begin
    xn := aNode.addChildByName(sntpEnvioConsultaANTTDetalhe_situacaoTransportador);
    FsituacaoTransportador.Save(xn);
  end;
  if Assigned(FveiculosTransportador) then
  begin
    xn := aNode.addChildByName(sntpEnvioConsultaANTTDetalhe_veiculosTransportador);
    FveiculosTransportador.Save(xn);
  end;
end; // procedure save

{ ttpConsultaANTTDetalhe }

function ttpConsultaANTTDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsultaANTTDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsultaANTTDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpConsultaANTTDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsultaANTTDetalhe_situacaoTransportador) then
      situacaoTransportador := ttpConsultaANTTSituacaoTransporador.Create(xn)
    else if (sn = sntpConsultaANTTDetalhe_veiculosTransportador) then
      veiculosTransportador := ttpConsultaANTTVeiculosTransportador.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsultaANTTDetalhe.Destroy;
begin
  if assigned(FsituacaoTransportador) then  FsituacaoTransportador.free;
  if assigned(FveiculosTransportador) then  FveiculosTransportador.free;
  inherited;
end; // destructor ...

procedure ttpConsultaANTTDetalhe.SetsituacaoTransportador(value:ttpConsultaANTTSituacaoTransporador);
begin
  FsituacaoTransportador := value;
  FsituacaoTransportador_IsSet_ := true;
end;

procedure ttpConsultaANTTDetalhe.SetveiculosTransportador(value:ttpConsultaANTTVeiculosTransportador);
begin
  FveiculosTransportador := value;
  FveiculosTransportador_IsSet_ := true;
end;

procedure ttpConsultaANTTDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpConsultaANTTDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FsituacaoTransportador) then
  begin
    xn := aNode.addChildByName(sntpConsultaANTTDetalhe_situacaoTransportador);
    FsituacaoTransportador.Save(xn);
  end;
  if Assigned(FveiculosTransportador) then
  begin
    xn := aNode.addChildByName(sntpConsultaANTTDetalhe_veiculosTransportador);
    FveiculosTransportador.Save(xn);
  end;
end; // procedure save

{ tinfConsultasANTT }

function tinfConsultasANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfConsultasANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfConsultasANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FconsultaANTT := tManagedStringlist.Create;
end; // constructor ...

constructor tinfConsultasANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfConsultasANTT_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sninfConsultasANTT_consultaANTT) then
    begin
      // list of simple type
      consultaANTT.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfConsultasANTT.Destroy;
begin
  FconsultaANTT.Free;
  inherited;
end; // destructor ...

procedure tinfConsultasANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infConsultasANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfConsultasANTT_cnpj));
  xn.text := Fcnpj;
  // element "consultaANTT" is tManagedStringlist
  if Assigned(FconsultaANTT) then
    for i:=0 to FconsultaANTT.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfConsultasANTT_consultaANTT));
      ttpConsultaANTTDetalhe(FconsultaANTT.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpConsultaANTT }

function ttpConsultaANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsultaANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsultaANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfConsultasANTT := tinfConsultasANTT.Create;
end; // constructor ...

constructor ttpConsultaANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpConsultaANTT_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpConsultaANTT_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsultaANTT_infConsultasANTT)
      and ((thisURI='') or (tinfConsultasANTT._nsURI_ = thisURI)) then
      FinfConsultasANTT := tinfConsultasANTT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsultaANTT.Destroy;
begin
  FinfConsultasANTT.Free;
  inherited;
end; // destructor ...

procedure ttpConsultaANTT.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpConsultaANTT.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := value<>'';
end;

procedure ttpConsultaANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpConsultaANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpConsultaANTT_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpConsultaANTT_token] := Ftoken;

  if Assigned(FinfConsultasANTT) then
  begin
    xn := aNode.addChildByName(sntpConsultaANTT_infConsultasANTT);
    FinfConsultasANTT.Save(xn);
  end;
end; // procedure save

{ tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento }

function tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_autorizacao_tpInfRetornoCancelarOperacaoPagamento_numero) then
      numero :=  xn.text // string
    else if (sn = snide_autorizacao_tpInfRetornoCancelarOperacaoPagamento_serie) then
      serie :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_autorizacao_tpInfRetornoCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_autorizacao_tpInfRetornoCancelarOperacaoPagamento_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_autorizacao_tpInfRetornoCancelarOperacaoPagamento_serie));
  xn.text := Fserie;
end; // procedure save

{ tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento }

function tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento_ndopCodVerificador) then
      ndopCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento_ndopCodVerificador));
  xn.text := FndopCodVerificador;
end; // procedure save

{ tautorizacao_tpInfRetornoCancelarOperacaoPagamento }

function tautorizacao_tpInfRetornoCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tautorizacao_tpInfRetornoCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tautorizacao_tpInfRetornoCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tautorizacao_tpInfRetornoCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snautorizacao_tpInfRetornoCancelarOperacaoPagamento_ndop)
      and ((thisURI='') or (tndop._nsURI_ = thisURI)) then
      ndop := tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Create(xn)
    else if (sn = snautorizacao_tpInfRetornoCancelarOperacaoPagamento_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      ide := tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tautorizacao_tpInfRetornoCancelarOperacaoPagamento.Destroy;
begin
  Fndop.Free;
  Fide.Free;
  inherited;
end; // destructor ...

procedure tautorizacao_tpInfRetornoCancelarOperacaoPagamento.Setndop(value:tndop_autorizacao_tpInfRetornoCancelarOperacaoPagamento);
begin
  Fndop := value;
  Fndop_IsSet_ := true;
end;

procedure tautorizacao_tpInfRetornoCancelarOperacaoPagamento.Setide(value:tide_autorizacao_tpInfRetornoCancelarOperacaoPagamento);
begin
  Fide := value;
  Fide_IsSet_ := true;
end;

procedure tautorizacao_tpInfRetornoCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'autorizacao_tpInfRetornoCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fndop) then
  begin
    xn := aNode.addChildByName(snautorizacao_tpInfRetornoCancelarOperacaoPagamento_ndop);
    Fndop.Save(xn);
  end;
  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(snautorizacao_tpInfRetornoCancelarOperacaoPagamento_ide);
    Fide.Save(xn);
  end;
end; // procedure save

{ ttpInfRetornoCancelarOperacaoPagamento }

function ttpInfRetornoCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfRetornoCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfRetornoCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := tautorizacao_tpInfRetornoCancelarOperacaoPagamento.Create;
end; // constructor ...

constructor ttpInfRetornoCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpInfRetornoCancelarOperacaoPagamento_ID then
      ID := aRoot.attribute[i]; // string
    if sn = antpInfRetornoCancelarOperacaoPagamento_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfRetornoCancelarOperacaoPagamento_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpInfRetornoCancelarOperacaoPagamento_autorizacao)
      and ((thisURI='') or (tautorizacao._nsURI_ = thisURI)) then
      Fautorizacao := tautorizacao_tpInfRetornoCancelarOperacaoPagamento.Create(xn)
    else if (sn = sntpInfRetornoCancelarOperacaoPagamento_motivoCancelamento) then
      motivoCancelamento :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfRetornoCancelarOperacaoPagamento.Destroy;
begin
  Fautorizacao.Free;
  inherited;
end; // destructor ...

procedure ttpInfRetornoCancelarOperacaoPagamento.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := value<>'';
end;

procedure ttpInfRetornoCancelarOperacaoPagamento.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := value<>'';
end;

procedure ttpInfRetornoCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfRetornoCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpInfRetornoCancelarOperacaoPagamento_ID] := FID;
  if token_IsSet_ then
    aNode.attribute[antpInfRetornoCancelarOperacaoPagamento_token] := Ftoken;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfRetornoCancelarOperacaoPagamento_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoCancelarOperacaoPagamento_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfRetornoCancelarOperacaoPagamento_motivoCancelamento));
  xn.text := FmotivoCancelamento;
end; // procedure save

{ tide_autorizacao_tpInfCancelarOperacaoPagamento }

function tide_autorizacao_tpInfCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_autorizacao_tpInfCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_autorizacao_tpInfCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_autorizacao_tpInfCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_autorizacao_tpInfCancelarOperacaoPagamento_numero) then
      numero :=  xn.text // string
    else if (sn = snide_autorizacao_tpInfCancelarOperacaoPagamento_serie) then
      serie :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_autorizacao_tpInfCancelarOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide_autorizacao_tpInfCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_autorizacao_tpInfCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_autorizacao_tpInfCancelarOperacaoPagamento_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_autorizacao_tpInfCancelarOperacaoPagamento_serie));
  xn.text := Fserie;
end; // procedure save

{ tndop_autorizacao_tpInfCancelarOperacaoPagamento }

function tndop_autorizacao_tpInfCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndop_autorizacao_tpInfCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndop_autorizacao_tpInfCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndop_autorizacao_tpInfCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndop_autorizacao_tpInfCancelarOperacaoPagamento_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snndop_autorizacao_tpInfCancelarOperacaoPagamento_ndopCodVerificador) then
      ndopCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndop_autorizacao_tpInfCancelarOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndop_autorizacao_tpInfCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndop_autorizacao_tpInfCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpInfCancelarOperacaoPagamento_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpInfCancelarOperacaoPagamento_ndopCodVerificador));
  xn.text := FndopCodVerificador;
end; // procedure save

{ tautorizacao_tpInfCancelarOperacaoPagamento }

function tautorizacao_tpInfCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tautorizacao_tpInfCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tautorizacao_tpInfCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tautorizacao_tpInfCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snautorizacao_tpInfCancelarOperacaoPagamento_ndop)
      and ((thisURI='') or (tndop._nsURI_ = thisURI)) then
      ndop := tndop_autorizacao_tpInfCancelarOperacaoPagamento.Create(xn)
    else if (sn = snautorizacao_tpInfCancelarOperacaoPagamento_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      ide := tide_autorizacao_tpInfCancelarOperacaoPagamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tautorizacao_tpInfCancelarOperacaoPagamento.Destroy;
begin
  Fndop.Free;
  Fide.Free;
  inherited;
end; // destructor ...

procedure tautorizacao_tpInfCancelarOperacaoPagamento.Setndop(value:tndop_autorizacao_tpInfCancelarOperacaoPagamento);
begin
  Fndop := value;
  Fndop_IsSet_ := true;
end;

procedure tautorizacao_tpInfCancelarOperacaoPagamento.Setide(value:tide_autorizacao_tpInfCancelarOperacaoPagamento);
begin
  Fide := value;
  Fide_IsSet_ := true;
end;

procedure tautorizacao_tpInfCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'autorizacao_tpInfCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fndop) then
  begin
    xn := aNode.addChildByName(snautorizacao_tpInfCancelarOperacaoPagamento_ndop);
    Fndop.Save(xn);
  end;
  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(snautorizacao_tpInfCancelarOperacaoPagamento_ide);
    Fide.Save(xn);
  end;
end; // procedure save

{ ttpInfCancelarOperacaoPagamento }

function ttpInfCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := tautorizacao_tpInfCancelarOperacaoPagamento.Create;
end; // constructor ...

constructor ttpInfCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpInfCancelarOperacaoPagamento_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfCancelarOperacaoPagamento_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpInfCancelarOperacaoPagamento_autorizacao)
      and ((thisURI='') or (tautorizacao._nsURI_ = thisURI)) then
      Fautorizacao := tautorizacao_tpInfCancelarOperacaoPagamento.Create(xn)
    else if (sn = sntpInfCancelarOperacaoPagamento_motivoCancelamento) then
      motivoCancelamento :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfCancelarOperacaoPagamento.Destroy;
begin
  Fautorizacao.Free;
  inherited;
end; // destructor ...

procedure ttpInfCancelarOperacaoPagamento.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := value<>'';
end;

procedure ttpInfCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpInfCancelarOperacaoPagamento_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfCancelarOperacaoPagamento_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpInfCancelarOperacaoPagamento_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfCancelarOperacaoPagamento_motivoCancelamento));
  xn.text := FmotivoCancelamento;
end; // procedure save

{ ttpCancelarOperacaoPagamento }

function ttpCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfCancelarOperacaoPagamento := ttpInfCancelarOperacaoPagamento.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor ttpCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpCancelarOperacaoPagamento_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpCancelarOperacaoPagamento_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCancelarOperacaoPagamento_infCancelarOperacaoPagamento) then
      FinfCancelarOperacaoPagamento := ttpInfCancelarOperacaoPagamento.Create(xn)
    else if (sn = sntpCancelarOperacaoPagamento_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCancelarOperacaoPagamento.Destroy;
begin
  if assigned(FinfCancelarOperacaoPagamento) then  FinfCancelarOperacaoPagamento.free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpCancelarOperacaoPagamento.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpCancelarOperacaoPagamento.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := value<>'';
end;

procedure ttpCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpCancelarOperacaoPagamento_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpCancelarOperacaoPagamento_token] := Ftoken;

  if Assigned(FinfCancelarOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(sntpCancelarOperacaoPagamento_infCancelarOperacaoPagamento);
    FinfCancelarOperacaoPagamento.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpCancelarOperacaoPagamento_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ tsaldo_tpRetornoOperacaoPagamentoDetalhe }

function tsaldo_tpRetornoOperacaoPagamentoDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tsaldo_tpRetornoOperacaoPagamentoDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tsaldo_tpRetornoOperacaoPagamentoDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tsaldo_tpRetornoOperacaoPagamentoDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snsaldo_tpRetornoOperacaoPagamentoDetalhe_saldoDisponivel) then
      saldoDisponivel :=  xn.text // string
    else if (sn = snsaldo_tpRetornoOperacaoPagamentoDetalhe_dataConsulta) then
      dataConsulta :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tsaldo_tpRetornoOperacaoPagamentoDetalhe.Destroy;
begin
  inherited;
end; // destructor ...

procedure tsaldo_tpRetornoOperacaoPagamentoDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'saldo_tpRetornoOperacaoPagamentoDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsaldo_tpRetornoOperacaoPagamentoDetalhe_saldoDisponivel));
  xn.text := FsaldoDisponivel;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsaldo_tpRetornoOperacaoPagamentoDetalhe_dataConsulta));
  xn.text := FdataConsulta;
end; // procedure save

{ tpedagio_tpRetornoOperacaoPagamentoDetalhe }

function tpedagio_tpRetornoOperacaoPagamentoDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpedagio_tpRetornoOperacaoPagamentoDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpedagio_tpRetornoOperacaoPagamentoDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpedagio_tpRetornoOperacaoPagamentoDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
end; // constructor ...

destructor tpedagio_tpRetornoOperacaoPagamentoDetalhe.Destroy;
begin
  inherited;
end; // destructor ...

procedure tpedagio_tpRetornoOperacaoPagamentoDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pedagio_tpRetornoOperacaoPagamentoDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

end; // procedure save

{ tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe }

function tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe_ndopCodVerificador) then
      ndopCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe_ndopCodVerificador));
  xn.text := FndopCodVerificador;
end; // procedure save

{ tautorizacao_tpRetornoOperacaoPagamentoDetalhe }

function tautorizacao_tpRetornoOperacaoPagamentoDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tautorizacao_tpRetornoOperacaoPagamentoDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tautorizacao_tpRetornoOperacaoPagamentoDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fndop := tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe.Create;
end; // constructor ...

constructor tautorizacao_tpRetornoOperacaoPagamentoDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snautorizacao_tpRetornoOperacaoPagamentoDetalhe_ndop)
      and ((thisURI='') or (tndop._nsURI_ = thisURI)) then
      Fndop := tndop_autorizacao_tpRetornoOperacaoPagamentoDetalhe.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tautorizacao_tpRetornoOperacaoPagamentoDetalhe.Destroy;
begin
  Fndop.Free;
  inherited;
end; // destructor ...

procedure tautorizacao_tpRetornoOperacaoPagamentoDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'autorizacao_tpRetornoOperacaoPagamentoDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fndop) then
  begin
    xn := aNode.addChildByName(snautorizacao_tpRetornoOperacaoPagamentoDetalhe_ndop);
    Fndop.Save(xn);
  end;
end; // procedure save

{ tsaldo_tpDetalheRetornoOperacaoPagamento }

function tsaldo_tpDetalheRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tsaldo_tpDetalheRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tsaldo_tpDetalheRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tsaldo_tpDetalheRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snsaldo_tpDetalheRetornoOperacaoPagamento_saldoDisponivel) then
      saldoDisponivel :=  xn.text // string
    else if (sn = snsaldo_tpDetalheRetornoOperacaoPagamento_dataConsulta) then
      dataConsulta :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tsaldo_tpDetalheRetornoOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tsaldo_tpDetalheRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'saldo_tpDetalheRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsaldo_tpDetalheRetornoOperacaoPagamento_saldoDisponivel));
  xn.text := FsaldoDisponivel;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsaldo_tpDetalheRetornoOperacaoPagamento_dataConsulta));
  xn.text := FdataConsulta;
end; // procedure save

{ tpedagio_tpDetalheRetornoOperacaoPagamento }

function tpedagio_tpDetalheRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpedagio_tpDetalheRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpedagio_tpDetalheRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpedagio_tpDetalheRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
end; // constructor ...

destructor tpedagio_tpDetalheRetornoOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tpedagio_tpDetalheRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pedagio_tpDetalheRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

end; // procedure save

{ tndop_autorizacao_tpDetalheRetornoOperacaoPagamento }

function tndop_autorizacao_tpDetalheRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndop_autorizacao_tpDetalheRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndop_autorizacao_tpDetalheRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndop_autorizacao_tpDetalheRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndop_autorizacao_tpDetalheRetornoOperacaoPagamento_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snndop_autorizacao_tpDetalheRetornoOperacaoPagamento_ndopCodVerificador) then
      ndopCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndop_autorizacao_tpDetalheRetornoOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndop_autorizacao_tpDetalheRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndop_autorizacao_tpDetalheRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpDetalheRetornoOperacaoPagamento_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpDetalheRetornoOperacaoPagamento_ndopCodVerificador));
  xn.text := FndopCodVerificador;
end; // procedure save

{ tautorizacao_tpDetalheRetornoOperacaoPagamento }

function tautorizacao_tpDetalheRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tautorizacao_tpDetalheRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tautorizacao_tpDetalheRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fndop := tndop_autorizacao_tpDetalheRetornoOperacaoPagamento.Create;
end; // constructor ...

constructor tautorizacao_tpDetalheRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snautorizacao_tpDetalheRetornoOperacaoPagamento_ndop)
      and ((thisURI='') or (tndop._nsURI_ = thisURI)) then
      Fndop := tndop_autorizacao_tpDetalheRetornoOperacaoPagamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tautorizacao_tpDetalheRetornoOperacaoPagamento.Destroy;
begin
  Fndop.Free;
  inherited;
end; // destructor ...

procedure tautorizacao_tpDetalheRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'autorizacao_tpDetalheRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fndop) then
  begin
    xn := aNode.addChildByName(snautorizacao_tpDetalheRetornoOperacaoPagamento_ndop);
    Fndop.Save(xn);
  end;
end; // procedure save

{ tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento }

function tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_autorizacao_tpInfRetornoConsultaOperacaoPagamento_numero) then
      numero :=  xn.text // string
    else if (sn = snide_autorizacao_tpInfRetornoConsultaOperacaoPagamento_serie) then
      serie :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_autorizacao_tpInfRetornoConsultaOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_autorizacao_tpInfRetornoConsultaOperacaoPagamento_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_autorizacao_tpInfRetornoConsultaOperacaoPagamento_serie));
  xn.text := Fserie;
end; // procedure save

{ tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento }

function tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento_ndopCodVerificador) then
      ndopCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento_ndopCodVerificador));
  xn.text := FndopCodVerificador;
end; // procedure save

{ tautorizacao_tpInfRetornoConsultaOperacaoPagamento }

function tautorizacao_tpInfRetornoConsultaOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tautorizacao_tpInfRetornoConsultaOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tautorizacao_tpInfRetornoConsultaOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tautorizacao_tpInfRetornoConsultaOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snautorizacao_tpInfRetornoConsultaOperacaoPagamento_ndop)
      and ((thisURI='') or (tndop._nsURI_ = thisURI)) then
      ndop := tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Create(xn)
    else if (sn = snautorizacao_tpInfRetornoConsultaOperacaoPagamento_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      ide := tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tautorizacao_tpInfRetornoConsultaOperacaoPagamento.Destroy;
begin
  Fndop.Free;
  Fide.Free;
  inherited;
end; // destructor ...

procedure tautorizacao_tpInfRetornoConsultaOperacaoPagamento.Setndop(value:tndop_autorizacao_tpInfRetornoConsultaOperacaoPagamento);
begin
  Fndop := value;
  Fndop_IsSet_ := true;
end;

procedure tautorizacao_tpInfRetornoConsultaOperacaoPagamento.Setide(value:tide_autorizacao_tpInfRetornoConsultaOperacaoPagamento);
begin
  Fide := value;
  Fide_IsSet_ := true;
end;

procedure tautorizacao_tpInfRetornoConsultaOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'autorizacao_tpInfRetornoConsultaOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fndop) then
  begin
    xn := aNode.addChildByName(snautorizacao_tpInfRetornoConsultaOperacaoPagamento_ndop);
    Fndop.Save(xn);
  end;
  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(snautorizacao_tpInfRetornoConsultaOperacaoPagamento_ide);
    Fide.Save(xn);
  end;
end; // procedure save

{ ttpInfRetornoConsultaOperacaoPagamento }

function ttpInfRetornoConsultaOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfRetornoConsultaOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfRetornoConsultaOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := tautorizacao_tpInfRetornoConsultaOperacaoPagamento.Create;
end; // constructor ...

constructor ttpInfRetornoConsultaOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpInfRetornoConsultaOperacaoPagamento_ID then
      ID := aRoot.attribute[i]; // string
    if sn = antpInfRetornoConsultaOperacaoPagamento_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfRetornoConsultaOperacaoPagamento_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpInfRetornoConsultaOperacaoPagamento_autorizacao)
      and ((thisURI='') or (tautorizacao._nsURI_ = thisURI)) then
      Fautorizacao := tautorizacao_tpInfRetornoConsultaOperacaoPagamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfRetornoConsultaOperacaoPagamento.Destroy;
begin
  Fautorizacao.Free;
  inherited;
end; // destructor ...

procedure ttpInfRetornoConsultaOperacaoPagamento.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := value<>'';
end;

procedure ttpInfRetornoConsultaOperacaoPagamento.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := value<>'';
end;

procedure ttpInfRetornoConsultaOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfRetornoConsultaOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpInfRetornoConsultaOperacaoPagamento_ID] := FID;
  if token_IsSet_ then
    aNode.attribute[antpInfRetornoConsultaOperacaoPagamento_token] := Ftoken;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfRetornoConsultaOperacaoPagamento_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoConsultaOperacaoPagamento_autorizacao);
    Fautorizacao.Save(xn);
  end;
end; // procedure save

{ tide_autorizacao }

function tide_autorizacao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_autorizacao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_autorizacao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_autorizacao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_autorizacao_numero) then
      numero :=  xn.text // string
    else if (sn = snide_autorizacao_serie) then
      serie :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_autorizacao.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide_autorizacao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_autorizacao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_autorizacao_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_autorizacao_serie));
  xn.text := Fserie;
end; // procedure save

{ tndop_autorizacao }

function tndop_autorizacao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndop_autorizacao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndop_autorizacao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndop_autorizacao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndop_autorizacao_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snndop_autorizacao_ndopCodVerificador) then
      ndopCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndop_autorizacao.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndop_autorizacao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndop_autorizacao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_autorizacao_ndopCodVerificador));
  xn.text := FndopCodVerificador;
end; // procedure save

{ tautorizacao }

function tautorizacao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tautorizacao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tautorizacao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tautorizacao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snautorizacao_ndop)
      and ((thisURI='') or (tndop._nsURI_ = thisURI)) then
      ndop := tndop_autorizacao.Create(xn)
    else if (sn = snautorizacao_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      ide := tide_autorizacao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tautorizacao.Destroy;
begin
  Fndop.Free;
  Fide.Free;
  inherited;
end; // destructor ...

procedure tautorizacao.Setndop(value:tndop_autorizacao);
begin
  Fndop := value;
  Fndop_IsSet_ := true;
end;

procedure tautorizacao.Setide(value:tide_autorizacao);
begin
  Fide := value;
  Fide_IsSet_ := true;
end;

procedure tautorizacao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'autorizacao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fndop) then
  begin
    xn := aNode.addChildByName(snautorizacao_ndop);
    Fndop.Save(xn);
  end;
  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(snautorizacao_ide);
    Fide.Save(xn);
  end;
end; // procedure save

{ ttpInfConsultaOperacaoPagamento }

function ttpInfConsultaOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfConsultaOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfConsultaOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := tautorizacao.Create;
end; // constructor ...

constructor ttpInfConsultaOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpInfConsultaOperacaoPagamento_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfConsultaOperacaoPagamento_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpInfConsultaOperacaoPagamento_autorizacao)
      and ((thisURI='') or (tautorizacao._nsURI_ = thisURI)) then
      Fautorizacao := tautorizacao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfConsultaOperacaoPagamento.Destroy;
begin
  Fautorizacao.Free;
  inherited;
end; // destructor ...

procedure ttpInfConsultaOperacaoPagamento.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure ttpInfConsultaOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfConsultaOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpInfConsultaOperacaoPagamento_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfConsultaOperacaoPagamento_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpInfConsultaOperacaoPagamento_autorizacao);
    Fautorizacao.Save(xn);
  end;
end; // procedure save

{ ttpConsultaOperacaoPagamento }

function ttpConsultaOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsultaOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsultaOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfResumoOperacaoPagamento := ttpInfConsultaOperacaoPagamento.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor ttpConsultaOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpConsultaOperacaoPagamento_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpConsultaOperacaoPagamento_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsultaOperacaoPagamento_infResumoOperacaoPagamento) then
      FinfResumoOperacaoPagamento := ttpInfConsultaOperacaoPagamento.Create(xn)
    else if (sn = sntpConsultaOperacaoPagamento_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsultaOperacaoPagamento.Destroy;
begin
  if assigned(FinfResumoOperacaoPagamento) then  FinfResumoOperacaoPagamento.free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpConsultaOperacaoPagamento.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpConsultaOperacaoPagamento.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpConsultaOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpConsultaOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpConsultaOperacaoPagamento_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpConsultaOperacaoPagamento_token] := Ftoken;

  if Assigned(FinfResumoOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(sntpConsultaOperacaoPagamento_infResumoOperacaoPagamento);
    FinfResumoOperacaoPagamento.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpConsultaOperacaoPagamento_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ tpagamento_tpInfRetornoOperacaoPagamento }

function tpagamento_tpInfRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpagamento_tpInfRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpagamento_tpInfRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpagamento_tpInfRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpagamento_tpInfRetornoOperacaoPagamento_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else if (sn = snpagamento_tpInfRetornoOperacaoPagamento_valor) then
      valor :=  xn.text // string
    else if (sn = snpagamento_tpInfRetornoOperacaoPagamento_valorPedagio) then
      valorPedagio :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpagamento_tpInfRetornoOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tpagamento_tpInfRetornoOperacaoPagamento.Setvalor(value:string);
begin
  Fvalor := value;
  Fvalor_IsSet_ := value<>'';
end;

procedure tpagamento_tpInfRetornoOperacaoPagamento.SetvalorPedagio(value:string);
begin
  FvalorPedagio := value;
  FvalorPedagio_IsSet_ := value<>'';
end;

procedure tpagamento_tpInfRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pagamento_tpInfRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpagamento_tpInfRetornoOperacaoPagamento_gestoraCartao));
  xn.text := FgestoraCartao;
  if valor_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpagamento_tpInfRetornoOperacaoPagamento_valor));
    xn.text := Fvalor;
  end;
  if valorPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpagamento_tpInfRetornoOperacaoPagamento_valorPedagio));
    xn.text := FvalorPedagio;
  end;
end; // procedure save

{ tide_tpInfRetornoOperacaoPagamento }

function tide_tpInfRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_tpInfRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_tpInfRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_tpInfRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_tpInfRetornoOperacaoPagamento_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = snide_tpInfRetornoOperacaoPagamento_ptEmissor) then
      ptEmissor :=  xn.text // string
    else if (sn = snide_tpInfRetornoOperacaoPagamento_numero) then
      numero :=  xn.text // string
    else if (sn = snide_tpInfRetornoOperacaoPagamento_serie) then
      serie :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_tpInfRetornoOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide_tpInfRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_tpInfRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoOperacaoPagamento_cnpj));
  xn.text := Fcnpj;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoOperacaoPagamento_ptEmissor));
  xn.text := FptEmissor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoOperacaoPagamento_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoOperacaoPagamento_serie));
  xn.text := Fserie;
end; // procedure save

{ tpagamento }

function tpagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpagamento_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else if (sn = snpagamento_valor) then
      valor :=  xn.text // string
    else if (sn = snpagamento_valorPedagio) then
      valorPedagio :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tpagamento.Setvalor(value:string);
begin
  Fvalor := value;
  Fvalor_IsSet_ := value<>'';
end;

procedure tpagamento.SetvalorPedagio(value:string);
begin
  FvalorPedagio := value;
  FvalorPedagio_IsSet_ := value<>'';
end;

procedure tpagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpagamento_gestoraCartao));
  xn.text := FgestoraCartao;
  if valor_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpagamento_valor));
    xn.text := Fvalor;
  end;
  if valorPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpagamento_valorPedagio));
    xn.text := FvalorPedagio;
  end;
end; // procedure save

{ tide_tpInfOperacaoPagamento }

function tide_tpInfOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_tpInfOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_tpInfOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_tpInfOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_tpInfOperacaoPagamento_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = snide_tpInfOperacaoPagamento_ptEmissor) then
      ptEmissor :=  xn.text // string
    else if (sn = snide_tpInfOperacaoPagamento_numero) then
      numero :=  xn.text // string
    else if (sn = snide_tpInfOperacaoPagamento_serie) then
      serie :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_tpInfOperacaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide_tpInfOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_tpInfOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfOperacaoPagamento_cnpj));
  xn.text := Fcnpj;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfOperacaoPagamento_ptEmissor));
  xn.text := FptEmissor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfOperacaoPagamento_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfOperacaoPagamento_serie));
  xn.text := Fserie;
end; // procedure save

{ tsaldo }

function tsaldo.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tsaldo._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tsaldo.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tsaldo.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snsaldo_saldoPedagioDisponivel) then
      saldoPedagioDisponivel :=  xn.text // string
    else if (sn = snsaldo_saldoDisponivel) then
      saldoDisponivel :=  xn.text // string
    else if (sn = snsaldo_dataConsulta) then
      dataConsulta :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tsaldo.Destroy;
begin
  inherited;
end; // destructor ...

procedure tsaldo.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'saldo')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsaldo_saldoPedagioDisponivel));
  xn.text := FsaldoPedagioDisponivel;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsaldo_saldoDisponivel));
  xn.text := FsaldoDisponivel;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snsaldo_dataConsulta));
  xn.text := FdataConsulta;
end; // procedure save

{ ttpInfConsultaSaldoCartaoFrota }

function ttpInfConsultaSaldoCartaoFrota.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfConsultaSaldoCartaoFrota._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfConsultaSaldoCartaoFrota.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpInfConsultaSaldoCartaoFrota.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfConsultaSaldoCartaoFrota_cpfColaborador) then
      cpfColaborador :=  xn.text // string
    else if (sn = sntpInfConsultaSaldoCartaoFrota_cartaoId) then
      cartaoId := StrToInt64Def(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfConsultaSaldoCartaoFrota.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpInfConsultaSaldoCartaoFrota.SetcpfColaborador(value:string);
begin
  FcpfColaborador := value;
  FcpfColaborador_IsSet_ := value<>'';
end;

procedure ttpInfConsultaSaldoCartaoFrota.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfConsultaSaldoCartaoFrota')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if cpfColaborador_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfConsultaSaldoCartaoFrota_cpfColaborador));
    xn.text := FcpfColaborador;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfConsultaSaldoCartaoFrota_cartaoId));
  xn.text := IntToStr(FcartaoId);
end; // procedure save

{ tinfLote_envioConsulta }

function tinfLote_envioConsulta.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfLote_envioConsulta._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfLote_envioConsulta.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fide := tManagedStringlist.Create;
end; // constructor ...

constructor tinfLote_envioConsulta.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = aninfLote_envioConsulta_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = aninfLote_envioConsulta_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfLote_envioConsulta_cnpjContratante) then
      cnpjContratante :=  xn.text // string
    else if (sn = sninfLote_envioConsulta_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else if (sn = sninfLote_envioConsulta_ide) then
    begin
      // list of simple type
      Fide.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfLote_envioConsulta.Destroy;
begin
  Fide.Free;
  inherited;
end; // destructor ...

procedure tinfLote_envioConsulta.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure tinfLote_envioConsulta.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure tinfLote_envioConsulta.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infLote_envioConsulta')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[aninfLote_envioConsulta_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[aninfLote_envioConsulta_token] := Ftoken;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfLote_envioConsulta_cnpjContratante));
  xn.text := FcnpjContratante;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfLote_envioConsulta_gestoraCartao));
  xn.text := FgestoraCartao;
  // element "ide" is tManagedStringlist
  if Assigned(Fide) then
    for i:=0 to Fide.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfLote_envioConsulta_ide));
      ttpInfConsultaSaldoCartaoFrota(Fide.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tenvioConsulta }

function tenvioConsulta.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tenvioConsulta._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tenvioConsulta.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfLote := tinfLote_envioConsulta.Create;
end; // constructor ...

constructor tenvioConsulta.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snenvioConsulta_infLote)
      and ((thisURI='') or (tinfLote._nsURI_ = thisURI)) then
      FinfLote := tinfLote_envioConsulta.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tenvioConsulta.Destroy;
begin
  FinfLote.Free;
  inherited;
end; // destructor ...

procedure tenvioConsulta.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'envioConsulta')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FinfLote) then
  begin
    xn := aNode.addChildByName(snenvioConsulta_infLote);
    FinfLote.Save(xn);
  end;
end; // procedure save

{ tinfLote }

function tinfLote.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfLote._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfLote.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fide := tManagedStringlist.Create;
end; // constructor ...

constructor tinfLote.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = aninfLote_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfLote_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sninfLote_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else if (sn = sninfLote_ide) then
    begin
      // list of simple type
      Fide.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfLote.Destroy;
begin
  Fide.Free;
  inherited;
end; // destructor ...

procedure tinfLote.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure tinfLote.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infLote')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[aninfLote_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfLote_cnpj));
  xn.text := Fcnpj;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfLote_gestoraCartao));
  xn.text := FgestoraCartao;
  // element "ide" is tManagedStringlist
  if Assigned(Fide) then
    for i:=0 to Fide.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfLote_ide));
      ttpInfConsultaSaldoCartaoFrota(Fide.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpConsultaSaldoCartaoFrota }

function ttpConsultaSaldoCartaoFrota.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsultaSaldoCartaoFrota._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsultaSaldoCartaoFrota.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfLote := tinfLote.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor ttpConsultaSaldoCartaoFrota.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpConsultaSaldoCartaoFrota_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpConsultaSaldoCartaoFrota_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsultaSaldoCartaoFrota_infLote)
      and ((thisURI='') or (tinfLote._nsURI_ = thisURI)) then
      FinfLote := tinfLote.Create(xn)
    else if (sn = sntpConsultaSaldoCartaoFrota_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsultaSaldoCartaoFrota.Destroy;
begin
  FinfLote.Free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpConsultaSaldoCartaoFrota.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpConsultaSaldoCartaoFrota.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpConsultaSaldoCartaoFrota.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpConsultaSaldoCartaoFrota')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpConsultaSaldoCartaoFrota_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpConsultaSaldoCartaoFrota_token] := Ftoken;

  if Assigned(FinfLote) then
  begin
    xn := aNode.addChildByName(sntpConsultaSaldoCartaoFrota_infLote);
    FinfLote.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpConsultaSaldoCartaoFrota_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ tcondutor_condutores_tpInfRetornoConsultaResumoOT }

function tcondutor_condutores_tpInfRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcondutor_condutores_tpInfRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcondutor_condutores_tpInfRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tcondutor_condutores_tpInfRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncondutor_condutores_tpInfRetornoConsultaResumoOT_cpf) then
      cpf :=  xn.text // string
    else if (sn = sncondutor_condutores_tpInfRetornoConsultaResumoOT_nome) then
      nome :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcondutor_condutores_tpInfRetornoConsultaResumoOT.Destroy;
begin
  inherited;
end; // destructor ...

procedure tcondutor_condutores_tpInfRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'condutor_condutores_tpInfRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncondutor_condutores_tpInfRetornoConsultaResumoOT_cpf));
  xn.text := Fcpf;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncondutor_condutores_tpInfRetornoConsultaResumoOT_nome));
  xn.text := Fnome;
end; // procedure save

{ tcondutores_tpInfRetornoConsultaResumoOT }

function tcondutores_tpInfRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcondutores_tpInfRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcondutores_tpInfRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fcondutor := tManagedStringlist.Create;
end; // constructor ...

constructor tcondutores_tpInfRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  acondutor: tcondutor;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncondutores_tpInfRetornoConsultaResumoOT_condutor)
      and ((thisURI='') or (tcondutor._nsURI_ = thisURI)) then
    begin
      acondutor := tcondutor.Create(xn);
      Fcondutor.AddObject('?', acondutor);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcondutores_tpInfRetornoConsultaResumoOT.Destroy;
begin
  Fcondutor.Free;
  inherited;
end; // destructor ...

procedure tcondutores_tpInfRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'condutores_tpInfRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "condutor" is tManagedStringlist
  if Assigned(Fcondutor) then
    for i:=0 to Fcondutor.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncondutores_tpInfRetornoConsultaResumoOT_condutor));
      tcondutor_condutores_tpInfRetornoConsultaResumoOT(Fcondutor.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tparcela_parcelas_tpInfRetornoConsultaResumoOT }

function tparcela_parcelas_tpInfRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tparcela_parcelas_tpInfRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tparcela_parcelas_tpInfRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tparcela_parcelas_tpInfRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snparcela_parcelas_tpInfRetornoConsultaResumoOT_nome) then
      nome :=  xn.text // string
    else if (sn = snparcela_parcelas_tpInfRetornoConsultaResumoOT_valorReal) then
      valorReal :=  xn.text // string
    else if (sn = snparcela_parcelas_tpInfRetornoConsultaResumoOT_valorAplicado) then
      valorAplicado :=  xn.text // string
    else if (sn = snparcela_parcelas_tpInfRetornoConsultaResumoOT_dataPrevisao) then
      dataPrevisao :=  xn.text // string
    else if (sn = snparcela_parcelas_tpInfRetornoConsultaResumoOT_dataPagamento) then
      dataPagamento :=  xn.text // string
    else if (sn = snparcela_parcelas_tpInfRetornoConsultaResumoOT_status) then
      status :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tparcela_parcelas_tpInfRetornoConsultaResumoOT.Destroy;
begin
  inherited;
end; // destructor ...

procedure tparcela_parcelas_tpInfRetornoConsultaResumoOT.SetdataPagamento(value:string);
begin
  FdataPagamento := value;
  FdataPagamento_IsSet_ := value<>'';
end;

procedure tparcela_parcelas_tpInfRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'parcela_parcelas_tpInfRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_parcelas_tpInfRetornoConsultaResumoOT_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_parcelas_tpInfRetornoConsultaResumoOT_valorReal));
  xn.text := FvalorReal;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_parcelas_tpInfRetornoConsultaResumoOT_valorAplicado));
  xn.text := FvalorAplicado;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_parcelas_tpInfRetornoConsultaResumoOT_dataPrevisao));
  xn.text := FdataPrevisao;
  if dataPagamento_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_parcelas_tpInfRetornoConsultaResumoOT_dataPagamento));
    xn.text := FdataPagamento;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_parcelas_tpInfRetornoConsultaResumoOT_status));
  xn.text := Fstatus;
end; // procedure save

{ tparcelas_tpInfRetornoConsultaResumoOT }

function tparcelas_tpInfRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tparcelas_tpInfRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tparcelas_tpInfRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fparcela := tManagedStringlist.Create;
end; // constructor ...

constructor tparcelas_tpInfRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aparcela: tparcela_parcelas_tpInfRetornoConsultaResumoOT;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snparcelas_tpInfRetornoConsultaResumoOT_parcela)
      and ((thisURI='') or (tparcela._nsURI_ = thisURI)) then
    begin
      aparcela := tparcela_parcelas_tpInfRetornoConsultaResumoOT.Create(xn);
      Fparcela.AddObject('?', aparcela);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tparcelas_tpInfRetornoConsultaResumoOT.Destroy;
begin
  Fparcela.Free;
  inherited;
end; // destructor ...

procedure tparcelas_tpInfRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'parcelas_tpInfRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "parcela" is tManagedStringlist
  if Assigned(Fparcela) then
    for i:=0 to Fparcela.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcelas_tpInfRetornoConsultaResumoOT_parcela));
      tparcela_parcelas_tpInfRetornoConsultaResumoOT(Fparcela.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tpedagio_tpInfRetornoConsultaResumoOT }

function tpedagio_tpInfRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpedagio_tpInfRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpedagio_tpInfRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpedagio_tpInfRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpedagio_tpInfRetornoConsultaResumoOT_valor) then
      valor :=  xn.text // string
    else if (sn = snpedagio_tpInfRetornoConsultaResumoOT_origem) then
      origem :=  xn.text // string
    else if (sn = snpedagio_tpInfRetornoConsultaResumoOT_destino) then
      destino :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpedagio_tpInfRetornoConsultaResumoOT.Destroy;
begin
  inherited;
end; // destructor ...

procedure tpedagio_tpInfRetornoConsultaResumoOT.Setorigem(value:string);
begin
  Forigem := value;
  Forigem_IsSet_ := true;
end;

procedure tpedagio_tpInfRetornoConsultaResumoOT.Setdestino(value:string);
begin
  Fdestino := value;
  Fdestino_IsSet_ := true;
end;

procedure tpedagio_tpInfRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pedagio_tpInfRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpedagio_tpInfRetornoConsultaResumoOT_valor));
  xn.text := Fvalor;
  if origem_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpedagio_tpInfRetornoConsultaResumoOT_origem));
    xn.text := Forigem;
  end;
  if destino_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpedagio_tpInfRetornoConsultaResumoOT_destino));
    xn.text := Fdestino;
  end;
end; // procedure save

{ tide_tpInfRetornoConsultaResumoOT }

function tide_tpInfRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_tpInfRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_tpInfRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_tpInfRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_tpInfRetornoConsultaResumoOT_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = snide_tpInfRetornoConsultaResumoOT_serie) then
      serie :=  xn.text // string
    else if (sn = snide_tpInfRetornoConsultaResumoOT_numero) then
      numero :=  xn.text // string
    else if (sn = snide_tpInfRetornoConsultaResumoOT_dataEmissao) then
      dataEmissao :=  xn.text // string
    else if (sn = snide_tpInfRetornoConsultaResumoOT_mfParcelas) then
      mfParcelas :=  xn.text // tbyte
    else if (sn = snide_tpInfRetornoConsultaResumoOT_mfPedagio) then
      mfPedagio :=  xn.text // tbyte
    else if (sn = snide_tpInfRetornoConsultaResumoOT_emAlteracao) then
      emAlteracao :=  xn.text // tbyte
    else if (sn = snide_tpInfRetornoConsultaResumoOT_status) then
      status :=  xn.text // tbyte
    else if (sn = snide_tpInfRetornoConsultaResumoOT_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_tpInfRetornoConsultaResumoOT.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide_tpInfRetornoConsultaResumoOT.SetgestoraCartao(value:string);
begin
  FgestoraCartao := value;
  FgestoraCartao_IsSet_ := true;
end;

procedure tide_tpInfRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_tpInfRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_cnpj));
  xn.text := Fcnpj;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_serie));
  xn.text := Fserie;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_dataEmissao));
  xn.text := FdataEmissao;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_mfParcelas));
  xn.text := FmfParcelas;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_mfPedagio));
  xn.text := FmfPedagio;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_emAlteracao));
  xn.text := FemAlteracao;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_status));
  xn.text := Fstatus;
  if gestoraCartao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_tpInfRetornoConsultaResumoOT_gestoraCartao));
    xn.text := FgestoraCartao;
  end;
end; // procedure save

{ tide_OT }

function tide_OT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_OT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_OT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_OT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_OT_serie) then
      serie :=  xn.text // string
    else if (sn = snide_OT_numero) then
      numero :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_OT.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide_OT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_OT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_OT_serie));
  xn.text := Fserie;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_OT_numero));
  xn.text := Fnumero;
end; // procedure save

{ tOT }

function tOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snOT_ciot) then
      ciot := xn.text
    else if (sn = snOT_ndot) then
      ndot := xn.text
    else if (sn = snOT_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      Fide := tide_OT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tOT.Destroy;
begin
  Fide.Free;
  inherited;
end; // destructor ...

procedure tOT.Setciot(value:string);
begin
  Fciot := value;
  Fciot_IsSet_ := true;
end;

procedure tOT.Setndot(value:string);
begin
  Fndot := value;
  Fndot_IsSet_ := true;
end;

procedure tOT.Setide(value:tide_OT);
begin
  Fide := value;
  Fide_IsSet_ := true;
end;

procedure tOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'OT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ciot_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snOT_ciot));
    xn.text := Fciot;
  end;
  if ndot_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snOT_ndot));
    xn.text := Fndot;
  end;
  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(snOT_ide);
    Fide.Save(xn);
  end;
end; // procedure save

{ ttpInfConsultaResumoOT }

function ttpInfConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FOT := tOT.Create;
end; // constructor ...

constructor ttpInfConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpInfConsultaResumoOT_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfConsultaResumoOT_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpInfConsultaResumoOT_OT)
      and ((thisURI='') or (tOT._nsURI_ = thisURI)) then
      FOT := tOT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfConsultaResumoOT.Destroy;
begin
  FOT.Free;
  inherited;
end; // destructor ...

procedure ttpInfConsultaResumoOT.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure ttpInfConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpInfConsultaResumoOT_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfConsultaResumoOT_cnpj));
  xn.text := Fcnpj;
  if Assigned(FOT) then
  begin
    xn := aNode.addChildByName(sntpInfConsultaResumoOT_OT);
    FOT.Save(xn);
  end;
end; // procedure save


{ ttpConsultaResumoOT }

function ttpConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfConsultaResumoOT := tinfConsultaResumoOT.Create;
  //FSignature := tSignature.Create;
end; // constructor ...

constructor ttpConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpConsultaResumoOT_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpConsultaResumoOT_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsultaResumoOT_infConsultaResumoOT)
      and ((thisURI='') or (tinfConsultaResumoOT._nsURI_ = thisURI)) then
      FinfConsultaResumoOT := tinfConsultaResumoOT.Create(xn)
{    else if (sn = sntpConsultaResumoOT_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
}
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsultaResumoOT.Destroy;
begin
  FinfConsultaResumoOT.Free;
  //FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpConsultaResumoOT.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpConsultaResumoOT.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, Copy(Self.ClassName,2,200))
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpConsultaResumoOT_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpConsultaResumoOT_token] := Ftoken;

  if Assigned(FinfConsultaResumoOT) then
  begin
    xn := aNode.addChildByName(sntpConsultaResumoOT_infConsultaResumoOT);
    FinfConsultaResumoOT.Save(xn);
  end;
{
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpConsultaResumoOT_Signature);
    FSignature.Save(xn);
  end;
}
end; // procedure save

{ tintegracoes }

function tintegracoes.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tintegracoes._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tintegracoes.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fintegracao := tManagedStringlist.Create;
end; // constructor ...

constructor tintegracoes.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snintegracoes_integracao) then
    begin
      // list of simple type
      Fintegracao.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tintegracoes.Destroy;
begin
  Fintegracao.Free;
  inherited;
end; // destructor ...

procedure tintegracoes.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'integracoes')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "integracao" is tManagedStringlist
  // but of simple elements
  if Assigned(Fintegracao) then
    for i:=0 to Fintegracao.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snintegracoes_integracao));
      xn.text := Fintegracao.Strings[i];
    end; // for i:=0 to ...
end; // procedure save

{ tconfiguracao }

function tconfiguracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tconfiguracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tconfiguracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tconfiguracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snconfiguracao_urlIntegracao) then
      urlIntegracao :=  xn.text // string
    else if (sn = snconfiguracao_periodicidade) then
      periodicidade := StrToIntDef(xn.text, 0)
    else if (sn = snconfiguracao_intervaloConsultaPagamento) then
      intervaloConsultaPagamento := StrToIntDef(xn.text, 0)
    else if (sn = snconfiguracao_versaoProcessamento) then
      versaoProcessamento :=  xn.text // string
    else if (sn = snconfiguracao_versaoCorrente) then
      versaoCorrente :=  xn.text // string
    else if (sn = snconfiguracao_integracoes)
      and ((thisURI='') or (tintegracoes._nsURI_ = thisURI)) then
      Fintegracoes := tintegracoes.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tconfiguracao.Destroy;
begin
  Fintegracoes.Free;
  inherited;
end; // destructor ...

procedure tconfiguracao.Setintegracoes(value:tintegracoes);
begin
  Fintegracoes := value;
  Fintegracoes_IsSet_ := true;
end;

procedure tconfiguracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'configuracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snconfiguracao_urlIntegracao));
  xn.text := FurlIntegracao;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snconfiguracao_periodicidade));
  xn.text := IntToStr(Fperiodicidade);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snconfiguracao_intervaloConsultaPagamento));
  xn.text := IntToStr(FintervaloConsultaPagamento);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snconfiguracao_versaoProcessamento));
  xn.text := FversaoProcessamento;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snconfiguracao_versaoCorrente));
  xn.text := FversaoCorrente;
  if Assigned(Fintegracoes) then
  begin
    xn := aNode.addChildByName(snconfiguracao_integracoes);
    Fintegracoes.Save(xn);
  end;
end; // procedure save

{ ttpConfiguracao }

function ttpConfiguracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConfiguracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConfiguracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FpontoEmissor := tManagedStringlist.Create;
end; // constructor ...

constructor ttpConfiguracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConfiguracao_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpConfiguracao_pontoEmissor) then
    begin
      // list of simple type
      pontoEmissor.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConfiguracao.Destroy;
begin
  FpontoEmissor.Free;
  inherited;
end; // destructor ...

procedure ttpConfiguracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpConfiguracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConfiguracao_cnpj));
  xn.text := Fcnpj;
  // element "pontoEmissor" is tManagedStringlist
  // but of simple elements
  if Assigned(FpontoEmissor) then
    for i:=0 to FpontoEmissor.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConfiguracao_pontoEmissor));
      xn.text := FpontoEmissor.Strings[i];
    end; // for i:=0 to ...
end; // procedure save

{ ttbPadraoImpressaoCompleto }

function ttbPadraoImpressaoCompleto.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttbPadraoImpressaoCompleto._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttbPadraoImpressaoCompleto.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttbPadraoImpressaoCompleto.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntbPadraoImpressaoCompleto_nomeArquivo) then
      nomeArquivo :=  xn.text // string
    else if (sn = sntbPadraoImpressaoCompleto_nomeImpressora) then
      nomeImpressora :=  xn.text // string
    else if (sn = sntbPadraoImpressaoCompleto_usuarioDocumento) then
      usuarioDocumento :=  xn.text // string
    else if (sn = sntbPadraoImpressaoCompleto_comandosImpressao) then
      comandosImpressao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttbPadraoImpressaoCompleto.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttbPadraoImpressaoCompleto.SetusuarioDocumento(value:string);
begin
  FusuarioDocumento := value;
  FusuarioDocumento_IsSet_ := true;
end;

procedure ttbPadraoImpressaoCompleto.SetcomandosImpressao(value:string);
begin
  FcomandosImpressao := value;
  FcomandosImpressao_IsSet_ := true;
end;

procedure ttbPadraoImpressaoCompleto.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tbPadraoImpressaoCompleto')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntbPadraoImpressaoCompleto_nomeArquivo));
  xn.text := FnomeArquivo;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntbPadraoImpressaoCompleto_nomeImpressora));
  xn.text := FnomeImpressora;
  if usuarioDocumento_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntbPadraoImpressaoCompleto_usuarioDocumento));
    xn.text := FusuarioDocumento;
  end;
  if comandosImpressao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntbPadraoImpressaoCompleto_comandosImpressao));
    xn.text := FcomandosImpressao;
  end;
end; // procedure save

{ timpressao_tpRetornoConfiguracao }

function timpressao_tpRetornoConfiguracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function timpressao_tpRetornoConfiguracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor timpressao_tpRetornoConfiguracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FPadraoImpressao := ttbPadraoImpressaoCompleto.Create;
end; // constructor ...

constructor timpressao_tpRetornoConfiguracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snimpressao_tpRetornoConfiguracao_PontoEmissor) then
      PontoEmissor :=  xn.text // string
    else if (sn = snimpressao_tpRetornoConfiguracao_PadraoImpressao) then
      FPadraoImpressao := ttbPadraoImpressaoCompleto.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor timpressao_tpRetornoConfiguracao.Destroy;
begin
  if assigned(FPadraoImpressao) then  FPadraoImpressao.free;
  inherited;
end; // destructor ...

procedure timpressao_tpRetornoConfiguracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'impressao_tpRetornoConfiguracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snimpressao_tpRetornoConfiguracao_PontoEmissor));
  xn.text := FPontoEmissor;
  if Assigned(FPadraoImpressao) then
  begin
    xn := aNode.addChildByName(snimpressao_tpRetornoConfiguracao_PadraoImpressao);
    FPadraoImpressao.Save(xn);
  end;
end; // procedure save

{ ttpCabecalhoFormularioImpressao }

function ttpCabecalhoFormularioImpressao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCabecalhoFormularioImpressao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCabecalhoFormularioImpressao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FpadraoImpressao := ttbPadraoImpressaoCompleto.Create;
end; // constructor ...

constructor ttpCabecalhoFormularioImpressao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCabecalhoFormularioImpressao_padraoImpressao) then
      FpadraoImpressao := ttbPadraoImpressaoCompleto.Create(xn)
    else if (sn = sntpCabecalhoFormularioImpressao_agruparDOTs) then
      agruparDOTs :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCabecalhoFormularioImpressao.Destroy;
begin
  if assigned(FpadraoImpressao) then  FpadraoImpressao.free;
  inherited;
end; // destructor ...

procedure ttpCabecalhoFormularioImpressao.SetagruparDOTs(value:tbyte);
begin
  FagruparDOTs := value;
  FagruparDOTs_IsSet_ := true;
end;

procedure ttpCabecalhoFormularioImpressao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCabecalhoFormularioImpressao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FpadraoImpressao) then
  begin
    xn := aNode.addChildByName(sntpCabecalhoFormularioImpressao_padraoImpressao);
    FpadraoImpressao.Save(xn);
  end;
  if agruparDOTs_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCabecalhoFormularioImpressao_agruparDOTs));
    xn.text := FagruparDOTs;
  end;
end; // procedure save

{ ttbPadraoImpressao }

function ttbPadraoImpressao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttbPadraoImpressao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttbPadraoImpressao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttbPadraoImpressao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntbPadraoImpressao_nomeImpressora) then
      nomeImpressora :=  xn.text // string
    else if (sn = sntbPadraoImpressao_usuarioDocumento) then
      usuarioDocumento :=  xn.text // string
    else if (sn = sntbPadraoImpressao_comandosImpressao) then
      comandosImpressao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttbPadraoImpressao.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttbPadraoImpressao.SetusuarioDocumento(value:string);
begin
  FusuarioDocumento := value;
  FusuarioDocumento_IsSet_ := true;
end;

procedure ttbPadraoImpressao.SetcomandosImpressao(value:string);
begin
  FcomandosImpressao := value;
  FcomandosImpressao_IsSet_ := true;
end;

procedure ttbPadraoImpressao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tbPadraoImpressao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntbPadraoImpressao_nomeImpressora));
  xn.text := FnomeImpressora;
  if usuarioDocumento_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntbPadraoImpressao_usuarioDocumento));
    xn.text := FusuarioDocumento;
  end;
  if comandosImpressao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntbPadraoImpressao_comandosImpressao));
    xn.text := FcomandosImpressao;
  end;
end; // procedure save

{ ttpPadraoImpressaoDocumentos }

function ttpPadraoImpressaoDocumentos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpPadraoImpressaoDocumentos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpPadraoImpressaoDocumentos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FpontoEmissor := tManagedStringlist.Create;
end; // constructor ...

constructor ttpPadraoImpressaoDocumentos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpPadraoImpressaoDocumentos_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpPadraoImpressaoDocumentos_pontoEmissor) then
    begin
      // list of simple type
      FpontoEmissor.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpPadraoImpressaoDocumentos.Destroy;
begin
  FpontoEmissor.Free;
  inherited;
end; // destructor ...

procedure ttpPadraoImpressaoDocumentos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpPadraoImpressaoDocumentos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpPadraoImpressaoDocumentos_cnpj));
  xn.text := Fcnpj;
  // element "pontoEmissor" is tManagedStringlist
  // but of simple elements
  if Assigned(FpontoEmissor) then
    for i:=0 to FpontoEmissor.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpPadraoImpressaoDocumentos_pontoEmissor));
      xn.text := FpontoEmissor.Strings[i];
    end; // for i:=0 to ...
end; // procedure save

{ tCrossTalk_Header_Response_Type }

function tCrossTalk_Header_Response_Type.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tCrossTalk_Header_Response_Type._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tCrossTalk_Header_Response_Type.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tCrossTalk_Header_Response_Type.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snCrossTalk_Header_Response_Type_ResponseCode) then
      ResponseCode := StrToIntDef(xn.text, 0)
    else if (sn = snCrossTalk_Header_Response_Type_ResponseCodeMessage) then
      ResponseCodeMessage :=  xn.text // string
    else if (sn = snCrossTalk_Header_Response_Type_ProcessCode) then
      ProcessCode := StrToIntDef(xn.text, 0)
    else if (sn = snCrossTalk_Header_Response_Type_MessageType) then
      MessageType := StrToIntDef(xn.text, 0)
    else if (sn = snCrossTalk_Header_Response_Type_ExchangePattern) then
      ExchangePattern :=  xn.text // tbyte
    else if (sn = snCrossTalk_Header_Response_Type_SourceId) then
      SourceId :=  xn.text // tbyte
    else if (sn = snCrossTalk_Header_Response_Type_GUID) then
      GUID :=  xn.text // string
    else if (sn = snCrossTalk_Header_Response_Type_DateTime) then
      DateTime := DateTimeFromXMLDateTime(xn.text) // tDateTime
    else if (sn = snCrossTalk_Header_Response_Type_EnterpriseId) then
      EnterpriseId := StrToInt64Def(xn.text, 0)
    else if (sn = snCrossTalk_Header_Response_Type_Token) then
      Token :=  xn.text // string
    else if (sn = snCrossTalk_Header_Response_Type_ContentType) then
      ContentType :=  xn.text // string
    else if (sn = snCrossTalk_Header_Response_Type_ContentEncoding) then
      ContentEncoding :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tCrossTalk_Header_Response_Type.Destroy;
begin
  inherited;
end; // destructor ...

procedure tCrossTalk_Header_Response_Type.SetResponseCodeMessage(value:string);
begin
  FResponseCodeMessage := value;
  FResponseCodeMessage_IsSet_ := true;
end;

procedure tCrossTalk_Header_Response_Type.SetExchangePattern(value:tbyte);
begin
  FExchangePattern := value;
  FExchangePattern_IsSet_ := true;
end;

procedure tCrossTalk_Header_Response_Type.SetSourceId(value:tbyte);
begin
  FSourceId := value;
  FSourceId_IsSet_ := true;
end;

procedure tCrossTalk_Header_Response_Type.SetGUID(value:string);
begin
  FGUID := value;
  FGUID_IsSet_ := true;
end;

procedure tCrossTalk_Header_Response_Type.SetDateTime(value:tDateTime);
begin
  FDateTime := value;
  FDateTime_IsSet_ := true;
end;

procedure tCrossTalk_Header_Response_Type.SetContentType(value:string);
begin
  FContentType := value;
  FContentType_IsSet_ := true;
end;

procedure tCrossTalk_Header_Response_Type.SetContentEncoding(value:string);
begin
  FContentEncoding := value;
  FContentEncoding_IsSet_ := true;
end;

procedure tCrossTalk_Header_Response_Type.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'CrossTalk_Header_Response_Type')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_ResponseCode));
  xn.text := IntToStr(FResponseCode);
  if ResponseCodeMessage_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_ResponseCodeMessage));
    xn.text := FResponseCodeMessage;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_ProcessCode));
  xn.text := IntToStr(FProcessCode);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_MessageType));
  xn.text := IntToStr(FMessageType);
  if ExchangePattern_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_ExchangePattern));
    xn.text := FExchangePattern;
  end;
  if SourceId_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_SourceId));
    xn.text := FSourceId;
  end;
  if GUID_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_GUID));
    xn.text := FGUID;
  end;
  if DateTime_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_DateTime));
    xn.text := DateTimeToXMLDateTime(FDateTime);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_EnterpriseId));
  xn.text := IntToStr(FEnterpriseId);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_Token));
  xn.text := FToken;
  if ContentType_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_ContentType));
    xn.text := FContentType;
  end;
  if ContentEncoding_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snCrossTalk_Header_Response_Type_ContentEncoding));
    xn.text := FContentEncoding;
  end;
end; // procedure save

{ tautomatica }

function tautomatica.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tautomatica._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tautomatica.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tautomatica.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snautomatica_dataHora) then
      dataHora :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tautomatica.Destroy;
begin
  inherited;
end; // destructor ...

procedure tautomatica.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'automatica')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snautomatica_dataHora));
  xn.text := FdataHora;
end; // procedure save

{ tperiodo }

function tperiodo.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tperiodo._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tperiodo.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tperiodo.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snperiodo_dataInicial) then
      dataInicial :=  xn.text // string
    else if (sn = snperiodo_dataFinal) then
      dataFinal :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tperiodo.Destroy;
begin
  inherited;
end; // destructor ...

procedure tperiodo.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'periodo')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snperiodo_dataInicial));
  xn.text := FdataInicial;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snperiodo_dataFinal));
  xn.text := FdataFinal;
end; // procedure save

{ ttpConsultaPgtos }

function ttpConsultaPgtos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsultaPgtos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsultaPgtos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpConsultaPgtos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpConsultaPgtos_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpConsultaPgtos_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsultaPgtos_cnpjContratante) then
      cnpjContratante :=  xn.text // string
    else if (sn = sntpConsultaPgtos_cnpjEmitente) then
      cnpjEmitente :=  xn.text // string
    else if (sn = sntpConsultaPgtos_GUID) then
      GUID :=  xn.text // string
    else if (sn = sntpConsultaPgtos_periodo)
      and ((thisURI='') or (tperiodo._nsURI_ = thisURI)) then
      periodo := tperiodo.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsultaPgtos.Destroy;
begin
  Fperiodo.Free;
  inherited;
end; // destructor ...

procedure ttpConsultaPgtos.SetcnpjContratante(value:string);
begin
  FcnpjContratante := value;
  FcnpjContratante_IsSet_ := true;
end;

procedure ttpConsultaPgtos.SetcnpjEmitente(value:string);
begin
  FcnpjEmitente := value;
  FcnpjEmitente_IsSet_ := true;
end;

procedure ttpConsultaPgtos.SetGUID(value:string);
begin
  FGUID := value;
  FGUID_IsSet_ := true;
end;

procedure ttpConsultaPgtos.Setperiodo(value:tperiodo);
begin
  Fperiodo := value;
  Fperiodo_IsSet_ := true;
end;

procedure ttpConsultaPgtos.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpConsultaPgtos.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpConsultaPgtos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, Copy(Self.ClassName,2,200))
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpConsultaPgtos_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpConsultaPgtos_token] := Ftoken;

  if cnpjContratante_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaPgtos_cnpjContratante));
    xn.text := FcnpjContratante;
  end;
  if cnpjEmitente_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaPgtos_cnpjEmitente));
    xn.text := FcnpjEmitente;
  end;
  if GUID_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsultaPgtos_GUID));
    xn.text := FGUID;
  end;
  if Assigned(Fperiodo) then
  begin
    xn := aNode.addChildByName(sntpConsultaPgtos_periodo);
    Fperiodo.Save(xn);
  end;
end; // procedure save

{ tremover }

function tremover.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tremover._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tremover.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tremover.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snremover_pedagioERP) then
      pedagioERP :=  xn.text // string
    else if (sn = snremover_cpf) then
      cpf :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tremover.Destroy;
begin
  inherited;
end; // destructor ...

procedure tremover.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'remover')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snremover_pedagioERP));
  xn.text := FpedagioERP;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snremover_cpf));
  xn.text := Fcpf;
end; // procedure save

{ taltData }

function taltData.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function taltData._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor taltData.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor taltData.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snaltData_data) then
      data :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor taltData.Destroy;
begin
  inherited;
end; // destructor ...

procedure taltData.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'altData')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snaltData_data));
  xn.text := Fdata;
end; // procedure save

{ tvalidade }

function tvalidade.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tvalidade._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tvalidade.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tvalidade.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snvalidade_dtInicio) then
      dtInicio :=  xn.text // string
    else if (sn = snvalidade_dtFim) then
      dtFim :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tvalidade.Destroy;
begin
  inherited;
end; // destructor ...

procedure tvalidade.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'validade')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snvalidade_dtInicio));
  xn.text := FdtInicio;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snvalidade_dtFim));
  xn.text := FdtFim;
end; // procedure save

{ ttpDescontoSemMF }

function ttpDescontoSemMF.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDescontoSemMF._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDescontoSemMF.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpDescontoSemMF.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDescontoSemMF_nmDesc) then
      nmDesc :=  xn.text // string
    else if (sn = sntpDescontoSemMF_vlrDesc) then
      vlrDesc :=  xn.text // string
    else if (sn = sntpDescontoSemMF_rubrica) then
      rubrica :=  xn.text // tbyte
    else if (sn = sntpDescontoSemMF_dsDesc) then
      dsDesc :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDescontoSemMF.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpDescontoSemMF.SetdsDesc(value:string);
begin
  FdsDesc := value;
  FdsDesc_IsSet_ := value<>'';
end;

procedure ttpDescontoSemMF.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDescontoSemMF')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoSemMF_nmDesc));
  xn.text := FnmDesc;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoSemMF_vlrDesc));
  xn.text := FvlrDesc;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoSemMF_rubrica));
  xn.text := Frubrica;
  if dsDesc_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoSemMF_dsDesc));
    xn.text := FdsDesc;
  end;
end; // procedure save

{ tresponsavel }

function tresponsavel.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tresponsavel._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tresponsavel.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tresponsavel.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snresponsavel_nome) then
      nome :=  xn.text // string
    else if (sn = snresponsavel_email) then
      email :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tresponsavel.Destroy;
begin
  inherited;
end; // destructor ...

procedure tresponsavel.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'responsavel')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snresponsavel_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snresponsavel_email));
  xn.text := Femail;
end; // procedure save

{ tresponsaveis }

function tresponsaveis.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tresponsaveis._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tresponsaveis.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fresponsavel := tManagedStringlist.Create;
end; // constructor ...

constructor tresponsaveis.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aresponsavel: tresponsavel;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snresponsaveis_responsavel)
      and ((thisURI='') or (tresponsavel._nsURI_ = thisURI)) then
    begin
      aresponsavel := tresponsavel.Create(xn);
      Fresponsavel.AddObject('?', aresponsavel);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tresponsaveis.Destroy;
begin
  Fresponsavel.Free;
  inherited;
end; // destructor ...

procedure tresponsaveis.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'responsaveis')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "responsavel" is tManagedStringlist
  if Assigned(Fresponsavel) then
    for i:=0 to Fresponsavel.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snresponsaveis_responsavel));
      tresponsavel(Fresponsavel.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tpontoParada }

function tpontoParada.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpontoParada._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpontoParada.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpontoParada.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpontoParada_codigoIBGE) then
      codigoIBGE :=  xn.text // string
    else if (sn = snpontoParada_cep) then
      cep :=  xn.text // string
    else if (sn = snpontoParada_tipoRotaEspecifico) then
      tipoRotaEspecifico :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpontoParada.Destroy;
begin
  inherited;
end; // destructor ...

procedure tpontoParada.SetcodigoIBGE(value:string);
begin
  FcodigoIBGE := value;
  FcodigoIBGE_IsSet_ := true;
end;

procedure tpontoParada.SettipoRotaEspecifico(value:tbyte);
begin
  FtipoRotaEspecifico := value;
  FtipoRotaEspecifico_IsSet_ := true;
end;

procedure tpontoParada.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pontoParada')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if codigoIBGE_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpontoParada_codigoIBGE));
    xn.text := FcodigoIBGE;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpontoParada_cep));
  xn.text := Fcep;
  if tipoRotaEspecifico_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpontoParada_tipoRotaEspecifico));
    xn.text := FtipoRotaEspecifico;
  end;
end; // procedure save

{ tpontosParada }

function tpontosParada.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpontosParada._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpontosParada.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FpontoParada := tManagedStringlist.Create;
end; // constructor ...

constructor tpontosParada.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  apontoParada: tpontoParada;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpontosParada_pontoParada)
      and ((thisURI='') or (tpontoParada._nsURI_ = thisURI)) then
    begin
      apontoParada := tpontoParada.Create(xn);
      FpontoParada.AddObject('?', apontoParada);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpontosParada.Destroy;
begin
  FpontoParada.Free;
  inherited;
end; // destructor ...

procedure tpontosParada.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pontosParada')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "pontoParada" is tManagedStringlist
  if Assigned(FpontoParada) then
    for i:=0 to FpontoParada.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpontosParada_pontoParada));
      tpontoParada(FpontoParada.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tinformacoes_tpRota }

function tinformacoes_tpRota.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinformacoes_tpRota._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinformacoes_tpRota.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FpontosParada := tpontosParada.Create;
end; // constructor ...

constructor tinformacoes_tpRota.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninformacoes_tpRota_nome) then
      nome :=  xn.text // string
    else if (sn = sninformacoes_tpRota_tipoRotaPadrao) then
      tipoRotaPadrao :=  xn.text // tbyte
    else if (sn = sninformacoes_tpRota_pontosParada)
      and ((thisURI='') or (tpontosParada._nsURI_ = thisURI)) then
      FpontosParada := tpontosParada.Create(xn)
    else if (sn = sninformacoes_tpRota_responsaveis)
      and ((thisURI='') or (tresponsaveis._nsURI_ = thisURI)) then
      responsaveis := tresponsaveis.Create(xn)
    else if (sn = sninformacoes_tpRota_utilizarRoteirizador) then
      utilizarRoteirizador :=  xn.text // tbyte
    else if (sn = sninformacoes_tpRota_totalKm) then
      totalKm :=  xn.text // string
    else if (sn = sninformacoes_tpRota_notificarRespContratante) then
      notificarRespContratante :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinformacoes_tpRota.Destroy;
begin
  FpontosParada.Free;
  Fresponsaveis.Free;
  inherited;
end; // destructor ...

procedure tinformacoes_tpRota.SettipoRotaPadrao(value:tbyte);
begin
  FtipoRotaPadrao := value;
  FtipoRotaPadrao_IsSet_ := true;
end;

procedure tinformacoes_tpRota.Setresponsaveis(value:tresponsaveis);
begin
  Fresponsaveis := value;
  Fresponsaveis_IsSet_ := true;
end;

procedure tinformacoes_tpRota.SetutilizarRoteirizador(value:tbyte);
begin
  FutilizarRoteirizador := value;
  FutilizarRoteirizador_IsSet_ := true;
end;

procedure tinformacoes_tpRota.SettotalKm(value:string);
begin
  FtotalKm := value;
  FtotalKm_IsSet_ := true;
end;

procedure tinformacoes_tpRota.SetnotificarRespContratante(value:tbyte);
begin
  FnotificarRespContratante := value;
  FnotificarRespContratante_IsSet_ := true;
end;

procedure tinformacoes_tpRota.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'informacoes_tpRota')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninformacoes_tpRota_nome));
  xn.text := Fnome;
  if tipoRotaPadrao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninformacoes_tpRota_tipoRotaPadrao));
    xn.text := FtipoRotaPadrao;
  end;
  if Assigned(FpontosParada) then
  begin
    xn := aNode.addChildByName(sninformacoes_tpRota_pontosParada);
    FpontosParada.Save(xn);
  end;
  if Assigned(Fresponsaveis) then
  begin
    xn := aNode.addChildByName(sninformacoes_tpRota_responsaveis);
    Fresponsaveis.Save(xn);
  end;
  if utilizarRoteirizador_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninformacoes_tpRota_utilizarRoteirizador));
    xn.text := FutilizarRoteirizador;
  end;
  if totalKm_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninformacoes_tpRota_totalKm));
    xn.text := FtotalKm;
  end;
  if notificarRespContratante_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninformacoes_tpRota_notificarRespContratante));
    xn.text := FnotificarRespContratante;
  end;
end; // procedure save

{ ttpRota }

function ttpRota.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRota._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRota.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRota.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRota_rotaERP) then
      rotaERP :=  xn.text // string
    else if (sn = sntpRota_informacoes)
      and ((thisURI='') or (tinformacoes._nsURI_ = thisURI)) then
      informacoes := tinformacoes_tpRota.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRota.Destroy;
begin
  Finformacoes.Free;
  inherited;
end; // destructor ...

procedure ttpRota.Setinformacoes(value:tinformacoes_tpRota);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure ttpRota.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRota')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if FrotaERP_isSet_ then
  begin
     xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRota_rotaERP));
     xn.text := FrotaERP;
  end;
  
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(sntpRota_informacoes);
    Finformacoes.Save(xn);
  end;
end; // procedure save

procedure ttpRota.SetFrotaERP(const Value: string);
begin
  FrotaERP := Value;
  FrotaERP_isSet_ := value <> '';
end;

{ tviagem }

function tviagem.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tviagem._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tviagem.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Frota := ttpRota.Create;
end; // constructor ...

constructor tviagem.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snviagem_rota) then
      Frota := ttpRota.Create(xn)
    else if (sn = snviagem_codigoSH) then
      codigoSH :=  xn.text // string
    else if (sn = snviagem_qtdeCarga) then
      qtdeCarga :=  xn.text // string
    else if (sn = snviagem_qtdeViagens) then
      qtdeViagens := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tviagem.Destroy;
begin
  if assigned(Frota) then  Frota.free;
  inherited;
end; // destructor ...

procedure tviagem.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'viagem')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Frota) then
  begin
    xn := aNode.addChildByName(snviagem_rota);
    Frota.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snviagem_codigoSH));
  xn.text := FcodigoSH;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snviagem_qtdeCarga));
  xn.text := FqtdeCarga;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snviagem_qtdeViagens));
  xn.text := IntToStr(FqtdeViagens);
end; // procedure save

{ tviagens }

function tviagens.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tviagens._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tviagens.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fviagem := tManagedStringlist.Create;
end; // constructor ...

constructor tviagens.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aviagem: tviagem;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snviagens_viagem)
      and ((thisURI='') or (tviagem._nsURI_ = thisURI)) then
    begin
      aviagem := tviagem.Create(xn);
      Fviagem.AddObject('?', aviagem);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tviagens.Destroy;
begin
  Fviagem.Free;
  inherited;
end; // destructor ...

procedure tviagens.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'viagens')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "viagem" is tManagedStringlist
  if Assigned(Fviagem) then
    for i:=0 to Fviagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snviagens_viagem));
      tviagem(Fviagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tcampo }

function tcampo.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcampo._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcampo.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tcampo.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncampo_nome) then
      nome :=  xn.text // string
    else if (sn = sncampo_valor) then
      valor :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcampo.Destroy;
begin
  inherited;
end; // destructor ...

procedure tcampo.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'campo')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncampo_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncampo_valor));
  xn.text := Fvalor;
end; // procedure save

{ ttpAdicionalImpressao }

function ttpAdicionalImpressao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpAdicionalImpressao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpAdicionalImpressao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fcampo := tManagedStringlist.Create;
end; // constructor ...

constructor ttpAdicionalImpressao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  acampo: tcampo;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpAdicionalImpressao_campo)
      and ((thisURI='') or (tcampo._nsURI_ = thisURI)) then
    begin
      acampo := tcampo.Create(xn);
      Fcampo.AddObject('?', acampo);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpAdicionalImpressao.Destroy;
begin
  Fcampo.Free;
  inherited;
end; // destructor ...

procedure ttpAdicionalImpressao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpAdicionalImpressao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "campo" is tManagedStringlist
  if Assigned(Fcampo) then
    for i:=0 to Fcampo.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAdicionalImpressao_campo));
      tcampo(Fcampo.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tTACagregado_encerramento }

function tTACagregado_encerramento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tTACagregado_encerramento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tTACagregado_encerramento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fviagens := tviagens.Create;
end; // constructor ...

constructor tTACagregado_encerramento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snTACagregado_encerramento_viagens)
      and ((thisURI='') or (tviagens._nsURI_ = thisURI)) then
      Fviagens := tviagens.Create(xn)
    else if (sn = snTACagregado_encerramento_adicionais) then
      adicionais := ttpAdicionalImpressao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tTACagregado_encerramento.Destroy;
begin
  Fviagens.Free;
  if assigned(Fadicionais) then  Fadicionais.free;
  inherited;
end; // destructor ...

procedure tTACagregado_encerramento.Setadicionais(value:ttpAdicionalImpressao);
begin
  Fadicionais := value;
  Fadicionais_IsSet_ := true;
end;

procedure tTACagregado_encerramento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'TACagregado_encerramento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fviagens) then
  begin
    xn := aNode.addChildByName(snTACagregado_encerramento_viagens);
    Fviagens.Save(xn);
  end;
  if Assigned(Fadicionais) then
  begin
    xn := aNode.addChildByName(snTACagregado_encerramento_adicionais);
    Fadicionais.Save(xn);
  end;
end; // procedure save

{ tpadrao_encerramento }

function tpadrao_encerramento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpadrao_encerramento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpadrao_encerramento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpadrao_encerramento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpadrao_encerramento_qtdeCarga) then
      qtdeCarga :=  xn.text // string
    else if (sn = snpadrao_encerramento_adicionais) then
      adicionais := ttpAdicionalImpressao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpadrao_encerramento.Destroy;
begin
  if assigned(Fadicionais) then  Fadicionais.free;
  inherited;
end; // destructor ...

procedure tpadrao_encerramento.Setadicionais(value:ttpAdicionalImpressao);
begin
  Fadicionais := value;
  Fadicionais_IsSet_ := true;
end;

procedure tpadrao_encerramento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'padrao_encerramento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpadrao_encerramento_qtdeCarga));
  xn.text := FqtdeCarga;
  if Assigned(Fadicionais) then
  begin
    xn := aNode.addChildByName(snpadrao_encerramento_adicionais);
    Fadicionais.Save(xn);
  end;
end; // procedure save

{ tencerramento }

function tencerramento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tencerramento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tencerramento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tencerramento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snencerramento_padrao)
      and ((thisURI='') or (tpadrao._nsURI_ = thisURI)) then
      padrao := tpadrao_encerramento.Create(xn)
    else if (sn = snencerramento_TACagregado)
      and ((thisURI='') or (tTACagregado._nsURI_ = thisURI)) then
      TACagregado := tTACagregado_encerramento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tencerramento.Destroy;
begin
  Fpadrao.Free;
  FTACagregado.Free;
  inherited;
end; // destructor ...

procedure tencerramento.Setpadrao(value:tpadrao_encerramento);
begin
  Fpadrao := value;
  Fpadrao_IsSet_ := true;
end;

procedure tencerramento.SetTACagregado(value:tTACagregado_encerramento);
begin
  FTACagregado := value;
  FTACagregado_IsSet_ := true;
end;

procedure tencerramento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'encerramento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fpadrao) then
  begin
    xn := aNode.addChildByName(snencerramento_padrao);
    Fpadrao.Save(xn);
  end;
  if Assigned(FTACagregado) then
  begin
    xn := aNode.addChildByName(snencerramento_TACagregado);
    FTACagregado.Save(xn);
  end;
end; // procedure save

{ ttpDescontoParcelaAlteracao }

function ttpDescontoParcelaAlteracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDescontoParcelaAlteracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDescontoParcelaAlteracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpDescontoParcelaAlteracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDescontoParcelaAlteracao_tpDesc) then
      tpDesc :=  xn.text // tbyte
    else if (sn = sntpDescontoParcelaAlteracao_nmDesc) then
      nmDesc :=  xn.text // string
    else if (sn = sntpDescontoParcelaAlteracao_vlrDesc) then
      vlrDesc :=  xn.text // string
    else if (sn = sntpDescontoParcelaAlteracao_dsDesc) then
      dsDesc :=  xn.text // string
    else if (sn = sntpDescontoParcelaAlteracao_rubrica) then
      rubrica :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDescontoParcelaAlteracao.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpDescontoParcelaAlteracao.SetvlrDesc(value:string);
begin
  FvlrDesc := value;
  FvlrDesc_IsSet_ := true;
end;

procedure ttpDescontoParcelaAlteracao.SetdsDesc(value:string);
begin
  FdsDesc := value;
end;

procedure ttpDescontoParcelaAlteracao.Setrubrica(value:tbyte);
begin
  Frubrica := value;
  Frubrica_IsSet_ := true;
end;

procedure ttpDescontoParcelaAlteracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDescontoParcelaAlteracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcelaAlteracao_tpDesc));
  xn.text := FtpDesc;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcelaAlteracao_nmDesc));
  xn.text := FnmDesc;
  if vlrDesc_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcelaAlteracao_vlrDesc));
    xn.text := FvlrDesc;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcelaAlteracao_dsDesc));
  xn.text := FdsDesc;

  if rubrica_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcelaAlteracao_rubrica));
    xn.text := Frubrica;
  end;
end; // procedure save

{ ttpDescontoParcela }

function ttpDescontoParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDescontoParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDescontoParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpDescontoParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDescontoParcela_tpDesc) then
      tpDesc :=  xn.text // tbyte
    else if (sn = sntpDescontoParcela_nmDesc) then
      nmDesc :=  xn.text // string
    else if (sn = sntpDescontoParcela_vlrDesc) then
      vlrDesc :=  xn.text // string
    else if (sn = sntpDescontoParcela_dsDesc) then
      dsDesc :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDescontoParcela.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpDescontoParcela.SetvlrDesc(value:string);
begin
  FvlrDesc := value;
  FvlrDesc_IsSet_ := true;
end;

procedure ttpDescontoParcela.SetdsDesc(value:string);
begin
  FdsDesc := value;
  FdsDesc_IsSet_ := value<>'';
end;

procedure ttpDescontoParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDescontoParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcela_tpDesc));
  xn.text := FtpDesc;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcela_nmDesc));
  xn.text := FnmDesc;
  if vlrDesc_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcela_vlrDesc));
    xn.text := FvlrDesc;
  end;
  if dsDesc_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDescontoParcela_dsDesc));
    xn.text := FdsDesc;
  end;
end; // procedure save

{ ttpAdicionalParcela }

function ttpAdicionalParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpAdicionalParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpAdicionalParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpAdicionalParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpAdicionalParcela_valor) then
      valor :=  xn.text // string
    else if (sn = sntpAdicionalParcela_rubrica) then
      rubrica :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpAdicionalParcela.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpAdicionalParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpAdicionalParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAdicionalParcela_valor));
  xn.text := Fvalor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAdicionalParcela_rubrica));
  xn.text := Frubrica;
end; // procedure save

{ tdescontos_tpAlterarParcela }

function tdescontos_tpAlterarParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdescontos_tpAlterarParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdescontos_tpAlterarParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdesconto := tManagedStringlist.Create;
end; // constructor ...

constructor tdescontos_tpAlterarParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndescontos_tpAlterarParcela_desconto) then
    begin
      // list of simple type
      desconto.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdescontos_tpAlterarParcela.Destroy;
begin
  Fdesconto.Free;
  inherited;
end; // destructor ...

procedure tdescontos_tpAlterarParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'descontos_tpAlterarParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "desconto" is tManagedStringlist
  if Assigned(Fdesconto) then
    for i:=0 to Fdesconto.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndescontos_tpAlterarParcela_desconto));
      ttpDescontoParcela(Fdesconto.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tdescontos_tpParcela }

function tdescontos_tpParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdescontos_tpParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdescontos_tpParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdesconto := tManagedStringlist.Create;
end; // constructor ...

constructor tdescontos_tpParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndescontos_tpParcela_desconto) then
    begin
      // list of simple type
      desconto.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdescontos_tpParcela.Destroy;
begin
  Fdesconto.Free;
  inherited;
end; // destructor ...

procedure tdescontos_tpParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'descontos_tpParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "desconto" is tManagedStringlist
  if Assigned(Fdesconto) then
    for i:=0 to Fdesconto.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndescontos_tpParcela_desconto));
      ttpDescontoParcela(Fdesconto.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tautomatico }

function tautomatico.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tautomatico._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tautomatico.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tautomatico.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snautomatico_dataHora) then
      dataHora :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tautomatico.Destroy;
begin
  inherited;
end; // destructor ...

procedure tautomatico.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'automatico')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snautomatico_dataHora));
  xn.text := FdataHora;
end; // procedure save

{ tmanual }

function tmanual.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmanual._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmanual.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tmanual.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmanual_dataPrevisao) then
      dataPrevisao :=  xn.text // string
    else if (sn = snmanual_efetivacao) then
      efetivacao :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmanual.Destroy;
begin
  inherited;
end; // destructor ...

procedure tmanual.Setefetivacao(value:tbyte);
begin
  Fefetivacao := value;
  Fefetivacao_IsSet_ := true;
end;

procedure tmanual.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'manual')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmanual_dataPrevisao));
  xn.text := FdataPrevisao;
  if efetivacao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmanual_efetivacao));
    xn.text := Fefetivacao;
  end;
end; // procedure save

{ ttpTipoPagamento }

function ttpTipoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpTipoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpTipoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpTipoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpTipoPagamento_manual)
      and ((thisURI='') or (tmanual._nsURI_ = thisURI)) then
      manual := tmanual.Create(xn)
    else if (sn = sntpTipoPagamento_automatico)
      and ((thisURI='') or (tautomatico._nsURI_ = thisURI)) then
      automatico := tautomatico.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpTipoPagamento.Destroy;
begin
  Fmanual.Free;
  Fautomatico.Free;
  inherited;
end; // destructor ...

procedure ttpTipoPagamento.Setmanual(value:tmanual);
begin
  Fmanual := value;
  Fmanual_IsSet_ := true;
end;

procedure ttpTipoPagamento.Setautomatico(value:tautomatico);
begin
  Fautomatico := value;
  Fautomatico_IsSet_ := true;
end;

procedure ttpTipoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpTipoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmanual) then
  begin
    xn := aNode.addChildByName(sntpTipoPagamento_manual);
    Fmanual.Save(xn);
  end;
  if Assigned(Fautomatico) then
  begin
    xn := aNode.addChildByName(sntpTipoPagamento_automatico);
    Fautomatico.Save(xn);
  end;
end; // procedure save

{ ttpRestricaoPagamento }

function ttpRestricaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRestricaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRestricaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRestricaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRestricaoPagamento_campo) then
      campo :=  xn.text // tbyte
    else if (sn = sntpRestricaoPagamento_valor) then
      valor :=  xn.text // string
    else if (sn = sntpRestricaoPagamento_criterio) then
      criterio :=  xn.text // tbyte
    else if (sn = sntpRestricaoPagamento_conector) then
      conector :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRestricaoPagamento.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpRestricaoPagamento.Setcriterio(value:tbyte);
begin
  Fcriterio := value;
  Fcriterio_IsSet_ := true;
end;

procedure ttpRestricaoPagamento.Setconector(value:tbyte);
begin
  Fconector := value;
  Fconector_IsSet_ := true;
end;

procedure ttpRestricaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRestricaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRestricaoPagamento_campo));
  xn.text := Fcampo;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRestricaoPagamento_valor));
  xn.text := Fvalor;
  if criterio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRestricaoPagamento_criterio));
    xn.text := Fcriterio;
  end;
  if conector_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRestricaoPagamento_conector));
    xn.text := Fconector;
  end;
end; // procedure save

{ trestricoes_tpAlterarParcela }

function trestricoes_tpAlterarParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function trestricoes_tpAlterarParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor trestricoes_tpAlterarParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Frestricao := tManagedStringlist.Create;
end; // constructor ...

constructor trestricoes_tpAlterarParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snrestricoes_tpAlterarParcela_restricao) then
    begin
      // list of simple type
      restricao.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor trestricoes_tpAlterarParcela.Destroy;
begin
  Frestricao.Free;
  inherited;
end; // destructor ...

procedure trestricoes_tpAlterarParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'restricoes_tpAlterarParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "restricao" is tManagedStringlist
  if Assigned(Frestricao) then
    for i:=0 to Frestricao.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snrestricoes_tpAlterarParcela_restricao));
      ttpRestricaoPagamento(Frestricao.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ trestricoes }

function trestricoes.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function trestricoes._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor trestricoes.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Frestricao := tManagedStringlist.Create;
end; // constructor ...

constructor trestricoes.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snrestricoes_restricao) then
    begin
      // list of simple type
      restricao.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor trestricoes.Destroy;
begin
  Frestricao.Free;
  inherited;
end; // destructor ...

procedure trestricoes.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'restricoes')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "restricao" is tManagedStringlist
  if Assigned(Frestricao) then
    for i:=0 to Frestricao.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snrestricoes_restricao));
      ttpRestricaoPagamento(Frestricao.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpImpostos }

function ttpImpostos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpImpostos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpImpostos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpImpostos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpImpostos_irrf) then
      irrf :=  xn.text // string
    else if (sn = sntpImpostos_inss) then
      inss :=  xn.text // string
    else if (sn = sntpImpostos_sestsenat) then
      sestsenat :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpImpostos.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpImpostos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpImpostos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpImpostos_irrf));
  xn.text := Firrf;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpImpostos_inss));
  xn.text := Finss;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpImpostos_sestsenat));
  xn.text := Fsestsenat;
end; // procedure save

{ taltValores }

function taltValores.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function taltValores._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor taltValores.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor taltValores.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snaltValores_adicional) then
      adicional := ttpAdicionalParcela.Create(xn)
    else if (sn = snaltValores_desconto) then
      desconto := ttpDescontoParcelaAlteracao.Create(xn)
    else if (sn = snaltValores_retencoes) then
      retencoes := ttpImpostos.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor taltValores.Destroy;
begin
  if assigned(Fadicional) then  Fadicional.free;
  if assigned(Fdesconto) then  Fdesconto.free;
  if assigned(Fretencoes) then  Fretencoes.free;
  inherited;
end; // destructor ...

procedure taltValores.Setadicional(value:ttpAdicionalParcela);
begin
  Fadicional := value;
  Fadicional_IsSet_ := true;
end;

procedure taltValores.Setdesconto(value:ttpDescontoParcelaAlteracao);
begin
  Fdesconto := value;
  Fdesconto_IsSet_ := true;
end;

procedure taltValores.Setretencoes(value:ttpImpostos);
begin
  Fretencoes := value;
  Fretencoes_IsSet_ := true;
end;

procedure taltValores.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'altValores')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fadicional) then
  begin
    xn := aNode.addChildByName(snaltValores_adicional);
    Fadicional.Save(xn);
  end;
  if Assigned(Fdesconto) then
  begin
    xn := aNode.addChildByName(snaltValores_desconto);
    Fdesconto.Save(xn);
  end;
  if Assigned(Fretencoes) then
  begin
    xn := aNode.addChildByName(snaltValores_retencoes);
    Fretencoes.Save(xn);
  end;
end; // procedure save

{ tajustaParc }

function tajustaParc.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tajustaParc._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tajustaParc.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tajustaParc.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snajustaParc_nome) then
      nome :=  xn.text // string
    else if (sn = snajustaParc_altData)
      and ((thisURI='') or (taltData._nsURI_ = thisURI)) then
      altData := taltData.Create(xn)
    else if (sn = snajustaParc_altValores)
      and ((thisURI='') or (taltValores._nsURI_ = thisURI)) then
      altValores := taltValores.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tajustaParc.Destroy;
begin
  if assigned(FaltData) then FaltData.Free;
  if assigned(FaltValores) then FaltValores.Free;
  inherited;
end; // destructor ...

procedure tajustaParc.SetaltData(value:taltData);
begin
  FaltData := value;
  FaltData_IsSet_ := true;
end;

procedure tajustaParc.SetaltValores(value:taltValores);
begin
  FaltValores := value;
  FaltValores_IsSet_ := true;
end;

procedure tajustaParc.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ajustaParc')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snajustaParc_nome));
  xn.text := Fnome;
  if Assigned(FaltData) then
  begin
    xn := aNode.addChildByName(snajustaParc_altData);
    FaltData.Save(xn);
  end;
  if Assigned(FaltValores) then
  begin
    xn := aNode.addChildByName(snajustaParc_altValores);
    FaltValores.Save(xn);
  end;
end; // procedure save

{ tpraca_pracas_tpRetornoPedagio }

function tpraca_pracas_tpRetornoPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpraca_pracas_tpRetornoPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpraca_pracas_tpRetornoPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpraca_pracas_tpRetornoPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpraca_pracas_tpRetornoPedagio_nome) then
      nome :=  xn.text // string
    else if (sn = snpraca_pracas_tpRetornoPedagio_valor) then
      valor :=  xn.text // string
    else if (sn = snpraca_pracas_tpRetornoPedagio_localizacao) then
      localizacao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpraca_pracas_tpRetornoPedagio.Destroy;
begin
  inherited;
end; // destructor ...

procedure tpraca_pracas_tpRetornoPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'praca_pracas_tpRetornoPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpraca_pracas_tpRetornoPedagio_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpraca_pracas_tpRetornoPedagio_valor));
  xn.text := Fvalor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpraca_pracas_tpRetornoPedagio_localizacao));
  xn.text := Flocalizacao;
end; // procedure save

{ tpracas_tpRetornoPedagio }

function tpracas_tpRetornoPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpracas_tpRetornoPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpracas_tpRetornoPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fpraca := tManagedStringlist.Create;
end; // constructor ...

constructor tpracas_tpRetornoPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  apraca: tpraca;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpracas_tpRetornoPedagio_praca)
      and ((thisURI='') or (tpraca._nsURI_ = thisURI)) then
    begin
      apraca := tpraca.Create(xn);
      Fpraca.AddObject('?', apraca);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpracas_tpRetornoPedagio.Destroy;
begin
  Fpraca.Free;
  inherited;
end; // destructor ...

procedure tpracas_tpRetornoPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pracas_tpRetornoPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "praca" is tManagedStringlist
  if Assigned(Fpraca) then
    for i:=0 to Fpraca.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpracas_tpRetornoPedagio_praca));
      tpraca_pracas_tpRetornoPedagio(Fpraca.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoPedagio }

function ttpRetornoPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoPedagio_valor) then
      valor :=  xn.text // string
    else if (sn = sntpRetornoPedagio_origem) then
      origem :=  xn.text // string
    else if (sn = sntpRetornoPedagio_destino) then
      destino :=  xn.text // string
    else if (sn = sntpRetornoPedagio_pracas)
      and ((thisURI='') or (tpracas._nsURI_ = thisURI)) then
      pracas := tpracas_tpRetornoPedagio.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoPedagio.Destroy;
begin
  Fpracas.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoPedagio.Setpracas(value:tpracas_tpRetornoPedagio);
begin
  Fpracas := value;
  Fpracas_IsSet_ := true;
end;

procedure ttpRetornoPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPedagio_valor));
  xn.text := Fvalor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPedagio_origem));
  xn.text := Forigem;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPedagio_destino));
  xn.text := Fdestino;
  if Assigned(Fpracas) then
  begin
    xn := aNode.addChildByName(sntpRetornoPedagio_pracas);
    Fpracas.Save(xn);
  end;
end; // procedure save

{ ttpRetornoValores }

function ttpRetornoValores.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoValores._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoValores.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoValores.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoValores_vlrFrete) then
      vlrFrete :=  xn.text // string
    else if (sn = sntpRetornoValores_vlrDespesas) then
      vlrDespesas :=  xn.text // string
    else if (sn = sntpRetornoValores_vlrCombustivel) then
      vlrCombustivel :=  xn.text // string
    else if (sn = sntpRetornoValores_vlrSaldo) then
      vlrSaldo :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoValores.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpRetornoValores.SetvlrDespesas(value:string);
begin
  FvlrDespesas := value;
  FvlrDespesas_IsSet_ := true;
end;

procedure ttpRetornoValores.SetvlrCombustivel(value:string);
begin
  FvlrCombustivel := value;
  FvlrCombustivel_IsSet_ := true;
end;

procedure ttpRetornoValores.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoValores')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoValores_vlrFrete));
  xn.text := FvlrFrete;
  if vlrDespesas_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoValores_vlrDespesas));
    xn.text := FvlrDespesas;
  end;
  if vlrCombustivel_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoValores_vlrCombustivel));
    xn.text := FvlrCombustivel;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoValores_vlrSaldo));
  xn.text := FvlrSaldo;
end; // procedure save

{ ttpDespesas }

function ttpDespesas.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDespesas._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDespesas.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpDespesas.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDespesas_vlrDespesas) then
      vlrDespesas :=  xn.text // string
    else if (sn = sntpDespesas_descricao) then
      descricao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDespesas.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpDespesas.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDespesas')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDespesas_vlrDespesas));
  xn.text := FvlrDespesas;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDespesas_descricao));
  xn.text := Fdescricao;
end; // procedure save

{ ttpValoresSemMF }

function ttpValoresSemMF.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpValoresSemMF._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpValoresSemMF.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpValoresSemMF.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpValoresSemMF_vlrFrete) then
      vlrFrete :=  xn.text // string
    else if (sn = sntpValoresSemMF_despesas) then
      despesas := ttpDespesas.Create(xn)
    else if (sn = sntpValoresSemMF_retencoes) then
      retencoes := ttpImpostos.Create(xn)
    else if (sn = sntpValoresSemMF_vlrCombustivel) then
      vlrCombustivel :=  xn.text // string
    else if (sn = sntpValoresSemMF_vlrPedagio) then
      vlrPedagio :=  xn.text // string
    else if (sn = sntpValoresSemMF_desconto) then
      desconto := ttpDescontoSemMF.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpValoresSemMF.Destroy;
begin
  if assigned(Fdespesas) then  Fdespesas.free;
  if assigned(Fretencoes) then  Fretencoes.free;
  if assigned(Fdesconto) then  Fdesconto.free;
  inherited;
end; // destructor ...

procedure ttpValoresSemMF.SetvlrFrete(value:string);
begin
  FvlrFrete := value;
  FvlrFrete_IsSet_ := true;
end;

procedure ttpValoresSemMF.Setdespesas(value:ttpDespesas);
begin
  Fdespesas := value;
  Fdespesas_IsSet_ := true;
end;

procedure ttpValoresSemMF.Setretencoes(value:ttpImpostos);
begin
  Fretencoes := value;
  Fretencoes_IsSet_ := true;
end;

procedure ttpValoresSemMF.SetvlrCombustivel(value:string);
begin
  FvlrCombustivel := value;
  FvlrCombustivel_IsSet_ := true;
end;

procedure ttpValoresSemMF.SetvlrPedagio(value:string);
begin
  FvlrPedagio := value;
  FvlrPedagio_IsSet_ := true;
end;

procedure ttpValoresSemMF.Setdesconto(value:ttpDescontoSemMF);
begin
  Fdesconto := value;
  Fdesconto_IsSet_ := true;
end;

procedure ttpValoresSemMF.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpValoresSemMF')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if vlrFrete_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpValoresSemMF_vlrFrete));
    xn.text := FvlrFrete;
  end;
  if Assigned(Fdespesas) then
  begin
    xn := aNode.addChildByName(sntpValoresSemMF_despesas);
    Fdespesas.Save(xn);
  end;
  if Assigned(Fretencoes) then
  begin
    xn := aNode.addChildByName(sntpValoresSemMF_retencoes);
    Fretencoes.Save(xn);
  end;
  if vlrCombustivel_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpValoresSemMF_vlrCombustivel));
    xn.text := FvlrCombustivel;
  end;
  if vlrPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpValoresSemMF_vlrPedagio));
    xn.text := FvlrPedagio;
  end;
  if Assigned(Fdesconto) then
  begin
    xn := aNode.addChildByName(sntpValoresSemMF_desconto);
    Fdesconto.Save(xn);
  end;
end; // procedure save

{ tsemMF }

function tsemMF.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tsemMF._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tsemMF.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fvalores := ttpValoresSemMF.Create;
end; // constructor ...

constructor tsemMF.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snsemMF_valores) then
      Fvalores := ttpValoresSemMF.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tsemMF.Destroy;
begin
  if assigned(Fvalores) then  Fvalores.free;
  inherited;
end; // destructor ...

procedure tsemMF.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'semMF')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fvalores) then
  begin
    xn := aNode.addChildByName(snsemMF_valores);
    Fvalores.Save(xn);
  end;
end; // procedure save

{ tdescontos }

function tdescontos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdescontos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdescontos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdesconto := tManagedStringlist.Create;
end; // constructor ...

constructor tdescontos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndescontos_desconto) then
    begin
      // list of simple type
      Fdesconto.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdescontos.Destroy;
begin
  Fdesconto.Free;
  inherited;
end; // destructor ...

procedure tdescontos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'descontos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "desconto" is tManagedStringlist
  if Assigned(Fdesconto) then
    for i:=0 to Fdesconto.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndescontos_desconto));
      ttpDescontoParcela(Fdesconto.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoIdentificacao }

function ttpRetornoIdentificacao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoIdentificacao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoIdentificacao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoIdentificacao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoIdentificacao_serie) then
      serie :=  xn.text // string
    else if (sn = sntpRetornoIdentificacao_numero) then
      numero :=  xn.text // string
    else if (sn = sntpRetornoIdentificacao_dataEmissao) then
      dataEmissao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoIdentificacao.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpRetornoIdentificacao.Setserie(value:string);
begin
  Fserie := value;
  Fserie_IsSet_ := true;
end;

procedure ttpRetornoIdentificacao.Setnumero(value:string);
begin
  Fnumero := value;
  Fnumero_IsSet_ := true;
end;

procedure ttpRetornoIdentificacao.SetdataEmissao(value:string);
begin
  FdataEmissao := value;
  FdataEmissao_IsSet_ := true;
end;

procedure ttpRetornoIdentificacao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoIdentificacao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if serie_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoIdentificacao_serie));
    xn.text := Fserie;
  end;
  if numero_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoIdentificacao_numero));
    xn.text := Fnumero;
  end;
  if dataEmissao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoIdentificacao_dataEmissao));
    xn.text := FdataEmissao;
  end;
end; // procedure save

{ tdependencia }

function tdependencia.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdependencia._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdependencia.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tdependencia.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndependencia_descricao) then
      descricao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdependencia.Destroy;
begin
  inherited;
end; // destructor ...

procedure tdependencia.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'dependencia')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndependencia_descricao));
  xn.text := Fdescricao;
end; // procedure save

{ tdependencias }

function tdependencias.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdependencias._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdependencias.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdependencia := tManagedStringlist.Create;
end; // constructor ...

constructor tdependencias.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  adependencia: tdependencia;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndependencias_dependencia)
      and ((thisURI='') or (tdependencia._nsURI_ = thisURI)) then
    begin
      adependencia := tdependencia.Create(xn);
      Fdependencia.AddObject('?', adependencia);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdependencias.Destroy;
begin
  Fdependencia.Free;
  inherited;
end; // destructor ...

procedure tdependencias.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'dependencias')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "dependencia" is tManagedStringlist
  if Assigned(Fdependencia) then
    for i:=0 to Fdependencia.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndependencias_dependencia));
      tdependencia(Fdependencia.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpDocumento }

function ttpDocumento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDocumento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDocumento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdependencias := tdependencias.Create;
end; // constructor ...

constructor ttpDocumento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDocumento_tipo) then
      tipo :=  xn.text // string
    else if (sn = sntpDocumento_obrigatorio) then
      obrigatorio :=  xn.text // tbyte
    else if (sn = sntpDocumento_dependencias)
      and ((thisURI='') or (tdependencias._nsURI_ = thisURI)) then
      Fdependencias := tdependencias.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDocumento.Destroy;
begin
  Fdependencias.Free;
  inherited;
end; // destructor ...

procedure ttpDocumento.Setobrigatorio(value:tbyte);
begin
  Fobrigatorio := value;
  Fobrigatorio_IsSet_ := true;
end;

procedure ttpDocumento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDocumento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDocumento_tipo));
  xn.text := Ftipo;
  if obrigatorio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDocumento_obrigatorio));
    xn.text := Fobrigatorio;
  end;
  if Assigned(Fdependencias) then
  begin
    xn := aNode.addChildByName(sntpDocumento_dependencias);
    Fdependencias.Save(xn);
  end;
end; // procedure save

{ tdocumentos_tpAlterarParcela }

function tdocumentos_tpAlterarParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdocumentos_tpAlterarParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdocumentos_tpAlterarParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdocumento := tManagedStringlist.Create;
end; // constructor ...

constructor tdocumentos_tpAlterarParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndocumentos_tpAlterarParcela_documento) then
    begin
      // list of simple type
      Fdocumento.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdocumentos_tpAlterarParcela.Destroy;
begin
  Fdocumento.Free;
  inherited;
end; // destructor ...

procedure tdocumentos_tpAlterarParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'documentos_tpAlterarParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "documento" is tManagedStringlist
  if Assigned(Fdocumento) then
    for i:=0 to Fdocumento.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndocumentos_tpAlterarParcela_documento));
      ttpDocumento(Fdocumento.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpAlterarParcela }

function ttpAlterarParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpAlterarParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpAlterarParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FtipoPgto := ttpTipoPagamento.Create;
end; // constructor ...

constructor ttpAlterarParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpAlterarParcela_nome) then
      nome :=  xn.text // string
    else if (sn = sntpAlterarParcela_tipoPgto) then
      FtipoPgto := ttpTipoPagamento.Create(xn)
    else if (sn = sntpAlterarParcela_valorAplicado) then
      valorAplicado :=  xn.text // string
    else if (sn = sntpAlterarParcela_valorReal) then
      valorReal :=  xn.text // string
    else if (sn = sntpAlterarParcela_documentos)
      and ((thisURI='') or (tdocumentos._nsURI_ = thisURI)) then
      documentos := tdocumentos_tpAlterarParcela.Create(xn)
    else if (sn = sntpAlterarParcela_descontos)
      and ((thisURI='') or (tdescontos._nsURI_ = thisURI)) then
      descontos := tdescontos_tpAlterarParcela.Create(xn)
    else if (sn = sntpAlterarParcela_restricoes)
      and ((thisURI='') or (trestricoes._nsURI_ = thisURI)) then
      restricoes := trestricoes_tpAlterarParcela.Create(xn)
    else if (sn = sntpAlterarParcela_retencoes) then
      retencoes := ttpImpostos.Create(xn)
    else if (sn = sntpAlterarParcela_rubrica) then
      rubrica :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpAlterarParcela.Destroy;
begin
  if assigned(FtipoPgto) then  FtipoPgto.free;
  Fdocumentos.Free;
  Fdescontos.Free;
  Frestricoes.Free;
  if assigned(Fretencoes) then  Fretencoes.free;
  inherited;
end; // destructor ...

procedure ttpAlterarParcela.SetvalorReal(value:string);
begin
  FvalorReal := value;
  FvalorReal_IsSet_ := true;
end;

procedure ttpAlterarParcela.Setdocumentos(value:tdocumentos_tpAlterarParcela);
begin
  Fdocumentos := value;
  Fdocumentos_IsSet_ := true;
end;

procedure ttpAlterarParcela.Setdescontos(value:tdescontos_tpAlterarParcela);
begin
  Fdescontos := value;
  Fdescontos_IsSet_ := true;
end;

procedure ttpAlterarParcela.Setrestricoes(value:trestricoes_tpAlterarParcela);
begin
  Frestricoes := value;
  Frestricoes_IsSet_ := true;
end;

procedure ttpAlterarParcela.Setretencoes(value:ttpImpostos);
begin
  Fretencoes := value;
  Fretencoes_IsSet_ := true;
end;

procedure ttpAlterarParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpAlterarParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAlterarParcela_nome));
  xn.text := Fnome;
  if Assigned(FtipoPgto) then
  begin
    xn := aNode.addChildByName(sntpAlterarParcela_tipoPgto);
    FtipoPgto.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAlterarParcela_valorAplicado));
  xn.text := FvalorAplicado;
  if valorReal_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAlterarParcela_valorReal));
    xn.text := FvalorReal;
  end;
  if Assigned(Fdocumentos) then
  begin
    xn := aNode.addChildByName(sntpAlterarParcela_documentos);
    Fdocumentos.Save(xn);
  end;
  if Assigned(Fdescontos) then
  begin
    xn := aNode.addChildByName(sntpAlterarParcela_descontos);
    Fdescontos.Save(xn);
  end;
  if Assigned(Frestricoes) then
  begin
    xn := aNode.addChildByName(sntpAlterarParcela_restricoes);
    Frestricoes.Save(xn);
  end;
  if Assigned(Fretencoes) then
  begin
    xn := aNode.addChildByName(sntpAlterarParcela_retencoes);
    Fretencoes.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAlterarParcela_rubrica));
  xn.text := Frubrica;
end; // procedure save

{ tdocumentos_tpParcela }

function tdocumentos_tpParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdocumentos_tpParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdocumentos_tpParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdocumento := tManagedStringlist.Create;
end; // constructor ...

constructor tdocumentos_tpParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndocumentos_tpParcela_documento) then
    begin
      // list of simple type
      Fdocumento.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdocumentos_tpParcela.Destroy;
begin
  Fdocumento.Free;
  inherited;
end; // destructor ...

procedure tdocumentos_tpParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'documentos_tpParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "documento" is tManagedStringlist
  if Assigned(Fdocumento) then
    for i:=0 to Fdocumento.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndocumentos_tpParcela_documento));
      ttpDocumento(Fdocumento.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpParcela }

function ttpParcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpParcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpParcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FtipoPgto := ttpTipoPagamento.Create;
end; // constructor ...

constructor ttpParcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpParcela_nome) then
      nome :=  xn.text // string
    else if (sn = sntpParcela_tipoPgto) then
      FtipoPgto := ttpTipoPagamento.Create(xn)
    else if (sn = sntpParcela_valorAplicado) then
      valorAplicado :=  xn.text // string
    else if (sn = sntpParcela_valorReal) then
      valorReal :=  xn.text // string
    else if (sn = sntpParcela_documentos)
      and ((thisURI='') or (tdocumentos._nsURI_ = thisURI)) then
      documentos := tdocumentos_tpParcela.Create(xn)
    else if (sn = sntpParcela_descontos)
      and ((thisURI='') or (tdescontos._nsURI_ = thisURI)) then
      descontos := tdescontos_tpParcela.Create(xn)
    else if (sn = sntpParcela_restricoes)
      and ((thisURI='') or (trestricoes._nsURI_ = thisURI)) then
      restricoes := trestricoes.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpParcela.Destroy;
begin
  if assigned(FtipoPgto) then  FtipoPgto.free;
  Fdocumentos.Free;
  Fdescontos.Free;
  Frestricoes.Free;
  inherited;
end; // destructor ...

procedure ttpParcela.SetvalorReal(value:string);
begin
  FvalorReal := value;
  FvalorReal_IsSet_ := true;
end;

procedure ttpParcela.Setdocumentos(value:tdocumentos_tpParcela);
begin
  Fdocumentos := value;
  Fdocumentos_IsSet_ := true;
end;

procedure ttpParcela.Setdescontos(value:tdescontos_tpParcela);
begin
  Fdescontos := value;
  Fdescontos_IsSet_ := true;
end;

procedure ttpParcela.Setrestricoes(value:trestricoes);
begin
  Frestricoes := value;
  Frestricoes_IsSet_ := true;
end;

procedure ttpParcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpParcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpParcela_nome));
  xn.text := Fnome;
  if Assigned(FtipoPgto) then
  begin
    xn := aNode.addChildByName(sntpParcela_tipoPgto);
    FtipoPgto.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpParcela_valorAplicado));
  xn.text := FvalorAplicado;
  if valorReal_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpParcela_valorReal));
    xn.text := FvalorReal;
  end;
  if Assigned(Fdocumentos) then
  begin
    xn := aNode.addChildByName(sntpParcela_documentos);
    Fdocumentos.Save(xn);
  end;
  if Assigned(Fdescontos) then
  begin
    xn := aNode.addChildByName(sntpParcela_descontos);
    Fdescontos.Save(xn);
  end;
  if Assigned(Frestricoes) then
  begin
    xn := aNode.addChildByName(sntpParcela_restricoes);
    Frestricoes.Save(xn);
  end;
end; // procedure save

{ tparcelas }

function tparcelas.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tparcelas._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tparcelas.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fparcela := tManagedStringlist.Create;
end; // constructor ...

constructor tparcelas.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snparcelas_parcela) then
    begin
      // list of simple type
      Fparcela.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tparcelas.Destroy;
begin
  Fparcela.Free;
  inherited;
end; // destructor ...

procedure tparcelas.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'parcelas')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "parcela" is tManagedStringlist
  if Assigned(Fparcela) then
    for i:=0 to Fparcela.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcelas_parcela));
      ttpParcela(Fparcela.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tinformacoes }

function tinformacoes.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinformacoes._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinformacoes.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fparcelas := tparcelas.Create;
end; // constructor ...

constructor tinformacoes.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninformacoes_parcelas)
      and ((thisURI='') or (tparcelas._nsURI_ = thisURI)) then
      Fparcelas := tparcelas.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinformacoes.Destroy;
begin
  Fparcelas.Free;
  inherited;
end; // destructor ...

procedure tinformacoes.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'informacoes')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fparcelas) then
  begin
    xn := aNode.addChildByName(sninformacoes_parcelas);
    Fparcelas.Save(xn);
  end;
end; // procedure save

{ ttpParcelamento }

function ttpParcelamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpParcelamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpParcelamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpParcelamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpParcelamento_regraERP) then
      regraERP :=  xn.text // string
    else if (sn = sntpParcelamento_informacoes)
      and ((thisURI='') or (tinformacoes._nsURI_ = thisURI)) then
      Finformacoes := tinformacoes.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpParcelamento.Destroy;
begin
  Finformacoes.Free;
  inherited;
end; // destructor ...

procedure ttpParcelamento.Setinformacoes(value:tinformacoes);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure ttpParcelamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpParcelamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;
  if FregraERP_isSet_ then
  begin
     xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpParcelamento_regraERP));
     xn.text := FregraERP;
  end;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(sntpParcelamento_informacoes);
    Finformacoes.Save(xn);
  end;
end; // procedure save

procedure ttpParcelamento.SetregraERP(const Value: string);
begin
  FregraERP := Value;
  FregraERP_isSet_ := Value<>'';
end;


{ tndot_tpAutorizacaoOT }

function tndot_tpAutorizacaoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndot_tpAutorizacaoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndot_tpAutorizacaoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndot_tpAutorizacaoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndot_tpAutorizacaoOT_numero) then
      numero := xn.text
    else if (sn = snndot_tpAutorizacaoOT_ndotCodVerificador) then
      ndotCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndot_tpAutorizacaoOT.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndot_tpAutorizacaoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndot_tpAutorizacaoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndot_tpAutorizacaoOT_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndot_tpAutorizacaoOT_ndotCodVerificador));
  xn.text := FndotCodVerificador;
end; // procedure save

{ tciot_tpAutorizacaoOT }

function tciot_tpAutorizacaoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tciot_tpAutorizacaoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tciot_tpAutorizacaoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tciot_tpAutorizacaoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snciot_tpAutorizacaoOT_numero) then
      numero := xn.text
    else if (sn = snciot_tpAutorizacaoOT_ciotCodVerificador) then
      ciotCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tciot_tpAutorizacaoOT.Destroy;
begin
  inherited;
end; // destructor ...

procedure tciot_tpAutorizacaoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ciot_tpAutorizacaoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snciot_tpAutorizacaoOT_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snciot_tpAutorizacaoOT_ciotCodVerificador));
  xn.text := FciotCodVerificador;
end; // procedure save

{ ttpAutorizacaoOT }

function ttpAutorizacaoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpAutorizacaoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpAutorizacaoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpAutorizacaoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpAutorizacaoOT_ciot)
      and ((thisURI='') or (tciot._nsURI_ = thisURI)) then
      ciot := tciot_tpAutorizacaoOT.Create(xn)
    else if (sn = sntpAutorizacaoOT_ndot)
      and ((thisURI='') or (tndot._nsURI_ = thisURI)) then
      ndot := tndot_tpAutorizacaoOT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpAutorizacaoOT.Destroy;
begin
  Fciot.Free;
  Fndot.Free;
  inherited;
end; // destructor ...

procedure ttpAutorizacaoOT.Setciot(value:tciot_tpAutorizacaoOT);
begin
  Fciot := value;
  Fciot_IsSet_ := true;
end;

procedure ttpAutorizacaoOT.Setndot(value:tndot_tpAutorizacaoOT);
begin
  Fndot := value;
  Fndot_IsSet_ := true;
end;

procedure ttpAutorizacaoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpAutorizacaoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fciot) then
  begin
    xn := aNode.addChildByName(sntpAutorizacaoOT_ciot);
    Fciot.Save(xn);
  end;
  if Assigned(Fndot) then
  begin
    xn := aNode.addChildByName(sntpAutorizacaoOT_ndot);
    Fndot.Save(xn);
  end;
end; // procedure save

{ ttpCabecalhoImpressaoRetorno }

function ttpCabecalhoImpressaoRetorno.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCabecalhoImpressaoRetorno._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCabecalhoImpressaoRetorno.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
end; // constructor ...

constructor ttpCabecalhoImpressaoRetorno.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCabecalhoImpressaoRetorno_pontoEmissor) then
      pontoEmissor :=  xn.text // string
    else if (sn = sntpCabecalhoImpressaoRetorno_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpCabecalhoImpressaoRetorno_conteudo) then
      conteudo :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCabecalhoImpressaoRetorno.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  inherited;
end; // destructor ...

procedure ttpCabecalhoImpressaoRetorno.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCabecalhoImpressaoRetorno')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCabecalhoImpressaoRetorno_pontoEmissor));
  xn.text := FpontoEmissor;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpCabecalhoImpressaoRetorno_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCabecalhoImpressaoRetorno_conteudo));
  xn.text := Fconteudo;
end; // procedure save

{ ttpRetornoEncerramentoOT }

function ttpRetornoEncerramentoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoEncerramentoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoEncerramentoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
end; // constructor ...

constructor ttpRetornoEncerramentoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoEncerramentoOT_dataHora) then
      dataHora :=  xn.text // string
    else if (sn = sntpRetornoEncerramentoOT_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpRetornoEncerramentoOT_protocoloEnce) then
      protocoloEnce :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoEncerramentoOT.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  inherited;
end; // destructor ...

procedure ttpRetornoEncerramentoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoEncerramentoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoEncerramentoOT_dataHora));
  xn.text := FdataHora;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpRetornoEncerramentoOT_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoEncerramentoOT_protocoloEnce));
  xn.text := FprotocoloEnce;
end; // procedure save

{ ttpInfEnceOT }

function ttpInfEnceOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfEnceOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfEnceOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
  Fencerramento := tencerramento.Create;
end; // constructor ...

constructor ttpInfEnceOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpInfEnceOT_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfEnceOT_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpInfEnceOT_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpInfEnceOT_encerramento)
      and ((thisURI='') or (tencerramento._nsURI_ = thisURI)) then
      Fencerramento := tencerramento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfEnceOT.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  Fencerramento.Free;
  inherited;
end; // destructor ...

procedure ttpInfEnceOT.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure ttpInfEnceOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfEnceOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpInfEnceOT_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfEnceOT_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpInfEnceOT_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if Assigned(Fencerramento) then
  begin
    xn := aNode.addChildByName(sntpInfEnceOT_encerramento);
    Fencerramento.Save(xn);
  end;
end; // procedure save

{ ttpEncerramentoOT }

function ttpEncerramentoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpEncerramentoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpEncerramentoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfEnceOT := ttpInfEnceOT.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor ttpEncerramentoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpEncerramentoOT_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpEncerramentoOT_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpEncerramentoOT_infEnceOT) then
      FinfEnceOT := ttpInfEnceOT.Create(xn)
    else if (sn = sntpEncerramentoOT_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpEncerramentoOT.Destroy;
begin
  if assigned(FinfEnceOT) then  FinfEnceOT.free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpEncerramentoOT.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpEncerramentoOT.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpEncerramentoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpEncerramentoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpEncerramentoOT_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpEncerramentoOT_token] := Ftoken;

  if Assigned(FinfEnceOT) then
  begin
    xn := aNode.addChildByName(sntpEncerramentoOT_infEnceOT);
    FinfEnceOT.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpEncerramentoOT_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ ttpSolicitarImpressao }

function ttpSolicitarImpressao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpSolicitarImpressao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpSolicitarImpressao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
end; // constructor ...

constructor ttpSolicitarImpressao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpSolicitarImpressao_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpSolicitarImpressao_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpSolicitarImpressao_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpSolicitarImpressao_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpSolicitarImpressao_ptEmissor) then
      ptEmissor :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpSolicitarImpressao.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  inherited;
end; // destructor ...

procedure ttpSolicitarImpressao.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpSolicitarImpressao.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpSolicitarImpressao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpSolicitarImpressao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpSolicitarImpressao_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpSolicitarImpressao_token] := Ftoken;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpSolicitarImpressao_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpSolicitarImpressao_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpSolicitarImpressao_ptEmissor));
  xn.text := FptEmissor;
end; // procedure save

{ tinfPgtoOT }

function tinfPgtoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfPgtoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfPgtoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
end; // constructor ...

constructor tinfPgtoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = aninfPgtoOT_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfPgtoOT_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sninfPgtoOT_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sninfPgtoOT_nomeParcela) then
      nomeParcela :=  xn.text // string
    else if (sn = sninfPgtoOT_motivo) then
      motivo :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfPgtoOT.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  inherited;
end; // destructor ...

procedure tinfPgtoOT.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure tinfPgtoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infPgtoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[aninfPgtoOT_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfPgtoOT_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sninfPgtoOT_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfPgtoOT_nomeParcela));
  xn.text := FnomeParcela;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfPgtoOT_motivo));
  xn.text := Fmotivo;
end; // procedure save

{ ttpPagamentoImediatoOT }

function ttpPagamentoImediatoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpPagamentoImediatoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpPagamentoImediatoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfPgtoOT := tinfPgtoOT.Create;
  //FSignature := tSignature.Create;
end; // constructor ...

constructor ttpPagamentoImediatoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpPagamentoImediatoOT_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpPagamentoImediatoOT_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpPagamentoImediatoOT_infPgtoOT)
      and ((thisURI='') or (tinfPgtoOT._nsURI_ = thisURI)) then
      FinfPgtoOT := tinfPgtoOT.Create(xn)
    else if (sn = sntpPagamentoImediatoOT_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      //FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpPagamentoImediatoOT.Destroy;
begin
  FinfPgtoOT.Free;
 // FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpPagamentoImediatoOT.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpPagamentoImediatoOT.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpPagamentoImediatoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, Copy(Self.ClassName,2,200))
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpPagamentoImediatoOT_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpPagamentoImediatoOT_token] := Ftoken;

  if Assigned(FinfPgtoOT) then
  begin
    xn := aNode.addChildByName(sntpPagamentoImediatoOT_infPgtoOT);
    FinfPgtoOT.Save(xn);
  end;
{  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpPagamentoImediatoOT_Signature);
    FSignature.Save(xn);
  end;}
end; // procedure save

{ ttpRetornoCancelamento }

function ttpRetornoCancelamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoCancelamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoCancelamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
end; // constructor ...

constructor ttpRetornoCancelamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoCancelamento_dataHora) then
      dataHora :=  xn.text // string
    else if (sn = sntpRetornoCancelamento_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpRetornoCancelamento_protocoloCanc) then
      protocoloCanc :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoCancelamento.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  inherited;
end; // destructor ...

procedure ttpRetornoCancelamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoCancelamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoCancelamento_dataHora));
  xn.text := FdataHora;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpRetornoCancelamento_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoCancelamento_protocoloCanc));
  xn.text := FprotocoloCanc;
end; // procedure save

{ tinfCancOT }

function tinfCancOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfCancOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfCancOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
end; // constructor ...

constructor tinfCancOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = aninfCancOT_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfCancOT_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sninfCancOT_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sninfCancOT_motivo) then
      motivo :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfCancOT.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  inherited;
end; // destructor ...

procedure tinfCancOT.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure tinfCancOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infCancOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[aninfCancOT_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfCancOT_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sninfCancOT_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfCancOT_motivo));
  xn.text := Fmotivo;
end; // procedure save

{ ttpCancelamento }

function ttpCancelamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCancelamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCancelamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfCancOT := tinfCancOT.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor ttpCancelamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpCancelamento_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpCancelamento_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCancelamento_infCancOT)
      and ((thisURI='') or (tinfCancOT._nsURI_ = thisURI)) then
      FinfCancOT := tinfCancOT.Create(xn)
    else if (sn = sntpCancelamento_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCancelamento.Destroy;
begin
  FinfCancOT.Free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpCancelamento.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpCancelamento.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpCancelamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCancelamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpCancelamento_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpCancelamento_token] := Ftoken;

  if Assigned(FinfCancOT) then
  begin
    xn := aNode.addChildByName(sntpCancelamento_infCancOT);
    FinfCancOT.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpCancelamento_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ ttpEnderecoComIBGE }

function ttpEnderecoComIBGE.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpEnderecoComIBGE._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpEnderecoComIBGE.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpEnderecoComIBGE.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpEnderecoComIBGE_UF) then
      UF :=  xn.text // string
    else if (sn = sntpEnderecoComIBGE_codigoMunicipio) then
      codigoMunicipio :=  xn.text // string
    else if (sn = sntpEnderecoComIBGE_bairro) then
      bairro :=  xn.text // string
    else if (sn = sntpEnderecoComIBGE_logradouro) then
      logradouro :=  xn.text // string
    else if (sn = sntpEnderecoComIBGE_numero) then
      numero :=  xn.text // string
    else if (sn = sntpEnderecoComIBGE_CEP) then
      CEP :=  xn.text // string
    else if (sn = sntpEnderecoComIBGE_complemento) then
      complemento :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpEnderecoComIBGE.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpEnderecoComIBGE.Setcomplemento(value:string);
begin
  Fcomplemento := value;
  Fcomplemento_IsSet_ := value<>'';
end;

procedure ttpEnderecoComIBGE.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpEnderecoComIBGE')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoComIBGE_UF));
  xn.text := FUF;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoComIBGE_codigoMunicipio));
  xn.text := FcodigoMunicipio;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoComIBGE_bairro));
  xn.text := Fbairro;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoComIBGE_logradouro));
  xn.text := Flogradouro;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoComIBGE_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoComIBGE_CEP));
  xn.text := FCEP;
  if complemento_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoComIBGE_complemento));
    xn.text := Fcomplemento;
  end;
end; // procedure save

{ ttpSubcontratado }

function ttpSubcontratado.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpSubcontratado._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpSubcontratado.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoComIBGE.Create;
end; // constructor ...

constructor ttpSubcontratado.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpSubcontratado_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpSubcontratado_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntpSubcontratado_nome) then
      nome :=  xn.text // string
    else if (sn = sntpSubcontratado_endereco) then
      Fendereco := ttpEnderecoComIBGE.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpSubcontratado.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpSubcontratado.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := true;
end;

procedure ttpSubcontratado.Setcpf(value:string);
begin
  Fcpf := value;
  Fcpf_IsSet_ := true;
end;

procedure ttpSubcontratado.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpSubcontratado')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpSubcontratado_cnpj));
    xn.text := Fcnpj;
  end;
  if cpf_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpSubcontratado_cpf));
    xn.text := Fcpf;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpSubcontratado_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpSubcontratado_endereco);
    Fendereco.Save(xn);
  end;
end; // procedure save

{ ttpDestinatario }

function ttpDestinatario.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDestinatario._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDestinatario.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoComIBGE.Create;
end; // constructor ...

constructor ttpDestinatario.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDestinatario_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpDestinatario_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntpDestinatario_nome) then
      nome :=  xn.text // string
    else if (sn = sntpDestinatario_endereco) then
      Fendereco := ttpEnderecoComIBGE.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDestinatario.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpDestinatario.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := true;
end;

procedure ttpDestinatario.Setcpf(value:string);
begin
  Fcpf := value;
  Fcpf_IsSet_ := true;
end;

procedure ttpDestinatario.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDestinatario')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDestinatario_cnpj));
    xn.text := Fcnpj;
  end;
  if cpf_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDestinatario_cpf));
    xn.text := Fcpf;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDestinatario_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpDestinatario_endereco);
    Fendereco.Save(xn);
  end;
end; // procedure save

{ ttpEnderecoSemIBGE }

function ttpEnderecoSemIBGE.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpEnderecoSemIBGE._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpEnderecoSemIBGE.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpEnderecoSemIBGE.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpEnderecoSemIBGE_UF) then
      UF :=  xn.text // string
    else if (sn = sntpEnderecoSemIBGE_cidade) then
      cidade :=  xn.text // string
    else if (sn = sntpEnderecoSemIBGE_bairro) then
      bairro :=  xn.text // string
    else if (sn = sntpEnderecoSemIBGE_logradouro) then
      logradouro :=  xn.text // string
    else if (sn = sntpEnderecoSemIBGE_numero) then
      numero :=  xn.text // string
    else if (sn = sntpEnderecoSemIBGE_CEP) then
      CEP :=  xn.text // string
    else if (sn = sntpEnderecoSemIBGE_complemento) then
      complemento :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpEnderecoSemIBGE.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpEnderecoSemIBGE.Setnumero(value:string);
begin
  Fnumero := value;
  Fnumero_IsSet_ := true;
end;

procedure ttpEnderecoSemIBGE.SetCEP(value:string);
begin
  FCEP := value;
  FCEP_IsSet_ := true;
end;

procedure ttpEnderecoSemIBGE.Setcomplemento(value:string);
begin
  Fcomplemento := value;
  Fcomplemento_IsSet_ := value<>'';
end;

procedure ttpEnderecoSemIBGE.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpEnderecoSemIBGE')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoSemIBGE_UF));
  xn.text := FUF;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoSemIBGE_cidade));
  xn.text := Fcidade;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoSemIBGE_bairro));
  xn.text := Fbairro;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoSemIBGE_logradouro));
  xn.text := Flogradouro;
  if numero_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoSemIBGE_numero));
    xn.text := Fnumero;
  end;
  if CEP_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoSemIBGE_CEP));
    xn.text := FCEP;
  end;
  if complemento_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpEnderecoSemIBGE_complemento));
    xn.text := Fcomplemento;
  end;
end; // procedure save

{ testabelecimento_pagamentoPedagio }

function testabelecimento_pagamentoPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function testabelecimento_pagamentoPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor testabelecimento_pagamentoPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoSemIBGE.Create;
end; // constructor ...

constructor testabelecimento_pagamentoPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snestabelecimento_pagamentoPedagio_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = snestabelecimento_pagamentoPedagio_nome) then
      nome :=  xn.text // string
    else if (sn = snestabelecimento_pagamentoPedagio_endereco) then
      Fendereco := ttpEnderecoSemIBGE.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor testabelecimento_pagamentoPedagio.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure testabelecimento_pagamentoPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'estabelecimento_pagamentoPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snestabelecimento_pagamentoPedagio_cnpj));
  xn.text := Fcnpj;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snestabelecimento_pagamentoPedagio_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(snestabelecimento_pagamentoPedagio_endereco);
    Fendereco.Save(xn);
  end;
end; // procedure save

{ tpagamentoPedagio }

function tpagamentoPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpagamentoPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpagamentoPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Festabelecimento := testabelecimento_pagamentoPedagio.Create;
end; // constructor ...

constructor tpagamentoPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpagamentoPedagio_dataPagamentoPedagio) then
      dataPagamentoPedagio :=  xn.text // string
    else if (sn = snpagamentoPedagio_estabelecimento)
      and ((thisURI='') or (testabelecimento._nsURI_ = thisURI)) then
      Festabelecimento := testabelecimento_pagamentoPedagio.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpagamentoPedagio.Destroy;
begin
  Festabelecimento.Free;
  inherited;
end; // destructor ...

procedure tpagamentoPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pagamentoPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpagamentoPedagio_dataPagamentoPedagio));
  xn.text := FdataPagamentoPedagio;
  if Assigned(Festabelecimento) then
  begin
    xn := aNode.addChildByName(snpagamentoPedagio_estabelecimento);
    Festabelecimento.Save(xn);
  end;
end; // procedure save

{ testabelecimento }

function testabelecimento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function testabelecimento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor testabelecimento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoSemIBGE.Create;
end; // constructor ...

constructor testabelecimento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snestabelecimento_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = snestabelecimento_nome) then
      nome :=  xn.text // string
    else if (sn = snestabelecimento_endereco) then
      Fendereco := ttpEnderecoSemIBGE.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor testabelecimento.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure testabelecimento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'estabelecimento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snestabelecimento_cnpj));
  xn.text := Fcnpj;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snestabelecimento_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(snestabelecimento_endereco);
    Fendereco.Save(xn);
  end;
end; // procedure save

{ tpedagio_tpPgto }

function tpedagio_tpPgto.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpedagio_tpPgto._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpedagio_tpPgto.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Festabelecimento := testabelecimento.Create;
end; // constructor ...

constructor tpedagio_tpPgto.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpedagio_tpPgto_valorPago) then
      valorPago :=  xn.text // string
    else if (sn = snpedagio_tpPgto_estabelecimento)
      and ((thisURI='') or (testabelecimento._nsURI_ = thisURI)) then
      Festabelecimento := testabelecimento.Create(xn)
    else if (sn = snpedagio_tpPgto_cpfRecebedor) then
      cpfRecebedor :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpedagio_tpPgto.Destroy;
begin
  Festabelecimento.Free;
  inherited;
end; // destructor ...

procedure tpedagio_tpPgto.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pedagio_tpPgto')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpedagio_tpPgto_valorPago));
  xn.text := FvalorPago;
  if Assigned(Festabelecimento) then
  begin
    xn := aNode.addChildByName(snpedagio_tpPgto_estabelecimento);
    Festabelecimento.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpedagio_tpPgto_cpfRecebedor));
  xn.text := FcpfRecebedor;
end; // procedure save

{ ttpRetornoPessoa }

function ttpRetornoPessoa.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoPessoa._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoPessoa.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoSemIBGE.Create;
end; // constructor ...

constructor ttpRetornoPessoa.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoPessoa_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntpRetornoPessoa_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpRetornoPessoa_nome) then
      nome :=  xn.text // string
    else if (sn = sntpRetornoPessoa_endereco) then
      Fendereco := ttpEnderecoSemIBGE.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoPessoa.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpRetornoPessoa.Setcpf(value:string);
begin
  Fcpf := value;
  Fcpf_IsSet_ := true;
end;

procedure ttpRetornoPessoa.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := true;
end;

procedure ttpRetornoPessoa.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoPessoa')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if cpf_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPessoa_cpf));
    xn.text := Fcpf;
  end;
  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPessoa_cnpj));
    xn.text := Fcnpj;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPessoa_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpRetornoPessoa_endereco);
    Fendereco.Save(xn);
  end;
end; // procedure save

{ ttpRetornoPessoaJuridica }

function ttpRetornoPessoaJuridica.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoPessoaJuridica._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoPessoaJuridica.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoSemIBGE.Create;
end; // constructor ...

constructor ttpRetornoPessoaJuridica.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoPessoaJuridica_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpRetornoPessoaJuridica_nome) then
      nome :=  xn.text // string
    else if (sn = sntpRetornoPessoaJuridica_endereco) then
      Fendereco := ttpEnderecoSemIBGE.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoPessoaJuridica.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpRetornoPessoaJuridica.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoPessoaJuridica')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPessoaJuridica_cnpj));
  xn.text := Fcnpj;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPessoaJuridica_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpRetornoPessoaJuridica_endereco);
    Fendereco.Save(xn);
  end;
end; // procedure save

{ tefetivacao }

function tefetivacao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tefetivacao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tefetivacao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tefetivacao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snefetivacao_postoCredenciado) then
      postoCredenciado := ttpRetornoPessoaJuridica.Create(xn)
    else if (sn = snefetivacao_centroTriagem) then
      centroTriagem := ttpRetornoPessoaJuridica.Create(xn)
    else if (sn = snefetivacao_contratante) then
      contratante := ttpRetornoPessoaJuridica.Create(xn)
    else if (sn = snefetivacao_confirmacaoEletronica) then
      confirmacaoEletronica := ttpRetornoPessoa.Create(xn)
    else if (sn = snefetivacao_automatica)
      and ((thisURI='') or (tautomatica._nsURI_ = thisURI)) then
      automatica := tautomatica.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tefetivacao.Destroy;
begin
  if assigned(FpostoCredenciado) then  FpostoCredenciado.free;
  if assigned(FcentroTriagem) then  FcentroTriagem.free;
  if assigned(Fcontratante) then  Fcontratante.free;
  if assigned(FconfirmacaoEletronica) then  FconfirmacaoEletronica.free;
  Fautomatica.Free;
  inherited;
end; // destructor ...

procedure tefetivacao.SetpostoCredenciado(value:ttpRetornoPessoaJuridica);
begin
  FpostoCredenciado := value;
  FpostoCredenciado_IsSet_ := true;
end;

procedure tefetivacao.SetcentroTriagem(value:ttpRetornoPessoaJuridica);
begin
  FcentroTriagem := value;
  FcentroTriagem_IsSet_ := true;
end;

procedure tefetivacao.Setcontratante(value:ttpRetornoPessoaJuridica);
begin
  Fcontratante := value;
  Fcontratante_IsSet_ := true;
end;

procedure tefetivacao.SetconfirmacaoEletronica(value:ttpRetornoPessoa);
begin
  FconfirmacaoEletronica := value;
  FconfirmacaoEletronica_IsSet_ := true;
end;

procedure tefetivacao.Setautomatica(value:tautomatica);
begin
  Fautomatica := value;
  Fautomatica_IsSet_ := true;
end;

procedure tefetivacao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'efetivacao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FpostoCredenciado) then
  begin
    xn := aNode.addChildByName(snefetivacao_postoCredenciado);
    FpostoCredenciado.Save(xn);
  end;
  if Assigned(FcentroTriagem) then
  begin
    xn := aNode.addChildByName(snefetivacao_centroTriagem);
    FcentroTriagem.Save(xn);
  end;
  if Assigned(Fcontratante) then
  begin
    xn := aNode.addChildByName(snefetivacao_contratante);
    Fcontratante.Save(xn);
  end;
  if Assigned(FconfirmacaoEletronica) then
  begin
    xn := aNode.addChildByName(snefetivacao_confirmacaoEletronica);
    FconfirmacaoEletronica.Save(xn);
  end;
  if Assigned(Fautomatica) then
  begin
    xn := aNode.addChildByName(snefetivacao_automatica);
    Fautomatica.Save(xn);
  end;
end; // procedure save

{ tparcela }

function tparcela.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tparcela._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tparcela.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fefetivacao := tefetivacao.Create;
end; // constructor ...

constructor tparcela.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snparcela_nome) then
      nome :=  xn.text // string
    else if (sn = snparcela_valorPago) then
      valorPago :=  xn.text // string
    else if (sn = snparcela_efetivacao)
      and ((thisURI='') or (tefetivacao._nsURI_ = thisURI)) then
      Fefetivacao := tefetivacao.Create(xn)
    else if (sn = snparcela_comentario) then
      comentario :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tparcela.Destroy;
begin
  Fefetivacao.Free;
  inherited;
end; // destructor ...

procedure tparcela.Setcomentario(value:string);
begin
  Fcomentario := value;
  Fcomentario_IsSet_ := true;
end;

procedure tparcela.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'parcela')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_valorPago));
  xn.text := FvalorPago;
  if Assigned(Fefetivacao) then
  begin
    xn := aNode.addChildByName(snparcela_efetivacao);
    Fefetivacao.Save(xn);
  end;
  if comentario_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcela_comentario));
    xn.text := Fcomentario;
  end;
end; // procedure save

{ tparcelas_frete }

function tparcelas_frete.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tparcelas_frete._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tparcelas_frete.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fparcela := tManagedStringlist.Create;
end; // constructor ...

constructor tparcelas_frete.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aparcela: tparcela;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snparcelas_frete_parcela)
      and ((thisURI='') or (tparcela._nsURI_ = thisURI)) then
    begin
      aparcela := tparcela.Create(xn);
      Fparcela.AddObject('?', aparcela);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tparcelas_frete.Destroy;
begin
  Fparcela.Free;
  inherited;
end; // destructor ...

procedure tparcelas_frete.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'parcelas_frete')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "parcela" is tManagedStringlist
  if Assigned(Fparcela) then
    for i:=0 to Fparcela.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snparcelas_frete_parcela));
      tparcela(Fparcela.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tfrete }

function tfrete.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tfrete._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tfrete.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fparcelas := tparcelas_frete.Create;
end; // constructor ...

constructor tfrete.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snfrete_parcelas)
      and ((thisURI='') or (tparcelas._nsURI_ = thisURI)) then
      Fparcelas := tparcelas_frete.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tfrete.Destroy;
begin
  Fparcelas.Free;
  inherited;
end; // destructor ...

procedure tfrete.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'frete')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fparcelas) then
  begin
    xn := aNode.addChildByName(snfrete_parcelas);
    Fparcelas.Save(xn);
  end;
end; // procedure save

{ ttpPgto }

function ttpPgto.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpPgto._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpPgto.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
end; // constructor ...

constructor ttpPgto.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpPgto_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpPgto_dataHora) then
      dataHora :=  xn.text // string
    else if (sn = sntpPgto_pedagio)
      and ((thisURI='') or (tpedagio._nsURI_ = thisURI)) then
      pedagio := tpedagio_tpPgto.Create(xn)
    else if (sn = sntpPgto_frete)
      and ((thisURI='') or (tfrete._nsURI_ = thisURI)) then
      frete := tfrete.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpPgto.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  Fpedagio.Free;
  Ffrete.Free;
  inherited;
end; // destructor ...

procedure ttpPgto.Setpedagio(value:tpedagio_tpPgto);
begin
  Fpedagio := value;
  Fpedagio_IsSet_ := true;
end;

procedure ttpPgto.Setfrete(value:tfrete);
begin
  Ffrete := value;
  Ffrete_IsSet_ := true;
end;

procedure ttpPgto.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpPgto')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpPgto_autorizacao);
    Fautorizacao.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpPgto_dataHora));
  xn.text := FdataHora;
  if Assigned(Fpedagio) then
  begin
    xn := aNode.addChildByName(sntpPgto_pedagio);
    Fpedagio.Save(xn);
  end;
  if Assigned(Ffrete) then
  begin
    xn := aNode.addChildByName(sntpPgto_frete);
    Ffrete.Save(xn);
  end;
end; // procedure save

{ tpgtos }

function tpgtos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpgtos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpgtos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fpgto := tManagedStringlist.Create;
end; // constructor ...

constructor tpgtos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpgtos_pgto) then
    begin
      // list of simple type
      Fpgto.AddObject('?', ttpPgto.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpgtos.Destroy;
begin
  Fpgto.Free;
  inherited;
end; // destructor ...

procedure tpgtos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pgtos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "pgto" is tManagedStringlist
  if Assigned(Fpgto) then
    for i:=0 to Fpgto.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpgtos_pgto));
      ttpPgto(Fpgto.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRemetente }

function ttpRemetente.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRemetente._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRemetente.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoComIBGE.Create;
end; // constructor ...

constructor ttpRemetente.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRemetente_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpRemetente_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntpRemetente_nome) then
      nome :=  xn.text // string
    else if (sn = sntpRemetente_endereco) then
      Fendereco := ttpEnderecoComIBGE.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRemetente.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpRemetente.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := true;
end;

procedure ttpRemetente.Setcpf(value:string);
begin
  Fcpf := value;
  Fcpf_IsSet_ := true;
end;

procedure ttpRemetente.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRemetente')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRemetente_cnpj));
    xn.text := Fcnpj;
  end;
  if cpf_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRemetente_cpf));
    xn.text := Fcpf;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRemetente_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpRemetente_endereco);
    Fendereco.Save(xn);
  end;
end; // procedure save

{ ttpConsignatario }

function ttpConsignatario.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpConsignatario._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpConsignatario.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoComIBGE.Create;
end; // constructor ...

constructor ttpConsignatario.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpConsignatario_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpConsignatario_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntpConsignatario_nome) then
      nome :=  xn.text // string
    else if (sn = sntpConsignatario_endereco) then
      Fendereco := ttpEnderecoComIBGE.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpConsignatario.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpConsignatario.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := true;
end;

procedure ttpConsignatario.Setcpf(value:string);
begin
  Fcpf := value;
  Fcpf_IsSet_ := true;
end;

procedure ttpConsignatario.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpConsignatario')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsignatario_cnpj));
    xn.text := Fcnpj;
  end;
  if cpf_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsignatario_cpf));
    xn.text := Fcpf;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpConsignatario_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpConsignatario_endereco);
    Fendereco.Save(xn);
  end;
end; // procedure save

{ ttpContato }

function ttpContato.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpContato._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpContato.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpContato.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpContato_nome) then
      nome :=  xn.text // string
    else if (sn = sntpContato_contato) then
      contato :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpContato.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpContato.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpContato')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpContato_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpContato_contato));
  xn.text := Fcontato;
end; // procedure save

{ tdocumentoOriginario }

function tdocumentoOriginario.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdocumentoOriginario._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdocumentoOriginario.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tdocumentoOriginario.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndocumentoOriginario_tipo) then
      tipo :=  xn.text // string
    else if (sn = sndocumentoOriginario_numero) then
      numero :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdocumentoOriginario.Destroy;
begin
  inherited;
end; // destructor ...

procedure tdocumentoOriginario.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'documentoOriginario')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndocumentoOriginario_tipo));
  xn.text := Ftipo;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndocumentoOriginario_numero));
  xn.text := Fnumero;
end; // procedure save

{ tdocumentosOriginarios }

function tdocumentosOriginarios.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdocumentosOriginarios._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdocumentosOriginarios.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FdocumentoOriginario := tManagedStringlist.Create;
end; // constructor ...

constructor tdocumentosOriginarios.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  adocumentoOriginario: tdocumentoOriginario;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndocumentosOriginarios_documentoOriginario)
      and ((thisURI='') or (tdocumentoOriginario._nsURI_ = thisURI)) then
    begin
      adocumentoOriginario := tdocumentoOriginario.Create(xn);
      FdocumentoOriginario.AddObject('?', adocumentoOriginario);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdocumentosOriginarios.Destroy;
begin
  FdocumentoOriginario.Free;
  inherited;
end; // destructor ...

procedure tdocumentosOriginarios.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'documentosOriginarios')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "documentoOriginario" is tManagedStringlist
  if Assigned(FdocumentoOriginario) then
    for i:=0 to FdocumentoOriginario.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndocumentosOriginarios_documentoOriginario));
      tdocumentoOriginario(FdocumentoOriginario.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tTACagregado }

function tTACagregado.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tTACagregado._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tTACagregado.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fremetente := ttpRemetente.Create;
end; // constructor ...

constructor tTACagregado.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snTACagregado_remetente) then
      Fremetente := ttpRemetente.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tTACagregado.Destroy;
begin
  if assigned(Fremetente) then  Fremetente.free;
  inherited;
end; // destructor ...

procedure tTACagregado.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'TACagregado')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fremetente) then
  begin
    xn := aNode.addChildByName(snTACagregado_remetente);
    Fremetente.Save(xn);
  end;
end; // procedure save

{ tpadrao }

function tpadrao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpadrao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpadrao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fremetente := ttpRemetente.Create;
  Fdestinatario := ttpDestinatario.Create;
end; // constructor ...

constructor tpadrao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpadrao_codigoSH) then
      codigoSH :=  xn.text // string
    else if (sn = snpadrao_quantidade) then
      quantidade :=  xn.text // string
    else if (sn = snpadrao_remetente) then
      Fremetente := ttpRemetente.Create(xn)
    else if (sn = snpadrao_destinatario) then
      Fdestinatario := ttpDestinatario.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpadrao.Destroy;
begin
  if assigned(Fremetente) then  Fremetente.free;
  if assigned(Fdestinatario) then  Fdestinatario.free;
  inherited;
end; // destructor ...

procedure tpadrao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'padrao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpadrao_codigoSH));
  xn.text := FcodigoSH;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpadrao_quantidade));
  xn.text := Fquantidade;
  if Assigned(Fremetente) then
  begin
    xn := aNode.addChildByName(snpadrao_remetente);
    Fremetente.Save(xn);
  end;
  if Assigned(Fdestinatario) then
  begin
    xn := aNode.addChildByName(snpadrao_destinatario);
    Fdestinatario.Save(xn);
  end;
end; // procedure save

{ ttpCarga }

function ttpCarga.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCarga._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCarga.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpCarga.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCarga_padrao)
      and ((thisURI='') or (tpadrao._nsURI_ = thisURI)) then
      padrao := tpadrao.Create(xn)
    else if (sn = sntpCarga_TACagregado)
      and ((thisURI='') or (tTACagregado._nsURI_ = thisURI)) then
      TACagregado := tTACagregado.Create(xn)
    else if (sn = sntpCarga_consignatario) then
      consignatario := ttpConsignatario.Create(xn)
    else if (sn = sntpCarga_proprietarioCarga) then
      proprietarioCarga :=  xn.text // tbyte
    else if (sn = sntpCarga_documentosOriginarios)
      and ((thisURI='') or (tdocumentosOriginarios._nsURI_ = thisURI)) then
      documentosOriginarios := tdocumentosOriginarios.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCarga.Destroy;
begin
  Fpadrao.Free;
  FTACagregado.Free;
  if assigned(Fconsignatario) then  Fconsignatario.free;
  FdocumentosOriginarios.Free;
  inherited;
end; // destructor ...

procedure ttpCarga.Setpadrao(value:tpadrao);
begin
  Fpadrao := value;
  Fpadrao_IsSet_ := true;
end;

procedure ttpCarga.SetTACagregado(value:tTACagregado);
begin
  FTACagregado := value;
  FTACagregado_IsSet_ := true;
end;

procedure ttpCarga.Setconsignatario(value:ttpConsignatario);
begin
  Fconsignatario := value;
  Fconsignatario_IsSet_ := true;
end;

procedure ttpCarga.SetdocumentosOriginarios(value:tdocumentosOriginarios);
begin
  FdocumentosOriginarios := value;
  FdocumentosOriginarios_IsSet_ := true;
end;

procedure ttpCarga.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCarga')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fpadrao) then
  begin
    xn := aNode.addChildByName(sntpCarga_padrao);
    Fpadrao.Save(xn);
  end;
  if Assigned(FTACagregado) then
  begin
    xn := aNode.addChildByName(sntpCarga_TACagregado);
    FTACagregado.Save(xn);
  end;
  if Assigned(Fconsignatario) then
  begin
    xn := aNode.addChildByName(sntpCarga_consignatario);
    Fconsignatario.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCarga_proprietarioCarga));
  xn.text := FproprietarioCarga;
  if Assigned(FdocumentosOriginarios) then
  begin
    xn := aNode.addChildByName(sntpCarga_documentosOriginarios);
    FdocumentosOriginarios.Save(xn);
  end;
end; // procedure save

{ ttpCondutor }

function ttpCondutor.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCondutor._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCondutor.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoSemIBGE.Create;
end; // constructor ...

constructor ttpCondutor.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCondutor_nome) then
      nome :=  xn.text // string
    else if (sn = sntpCondutor_identidade) then
      identidade :=  xn.text // string
    else if (sn = sntpCondutor_RNTRCTransportador) then
      RNTRCTransportador :=  xn.text // string
    else if (sn = sntpCondutor_endereco) then
      Fendereco := ttpEnderecoSemIBGE.Create(xn)
    else if (sn = sntpCondutor_CNH) then
      CNH := StrToInt64Def(xn.text, 0)
    else if (sn = sntpCondutor_dataEmissaoCNH) then
      dataEmissaoCNH :=  xn.text // string
    else if (sn = sntpCondutor_dataRenovacaoCNH) then
      dataRenovacaoCNH :=  xn.text // string
    else if (sn = sntpCondutor_telefone) then
      telefone := StrToInt64Def(xn.text, 0)
    else if (sn = sntpCondutor_cartaoId) then
      cartaoId := StrToInt64Def(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCondutor.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpCondutor.SetRNTRCTransportador(value:string);
begin
  FRNTRCTransportador := value;
  FRNTRCTransportador_IsSet_ := true;
end;

procedure ttpCondutor.SetCNH(value:int64);
begin
  FCNH := value;
  FCNH_IsSet_ := true;
end;

procedure ttpCondutor.SetdataEmissaoCNH(value:string);
begin
  FdataEmissaoCNH := value;
  FdataEmissaoCNH_IsSet_ := true;
end;

procedure ttpCondutor.SetdataRenovacaoCNH(value:string);
begin
  FdataRenovacaoCNH := value;
  FdataRenovacaoCNH_IsSet_ := true;
end;

procedure ttpCondutor.SetcartaoId(value:int64);
begin
  FcartaoId := value;
  FcartaoId_IsSet_ := true;
end;

procedure ttpCondutor.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCondutor')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCondutor_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCondutor_identidade));
  xn.text := Fidentidade;
  if RNTRCTransportador_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCondutor_RNTRCTransportador));
    xn.text := FRNTRCTransportador;
  end;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpCondutor_endereco);
    Fendereco.Save(xn);
  end;
  if CNH_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCondutor_CNH));
    xn.text := IntToStr(FCNH);
  end;
  if dataEmissaoCNH_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCondutor_dataEmissaoCNH));
    xn.text := FdataEmissaoCNH;
  end;
  if dataRenovacaoCNH_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCondutor_dataRenovacaoCNH));
    xn.text := FdataRenovacaoCNH;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCondutor_telefone));
  xn.text := IntToStr(Ftelefone);
  if cartaoId_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCondutor_cartaoId));
    xn.text := IntToStr(FcartaoId);
  end;
end; // procedure save

{ tinfCondutor }

function tinfCondutor.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfCondutor._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfCondutor.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tinfCondutor.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfCondutor_cpf) then
      cpf :=  xn.text // string
    else if (sn = sninfCondutor_informacoes) then
      informacoes := ttpCondutor.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfCondutor.Destroy;
begin
  if assigned(Finformacoes) then  Finformacoes.free;
  inherited;
end; // destructor ...

procedure tinfCondutor.Setinformacoes(value:ttpCondutor);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure tinfCondutor.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infCondutor')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfCondutor_cpf));
  xn.text := Fcpf;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(sninfCondutor_informacoes);
    Finformacoes.Save(xn);
  end;
end; // procedure save

{ tcondutor_alteracao }

function tcondutor_alteracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcondutor_alteracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcondutor_alteracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfCondutor := tinfCondutor.Create;
end; // constructor ...

constructor tcondutor_alteracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncondutor_alteracao_tipo) then
      tipo :=  xn.text // tbyte
    else if (sn = sncondutor_alteracao_infCondutor)
      and ((thisURI='') or (tinfCondutor._nsURI_ = thisURI)) then
      FinfCondutor := tinfCondutor.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcondutor_alteracao.Destroy;
begin
  FinfCondutor.Free;
  inherited;
end; // destructor ...

procedure tcondutor_alteracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'condutor_alteracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncondutor_alteracao_tipo));
  xn.text := Ftipo;
  if Assigned(FinfCondutor) then
  begin
    xn := aNode.addChildByName(sncondutor_alteracao_infCondutor);
    FinfCondutor.Save(xn);
  end;
end; // procedure save

{ ttpVeiculo }

function ttpVeiculo.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpVeiculo._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpVeiculo.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpVeiculo.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpVeiculo_modelo) then
      modelo :=  xn.text // string
    else if (sn = sntpVeiculo_kmLitroModelo) then
      kmLitroModelo :=  xn.text // string
    else if (sn = sntpVeiculo_tipo) then
      tipo :=  xn.text // tbyte
    else if (sn = sntpVeiculo_kmLitroVeiculo) then
      kmLitroVeiculo :=  xn.text // string
    else if (sn = sntpVeiculo_RNTRCTransportador) then
      RNTRCTransportador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpVeiculo.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpVeiculo.SetkmLitroModelo(value:string);
begin
  FkmLitroModelo := value;
  FkmLitroModelo_IsSet_ := true;
end;

procedure ttpVeiculo.SetkmLitroVeiculo(value:string);
begin
  FkmLitroVeiculo := value;
  FkmLitroVeiculo_IsSet_ := true;
end;

procedure ttpVeiculo.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpVeiculo')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpVeiculo_modelo));
  xn.text := Fmodelo;
  if kmLitroModelo_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpVeiculo_kmLitroModelo));
    xn.text := FkmLitroModelo;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpVeiculo_tipo));
  xn.text := Ftipo;
  if kmLitroVeiculo_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpVeiculo_kmLitroVeiculo));
    xn.text := FkmLitroVeiculo;
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpVeiculo_RNTRCTransportador));
  xn.text := FRNTRCTransportador;
end; // procedure save

{ tveiculo_veiculos_TACagregado_ANTT }

function tveiculo_veiculos_TACagregado_ANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculo_veiculos_TACagregado_ANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculo_veiculos_TACagregado_ANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tveiculo_veiculos_TACagregado_ANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculo_veiculos_TACagregado_ANTT_placa) then
      placa :=  xn.text // string
    else if (sn = snveiculo_veiculos_TACagregado_ANTT_informacoes) then
      informacoes := ttpVeiculo.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculo_veiculos_TACagregado_ANTT.Destroy;
begin
  if assigned(Finformacoes) then  Finformacoes.free;
  inherited;
end; // destructor ...

procedure tveiculo_veiculos_TACagregado_ANTT.Setinformacoes(value:ttpVeiculo);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure tveiculo_veiculos_TACagregado_ANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculo_veiculos_TACagregado_ANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculo_veiculos_TACagregado_ANTT_placa));
  xn.text := Fplaca;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(snveiculo_veiculos_TACagregado_ANTT_informacoes);
    Finformacoes.Save(xn);
  end;
end; // procedure save

{ tveiculos_TACagregado_ANTT }

function tveiculos_TACagregado_ANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculos_TACagregado_ANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculos_TACagregado_ANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fveiculo := tManagedStringlist.Create;
end; // constructor ...

constructor tveiculos_TACagregado_ANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aveiculo: tveiculo;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculos_TACagregado_ANTT_veiculo)
      and ((thisURI='') or (tveiculo._nsURI_ = thisURI)) then
    begin
      aveiculo := tveiculo.Create(xn);
      Fveiculo.AddObject('?', aveiculo);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculos_TACagregado_ANTT.Destroy;
begin
  Fveiculo.Free;
  inherited;
end; // destructor ...

procedure tveiculos_TACagregado_ANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculos_TACagregado_ANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "veiculo" is tManagedStringlist
  if Assigned(Fveiculo) then
    for i:=0 to Fveiculo.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculos_TACagregado_ANTT_veiculo));
      tveiculo_veiculos_TACagregado_ANTT(Fveiculo.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tTACagregado_ANTT }

function tTACagregado_ANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tTACagregado_ANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tTACagregado_ANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tTACagregado_ANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snTACagregado_ANTT_veiculos)
      and ((thisURI='') or (tveiculos._nsURI_ = thisURI)) then
      veiculos := tveiculos_TACagregado_ANTT.Create(xn)
    else if (sn = snTACagregado_ANTT_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tTACagregado_ANTT.Destroy;
begin
  Fveiculos.Free;
  inherited;
end; // destructor ...

procedure tTACagregado_ANTT.Setveiculos(value:tveiculos_TACagregado_ANTT);
begin
  Fveiculos := value;
  Fveiculos_IsSet_ := true;
end;

procedure tTACagregado_ANTT.SetcategoriaPedagio(value:integer);
begin
  FcategoriaPedagio := value;
  FcategoriaPedagio_IsSet_ := true;
end;

procedure tTACagregado_ANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'TACagregado_ANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fveiculos) then
  begin
    xn := aNode.addChildByName(snTACagregado_ANTT_veiculos);
    Fveiculos.Save(xn);
  end;
  if categoriaPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snTACagregado_ANTT_categoriaPedagio));
    xn.text := IntToStr(FcategoriaPedagio);
  end;
end; // procedure save

{ tveiculo_veiculos_depois24hrs }

function tveiculo_veiculos_depois24hrs.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculo_veiculos_depois24hrs._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculo_veiculos_depois24hrs.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tveiculo_veiculos_depois24hrs.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculo_veiculos_depois24hrs_placa) then
      placa :=  xn.text // string
    else if (sn = snveiculo_veiculos_depois24hrs_informacoes) then
      informacoes := ttpVeiculo.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculo_veiculos_depois24hrs.Destroy;
begin
  if assigned(Finformacoes) then  Finformacoes.free;
  inherited;
end; // destructor ...

procedure tveiculo_veiculos_depois24hrs.Setinformacoes(value:ttpVeiculo);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure tveiculo_veiculos_depois24hrs.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculo_veiculos_depois24hrs')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculo_veiculos_depois24hrs_placa));
  xn.text := Fplaca;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(snveiculo_veiculos_depois24hrs_informacoes);
    Finformacoes.Save(xn);
  end;
end; // procedure save

{ tveiculos_depois24hrs }

function tveiculos_depois24hrs.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculos_depois24hrs._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculos_depois24hrs.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fveiculo := tManagedStringlist.Create;
end; // constructor ...

constructor tveiculos_depois24hrs.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aveiculo: tveiculo;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculos_depois24hrs_veiculo)
      and ((thisURI='') or (tveiculo._nsURI_ = thisURI)) then
    begin
      aveiculo := tveiculo.Create(xn);
      Fveiculo.AddObject('?', aveiculo);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculos_depois24hrs.Destroy;
begin
  Fveiculo.Free;
  inherited;
end; // destructor ...

procedure tveiculos_depois24hrs.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculos_depois24hrs')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "veiculo" is tManagedStringlist
  if Assigned(Fveiculo) then
    for i:=0 to Fveiculo.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculos_depois24hrs_veiculo));
      tveiculo_veiculos_depois24hrs(Fveiculo.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tdepois24hrs }

function tdepois24hrs.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdepois24hrs._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdepois24hrs.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tdepois24hrs.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndepois24hrs_veiculos)
      and ((thisURI='') or (tveiculos._nsURI_ = thisURI)) then
      veiculos := tveiculos_depois24hrs.Create(xn)
    else if (sn = sndepois24hrs_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdepois24hrs.Destroy;
begin
  Fveiculos.Free;
  inherited;
end; // destructor ...

procedure tdepois24hrs.Setveiculos(value:tveiculos_depois24hrs);
begin
  Fveiculos := value;
  Fveiculos_IsSet_ := true;
end;

procedure tdepois24hrs.SetcategoriaPedagio(value:integer);
begin
  FcategoriaPedagio := value;
  FcategoriaPedagio_IsSet_ := true;
end;

procedure tdepois24hrs.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'depois24hrs')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fveiculos) then
  begin
    xn := aNode.addChildByName(sndepois24hrs_veiculos);
    Fveiculos.Save(xn);
  end;
  if categoriaPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndepois24hrs_categoriaPedagio));
    xn.text := IntToStr(FcategoriaPedagio);
  end;
end; // procedure save

{ tveiculo_veiculos_ate24hrs }

function tveiculo_veiculos_ate24hrs.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculo_veiculos_ate24hrs._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculo_veiculos_ate24hrs.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tveiculo_veiculos_ate24hrs.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculo_veiculos_ate24hrs_placa) then
      placa :=  xn.text // string
    else if (sn = snveiculo_veiculos_ate24hrs_informacoes) then
      informacoes := ttpVeiculo.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculo_veiculos_ate24hrs.Destroy;
begin
  if assigned(Finformacoes) then  Finformacoes.free;
  inherited;
end; // destructor ...

procedure tveiculo_veiculos_ate24hrs.Setinformacoes(value:ttpVeiculo);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure tveiculo_veiculos_ate24hrs.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculo_veiculos_ate24hrs')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculo_veiculos_ate24hrs_placa));
  xn.text := Fplaca;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(snveiculo_veiculos_ate24hrs_informacoes);
    Finformacoes.Save(xn);
  end;
end; // procedure save

{ tveiculos_ate24hrs }

function tveiculos_ate24hrs.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculos_ate24hrs._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculos_ate24hrs.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fveiculo := tManagedStringlist.Create;
end; // constructor ...

constructor tveiculos_ate24hrs.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aveiculo: tveiculo;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculos_ate24hrs_veiculo)
      and ((thisURI='') or (tveiculo._nsURI_ = thisURI)) then
    begin
      aveiculo := tveiculo.Create(xn);
      Fveiculo.AddObject('?', aveiculo);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculos_ate24hrs.Destroy;
begin
  Fveiculo.Free;
  inherited;
end; // destructor ...

procedure tveiculos_ate24hrs.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculos_ate24hrs')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "veiculo" is tManagedStringlist
  if Assigned(Fveiculo) then
    for i:=0 to Fveiculo.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculos_ate24hrs_veiculo));
      tveiculo_veiculos_ate24hrs(Fveiculo.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tequiparado }

function tequiparado.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tequiparado._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tequiparado.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tequiparado.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snequiparado_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = snequiparado_inscEstadual) then
      inscEstadual :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tequiparado.Destroy;
begin
  inherited;
end; // destructor ...

procedure tequiparado.SetinscEstadual(value:string);
begin
  FinscEstadual := value;
  FinscEstadual_IsSet_ := true;
end;

procedure tequiparado.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'equiparado')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snequiparado_cnpj));
  xn.text := Fcnpj;
  if inscEstadual_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snequiparado_inscEstadual));
    xn.text := FinscEstadual;
  end;
end; // procedure save

{ ttac }

function ttac.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttac._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttac.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttac.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntac_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntac_identidade) then
      identidade :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttac.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttac.Setidentidade(value:string);
begin
  Fidentidade := value;
  Fidentidade_IsSet_ := true;
end;

procedure ttac.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tac')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntac_cpf));
  xn.text := Fcpf;
  if identidade_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntac_identidade));
    xn.text := Fidentidade;
  end;
end; // procedure save

{ tide_tpTransportador }

function tide_tpTransportador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide_tpTransportador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide_tpTransportador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide_tpTransportador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_tpTransportador_tac)
      and ((thisURI='') or (ttac._nsURI_ = thisURI)) then
      tac := ttac.Create(xn)
    else if (sn = snide_tpTransportador_equiparado)
      and ((thisURI='') or (tequiparado._nsURI_ = thisURI)) then
      equiparado := tequiparado.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide_tpTransportador.Destroy;
begin
  Ftac.Free;
  Fequiparado.Free;
  inherited;
end; // destructor ...

procedure tide_tpTransportador.Settac(value:ttac);
begin
  Ftac := value;
  Ftac_IsSet_ := true;
end;

procedure tide_tpTransportador.Setequiparado(value:tequiparado);
begin
  Fequiparado := value;
  Fequiparado_IsSet_ := true;
end;

procedure tide_tpTransportador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide_tpTransportador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Ftac) then
  begin
    xn := aNode.addChildByName(snide_tpTransportador_tac);
    Ftac.Save(xn);
  end;
  if Assigned(Fequiparado) then
  begin
    xn := aNode.addChildByName(snide_tpTransportador_equiparado);
    Fequiparado.Save(xn);
  end;
end; // procedure save

{ ttpTransportador }

function ttpTransportador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpTransportador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpTransportador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fide := tide_tpTransportador.Create;
  Fendereco := ttpEnderecoSemIBGE.Create;
end; // constructor ...

constructor ttpTransportador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpTransportador_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      Fide := tide_tpTransportador.Create(xn)
    else if (sn = sntpTransportador_nome) then
      nome :=  xn.text // string
    else if (sn = sntpTransportador_endereco) then
      Fendereco := ttpEnderecoSemIBGE.Create(xn)
    else if (sn = sntpTransportador_telefone) then
      telefone := StrToInt64Def(xn.text, 0)
    else if (sn = sntpTransportador_cartaoId) then
      cartaoId := StrToInt64Def(xn.text, 0)
    else if (sn = sntpTransportador_email) then
      email :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpTransportador.Destroy;
begin
  Fide.Free;
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpTransportador.SetcartaoId(value:int64);
begin
  FcartaoId := value;
  FcartaoId_IsSet_ := true;
end;

procedure ttpTransportador.Setemail(value:string);
begin
  Femail := value;
  Femail_IsSet_ := true;
end;

procedure ttpTransportador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpTransportador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(sntpTransportador_ide);
    Fide.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpTransportador_nome));
  xn.text := Fnome;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpTransportador_endereco);
    Fendereco.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpTransportador_telefone));
  xn.text := IntToStr(Ftelefone);
  if cartaoId_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpTransportador_cartaoId));
    xn.text := IntToStr(FcartaoId);
  end;
  if email_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpTransportador_email));
    xn.text := Femail;
  end;
end; // procedure save

{ ttpAlterarCarga }

function ttpAlterarCarga.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpAlterarCarga._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpAlterarCarga.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpAlterarCarga.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpAlterarCarga_codigoSH) then
      codigoSH :=  xn.text // string
    else if (sn = sntpAlterarCarga_quantidade) then
      quantidade :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpAlterarCarga.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpAlterarCarga.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpAlterarCarga')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAlterarCarga_codigoSH));
  xn.text := FcodigoSH;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpAlterarCarga_quantidade));
  xn.text := Fquantidade;
end; // procedure save

{ tate24hrs }

function tate24hrs.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tate24hrs._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tate24hrs.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tate24hrs.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snate24hrs_validade)
      and ((thisURI='') or (tvalidade._nsURI_ = thisURI)) then
      validade := tvalidade.Create(xn)
    else if (sn = snate24hrs_carga) then
      carga := ttpAlterarCarga.Create(xn)
    else if (sn = snate24hrs_veiculos)
      and ((thisURI='') or (tveiculos._nsURI_ = thisURI)) then
      veiculos := tveiculos_ate24hrs.Create(xn)
    else if (sn = snate24hrs_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else if (sn = snate24hrs_rota) then
      rota := ttpRota.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tate24hrs.Destroy;
begin
  Fvalidade.Free;
  if assigned(Fcarga) then  Fcarga.free;
  Fveiculos.Free;
  if assigned(Frota) then  Frota.free;
  inherited;
end; // destructor ...

procedure tate24hrs.Setvalidade(value:tvalidade);
begin
  Fvalidade := value;
  Fvalidade_IsSet_ := true;
end;

procedure tate24hrs.Setcarga(value:ttpAlterarCarga);
begin
  Fcarga := value;
  Fcarga_IsSet_ := true;
end;

procedure tate24hrs.Setveiculos(value:tveiculos_ate24hrs);
begin
  Fveiculos := value;
  Fveiculos_IsSet_ := true;
end;

procedure tate24hrs.SetcategoriaPedagio(value:integer);
begin
  FcategoriaPedagio := value;
  FcategoriaPedagio_IsSet_ := true;
end;

procedure tate24hrs.Setrota(value:ttpRota);
begin
  Frota := value;
  Frota_IsSet_ := true;
end;

procedure tate24hrs.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ate24hrs')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fvalidade) then
  begin
    xn := aNode.addChildByName(snate24hrs_validade);
    Fvalidade.Save(xn);
  end;
  if Assigned(Fcarga) then
  begin
    xn := aNode.addChildByName(snate24hrs_carga);
    Fcarga.Save(xn);
  end;
  if Assigned(Fveiculos) then
  begin
    xn := aNode.addChildByName(snate24hrs_veiculos);
    Fveiculos.Save(xn);
  end;
  if categoriaPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snate24hrs_categoriaPedagio));
    xn.text := IntToStr(FcategoriaPedagio);
  end;
  if Assigned(Frota) then
  begin
    xn := aNode.addChildByName(snate24hrs_rota);
    Frota.Save(xn);
  end;
end; // procedure save

{ tpadrao_ANTT }

function tpadrao_ANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpadrao_ANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpadrao_ANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpadrao_ANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpadrao_ANTT_ate24hrs)
      and ((thisURI='') or (tate24hrs._nsURI_ = thisURI)) then
      ate24hrs := tate24hrs.Create(xn)
    else if (sn = snpadrao_ANTT_depois24hrs)
      and ((thisURI='') or (tdepois24hrs._nsURI_ = thisURI)) then
      depois24hrs := tdepois24hrs.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpadrao_ANTT.Destroy;
begin
  Fate24hrs.Free;
  Fdepois24hrs.Free;
  inherited;
end; // destructor ...

procedure tpadrao_ANTT.Setate24hrs(value:tate24hrs);
begin
  Fate24hrs := value;
  Fate24hrs_IsSet_ := true;
end;

procedure tpadrao_ANTT.Setdepois24hrs(value:tdepois24hrs);
begin
  Fdepois24hrs := value;
  Fdepois24hrs_IsSet_ := true;
end;

procedure tpadrao_ANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'padrao_ANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fate24hrs) then
  begin
    xn := aNode.addChildByName(snpadrao_ANTT_ate24hrs);
    Fate24hrs.Save(xn);
  end;
  if Assigned(Fdepois24hrs) then
  begin
    xn := aNode.addChildByName(snpadrao_ANTT_depois24hrs);
    Fdepois24hrs.Save(xn);
  end;
end; // procedure save

{ tANTT }

function tANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snANTT_padrao)
      and ((thisURI='') or (tpadrao._nsURI_ = thisURI)) then
      padrao := tpadrao_ANTT.Create(xn)
    else if (sn = snANTT_TACagregado)
      and ((thisURI='') or (tTACagregado._nsURI_ = thisURI)) then
      TACagregado := tTACagregado_ANTT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tANTT.Destroy;
begin
  Fpadrao.Free;
  FTACagregado.Free;
  inherited;
end; // destructor ...

procedure tANTT.Setpadrao(value:tpadrao_ANTT);
begin
  Fpadrao := value;
  Fpadrao_IsSet_ := true;
end;

procedure tANTT.SetTACagregado(value:tTACagregado_ANTT);
begin
  FTACagregado := value;
  FTACagregado_IsSet_ := true;
end;

procedure tANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fpadrao) then
  begin
    xn := aNode.addChildByName(snANTT_padrao);
    Fpadrao.Save(xn);
  end;
  if Assigned(FTACagregado) then
  begin
    xn := aNode.addChildByName(snANTT_TACagregado);
    FTACagregado.Save(xn);
  end;
end; // procedure save

{ tconfirmador }

function tconfirmador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tconfirmador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tconfirmador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tconfirmador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snconfirmador_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = snconfirmador_cpf) then
      cpf :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tconfirmador.Destroy;
begin
  inherited;
end; // destructor ...

procedure tconfirmador.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := true;
end;

procedure tconfirmador.Setcpf(value:string);
begin
  Fcpf := value;
  Fcpf_IsSet_ := true;
end;

procedure tconfirmador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'confirmador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snconfirmador_cnpj));
    xn.text := Fcnpj;
  end;
  if cpf_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snconfirmador_cpf));
    xn.text := Fcpf;
  end;
end; // procedure save

{ tdocumentos }

function tdocumentos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdocumentos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdocumentos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdocumento := tManagedStringlist.Create;
end; // constructor ...

constructor tdocumentos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndocumentos_documento) then
    begin
      // list of simple type
      Fdocumento.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdocumentos.Destroy;
begin
  Fdocumento.Free;
  inherited;
end; // destructor ...

procedure tdocumentos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'documentos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "documento" is tManagedStringlist
  if Assigned(Fdocumento) then
    for i:=0 to Fdocumento.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndocumentos_documento));
      ttpDocumento(Fdocumento.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tquitacao }

function tquitacao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tquitacao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tquitacao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdocumentos := tdocumentos.Create;
end; // constructor ...

constructor tquitacao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snquitacao_documentos)
      and ((thisURI='') or (tdocumentos._nsURI_ = thisURI)) then
      Fdocumentos := tdocumentos.Create(xn)
    else if (sn = snquitacao_entrega) then
      entrega :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tquitacao.Destroy;
begin
  Fdocumentos.Free;
  inherited;
end; // destructor ...

procedure tquitacao.Setentrega(value:string);
begin
  Fentrega := value;
  Fentrega_IsSet_ := true;
end;

procedure tquitacao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'quitacao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fdocumentos) then
  begin
    xn := aNode.addChildByName(snquitacao_documentos);
    Fdocumentos.Save(xn);
  end;
  if entrega_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snquitacao_entrega));
    xn.text := Fentrega;
  end;
end; // procedure save

{ tveiculo }

function tveiculo.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculo._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculo.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tveiculo.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculo_placa) then
      placa :=  xn.text // string
    else if (sn = snveiculo_informacoes) then
      informacoes := ttpVeiculo.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculo.Destroy;
begin
  if assigned(Finformacoes) then  Finformacoes.free;
  inherited;
end; // destructor ...

procedure tveiculo.Setinformacoes(value:ttpVeiculo);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure tveiculo.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculo')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculo_placa));
  xn.text := Fplaca;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(snveiculo_informacoes);
    Finformacoes.Save(xn);
  end;
end; // procedure save

{ tveiculos }

function tveiculos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tveiculos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tveiculos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fveiculo := tManagedStringlist.Create;
end; // constructor ...

constructor tveiculos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aveiculo: tveiculo;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snveiculos_veiculo)
      and ((thisURI='') or (tveiculo._nsURI_ = thisURI)) then
    begin
      aveiculo := tveiculo.Create(xn);
      Fveiculo.AddObject('?', aveiculo);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tveiculos.Destroy;
begin
  Fveiculo.Free;
  inherited;
end; // destructor ...

procedure tveiculos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'veiculos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "veiculo" is tManagedStringlist
  if Assigned(Fveiculo) then
    for i:=0 to Fveiculo.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snveiculos_veiculo));
      tveiculo(Fveiculo.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tcondutor }

function tcondutor.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcondutor._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcondutor.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tcondutor.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncondutor_cpf) then
      cpf :=  xn.text // string
    else if (sn = sncondutor_informacoes) then
      informacoes := ttpCondutor.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcondutor.Destroy;
begin
  if assigned(Finformacoes) then  Finformacoes.free;
  inherited;
end; // destructor ...

procedure tcondutor.Setinformacoes(value:ttpCondutor);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure tcondutor.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'condutor')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncondutor_cpf));
  xn.text := Fcpf;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(sncondutor_informacoes);
    Finformacoes.Save(xn);
  end;
end; // procedure save

{ tcondutores }

function tcondutores.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcondutores._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcondutores.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fcondutor := tManagedStringlist.Create;
end; // constructor ...

constructor tcondutores.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  acondutor: tcondutor;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncondutores_condutor)
      and ((thisURI='') or (tcondutor._nsURI_ = thisURI)) then
    begin
      acondutor := tcondutor.Create(xn);
      Fcondutor.AddObject('?', acondutor);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcondutores.Destroy;
begin
  Fcondutor.Free;
  inherited;
end; // destructor ...

procedure tcondutores.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'condutores')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "condutor" is tManagedStringlist
  if Assigned(Fcondutor) then
    for i:=0 to Fcondutor.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncondutores_condutor));
      tcondutor(Fcondutor.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tcontatos }

function tcontatos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcontatos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcontatos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fcontato := tManagedStringlist.Create;
end; // constructor ...

constructor tcontatos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncontatos_contato) then
    begin
      // list of simple type
      Fcontato.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcontatos.Destroy;
begin
  Fcontato.Free;
  inherited;
end; // destructor ...

procedure tcontatos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'contatos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "contato" is tManagedStringlist
  if Assigned(Fcontato) then
    for i:=0 to Fcontato.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncontatos_contato));
      ttpContato(Fcontato.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tide }

function tide.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tide._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tide.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tide.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snide_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = snide_numero) then
      numero :=  xn.text // string
    else if (sn = snide_serie) then
      serie :=  xn.text // string
    else if (sn = snide_ptEmissor) then
      ptEmissor :=  xn.text // string
    else if (sn = snide_dtInicio) then
      dtInicio :=  xn.text // string
    else if (sn = snide_dtFim) then
      dtFim :=  xn.text // string
    else if (sn = snide_contrato) then
      contrato :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tide.Destroy;
begin
  inherited;
end; // destructor ...

procedure tide.SetdtInicio(value:string);
begin
  FdtInicio := value;
  FdtInicio_IsSet_ := true;
end;

procedure tide.SetdtFim(value:string);
begin
  FdtFim := value;
  FdtFim_IsSet_ := true;
end;

procedure tide.Setcontrato(value:string);
begin
  Fcontrato := value;
  Fcontrato_IsSet_ := true;
end;

procedure tide.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ide')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_cnpj));
  xn.text := Fcnpj;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_numero));
  xn.text := Fnumero;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_serie));
  xn.text := Fserie;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_ptEmissor));
  xn.text := FptEmissor;
  if dtInicio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_dtInicio));
    xn.text := FdtInicio;
  end;
  if dtFim_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_dtFim));
    xn.text := FdtFim;
  end;
  if contrato_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snide_contrato));
    xn.text := Fcontrato;
  end;
end; // procedure save

{ tndop }

function tndop.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndop._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndop.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndop.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndop_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snndop_ndopCodVerificador) then
      ndopCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndop.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndop.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndop')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndop_ndopCodVerificador));
  xn.text := FndopCodVerificador;
end; // procedure save

{ tndot }

function tndot.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tndot._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tndot.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tndot.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snndot_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snndot_ndotCodVerificador) then
      ndotCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tndot.Destroy;
begin
  inherited;
end; // destructor ...

procedure tndot.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ndot')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndot_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snndot_ndotCodVerificador));
  xn.text := FndotCodVerificador;
end; // procedure save

{ tciot }

function tciot.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tciot._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tciot.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tciot.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snciot_numero) then
      numero := StrToInt64Def(xn.text, 0)
    else if (sn = snciot_ciotCodVerificador) then
      ciotCodVerificador :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tciot.Destroy;
begin
  inherited;
end; // destructor ...

procedure tciot.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'ciot')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snciot_numero));
  xn.text := IntToStr(Fnumero);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snciot_ciotCodVerificador));
  xn.text := FciotCodVerificador;
end; // procedure save

{ ttpAutorizacaoImpressao }

function ttpAutorizacaoImpressao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpAutorizacaoImpressao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpAutorizacaoImpressao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpAutorizacaoImpressao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpAutorizacaoImpressao_ciot)
      and ((thisURI='') or (tciot._nsURI_ = thisURI)) then
      ciot := tciot.Create(xn)
    else if (sn = sntpAutorizacaoImpressao_ndot)
      and ((thisURI='') or (tndot._nsURI_ = thisURI)) then
      ndot := tndot.Create(xn)
    else if (sn = sntpAutorizacaoImpressao_ndop)
      and ((thisURI='') or (tndop._nsURI_ = thisURI)) then
      ndop := tndop.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpAutorizacaoImpressao.Destroy;
begin
  Fciot.Free;
  Fndot.Free;
  Fndop.Free;
  inherited;
end; // destructor ...

procedure ttpAutorizacaoImpressao.Setciot(value:tciot);
begin
  Fciot := value;
  Fciot_IsSet_ := true;
end;

procedure ttpAutorizacaoImpressao.Setndot(value:tndot);
begin
  Fndot := value;
  Fndot_IsSet_ := true;
end;

procedure ttpAutorizacaoImpressao.Setndop(value:tndop);
begin
  Fndop := value;
  Fndop_IsSet_ := true;
end;

procedure ttpAutorizacaoImpressao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpAutorizacaoImpressao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fciot) then
  begin
    xn := aNode.addChildByName(sntpAutorizacaoImpressao_ciot);
    Fciot.Save(xn);
  end;
  if Assigned(Fndot) then
  begin
    xn := aNode.addChildByName(sntpAutorizacaoImpressao_ndot);
    Fndot.Save(xn);
  end;
  if Assigned(Fndop) then
  begin
    xn := aNode.addChildByName(sntpAutorizacaoImpressao_ndop);
    Fndop.Save(xn);
  end;
end; // procedure save

{ ttpCabecalhoImpressao }

function ttpCabecalhoImpressao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCabecalhoImpressao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCabecalhoImpressao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoImpressao.Create;
end; // constructor ...

constructor ttpCabecalhoImpressao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCabecalhoImpressao_pontoEmissor) then
      pontoEmissor :=  xn.text // string
    else if (sn = sntpCabecalhoImpressao_documentosImprimir) then
      documentosImprimir :=  xn.text // tbyte
    else if (sn = sntpCabecalhoImpressao_autorizacao) then
      Fautorizacao := ttpAutorizacaoImpressao.Create(xn)
    else if (sn = sntpCabecalhoImpressao_conteudo) then
      conteudo := ttbPadraoImpressaoCompleto.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCabecalhoImpressao.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  if assigned(Fconteudo) then  Fconteudo.free;
  inherited;
end; // destructor ...

procedure ttpCabecalhoImpressao.Setconteudo(value:ttbPadraoImpressaoCompleto);
begin
  Fconteudo := value;
  Fconteudo_IsSet_ := true;
end;

procedure ttpCabecalhoImpressao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCabecalhoImpressao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCabecalhoImpressao_pontoEmissor));
  xn.text := FpontoEmissor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCabecalhoImpressao_documentosImprimir));
  xn.text := FdocumentosImprimir;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpCabecalhoImpressao_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if Assigned(Fconteudo) then
  begin
    xn := aNode.addChildByName(sntpCabecalhoImpressao_conteudo);
    Fconteudo.Save(xn);
  end;
end; // procedure save

{ timpressao_tpRetornoImpressaoDocumentos }

function timpressao_tpRetornoImpressaoDocumentos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function timpressao_tpRetornoImpressaoDocumentos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor timpressao_tpRetornoImpressaoDocumentos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fcabecalho := ttpCabecalhoImpressao.Create;
end; // constructor ...

constructor timpressao_tpRetornoImpressaoDocumentos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snimpressao_tpRetornoImpressaoDocumentos_cabecalho) then
      Fcabecalho := ttpCabecalhoImpressao.Create(xn)
    else if (sn = snimpressao_tpRetornoImpressaoDocumentos_status) then
      status :=  xn.text // tbyte
    else if (sn = snimpressao_tpRetornoImpressaoDocumentos_descricaoErro) then
      descricaoErro :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor timpressao_tpRetornoImpressaoDocumentos.Destroy;
begin
  if assigned(Fcabecalho) then  Fcabecalho.free;
  inherited;
end; // destructor ...

procedure timpressao_tpRetornoImpressaoDocumentos.SetdescricaoErro(value:string);
begin
  FdescricaoErro := value;
  FdescricaoErro_IsSet_ := true;
end;

procedure timpressao_tpRetornoImpressaoDocumentos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'impressao_tpRetornoImpressaoDocumentos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fcabecalho) then
  begin
    xn := aNode.addChildByName(snimpressao_tpRetornoImpressaoDocumentos_cabecalho);
    Fcabecalho.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snimpressao_tpRetornoImpressaoDocumentos_status));
  xn.text := Fstatus;
  if descricaoErro_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snimpressao_tpRetornoImpressaoDocumentos_descricaoErro));
    xn.text := FdescricaoErro;
  end;
end; // procedure save

{ tformulario }

function tformulario.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tformulario._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tformulario.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fcabecalho := ttpCabecalhoImpressao.Create;
end; // constructor ...

constructor tformulario.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snformulario_cabecalho) then
      Fcabecalho := ttpCabecalhoImpressao.Create(xn)
    else if (sn = snformulario_impressaoDOT) then
      impressaoDOT := ttbPadraoImpressao.Create(xn)
    else if (sn = snformulario_impressaoDocumentosAdicionais) then
      impressaoDocumentosAdicionais := ttbPadraoImpressao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tformulario.Destroy;
begin
  if assigned(Fcabecalho) then  Fcabecalho.free;
  if assigned(FimpressaoDOT) then  FimpressaoDOT.free;
  if assigned(FimpressaoDocumentosAdicionais) then  FimpressaoDocumentosAdicionais.free;
  inherited;
end; // destructor ...

procedure tformulario.SetimpressaoDOT(value:ttbPadraoImpressao);
begin
  FimpressaoDOT := value;
  FimpressaoDOT_IsSet_ := true;
end;

procedure tformulario.SetimpressaoDocumentosAdicionais(value:ttbPadraoImpressao);
begin
  FimpressaoDocumentosAdicionais := value;
  FimpressaoDocumentosAdicionais_IsSet_ := true;
end;

procedure tformulario.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'formulario')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fcabecalho) then
  begin
    xn := aNode.addChildByName(snformulario_cabecalho);
    Fcabecalho.Save(xn);
  end;
  if Assigned(FimpressaoDOT) then
  begin
    xn := aNode.addChildByName(snformulario_impressaoDOT);
    FimpressaoDOT.Save(xn);
  end;
  if Assigned(FimpressaoDocumentosAdicionais) then
  begin
    xn := aNode.addChildByName(snformulario_impressaoDocumentosAdicionais);
    FimpressaoDocumentosAdicionais.Save(xn);
  end;
end; // procedure save

{ ttpinfImpressaoDocumentos }

function ttpinfImpressaoDocumentos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpinfImpressaoDocumentos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpinfImpressaoDocumentos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fcabecalho := ttpCabecalhoFormularioImpressao.Create;
  Fformulario := tManagedStringlist.Create;
end; // constructor ...

constructor ttpinfImpressaoDocumentos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aformulario: tformulario;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpinfImpressaoDocumentos_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpinfImpressaoDocumentos_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpinfImpressaoDocumentos_cabecalho) then
      Fcabecalho := ttpCabecalhoFormularioImpressao.Create(xn)
    else if (sn = sntpinfImpressaoDocumentos_formulario)
      and ((thisURI='') or (tformulario._nsURI_ = thisURI)) then
    begin
      aformulario := tformulario.Create(xn);
      Fformulario.AddObject('?', aformulario);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpinfImpressaoDocumentos.Destroy;
begin
  if assigned(Fcabecalho) then  Fcabecalho.free;
  Fformulario.Free;
  inherited;
end; // destructor ...

procedure ttpinfImpressaoDocumentos.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure ttpinfImpressaoDocumentos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpinfImpressaoDocumentos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpinfImpressaoDocumentos_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpinfImpressaoDocumentos_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fcabecalho) then
  begin
    xn := aNode.addChildByName(sntpinfImpressaoDocumentos_cabecalho);
    Fcabecalho.Save(xn);
  end;
  // element "formulario" is tManagedStringlist
  if Assigned(Fformulario) then
    for i:=0 to Fformulario.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpinfImpressaoDocumentos_formulario));
      tformulario(Fformulario.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ timpressao }

function timpressao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function timpressao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor timpressao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfImpressaoDocumentos := ttpinfImpressaoDocumentos.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor timpressao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snimpressao_infImpressaoDocumentos) then
      FinfImpressaoDocumentos := ttpinfImpressaoDocumentos.Create(xn)
    else if (sn = snimpressao_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor timpressao.Destroy;
begin
  if assigned(FinfImpressaoDocumentos) then  FinfImpressaoDocumentos.free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure timpressao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'impressao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FinfImpressaoDocumentos) then
  begin
    xn := aNode.addChildByName(snimpressao_infImpressaoDocumentos);
    FinfImpressaoDocumentos.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(snimpressao_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ ttpImpressaoDocumentos }

function ttpImpressaoDocumentos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpImpressaoDocumentos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpImpressaoDocumentos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fimpressao := timpressao.Create;
end; // constructor ...

constructor ttpImpressaoDocumentos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpImpressaoDocumentos_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpImpressaoDocumentos_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpImpressaoDocumentos_impressao)
      and ((thisURI='') or (timpressao._nsURI_ = thisURI)) then
      Fimpressao := timpressao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpImpressaoDocumentos.Destroy;
begin
  Fimpressao.Free;
  inherited;
end; // destructor ...

procedure ttpImpressaoDocumentos.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpImpressaoDocumentos.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpImpressaoDocumentos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpImpressaoDocumentos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpImpressaoDocumentos_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpImpressaoDocumentos_token] := Ftoken;

  if Assigned(Fimpressao) then
  begin
    xn := aNode.addChildByName(sntpImpressaoDocumentos_impressao);
    Fimpressao.Save(xn);
  end;
end; // procedure save

{ ttpCartaoObrigatorioColaborador }

function ttpCartaoObrigatorioColaborador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCartaoObrigatorioColaborador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCartaoObrigatorioColaborador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpCartaoObrigatorioColaborador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCartaoObrigatorioColaborador_cartaoId) then
      cartaoId := StrToInt64Def(xn.text, 0)
    else if (sn = sntpCartaoObrigatorioColaborador_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCartaoObrigatorioColaborador.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpCartaoObrigatorioColaborador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCartaoObrigatorioColaborador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCartaoObrigatorioColaborador_cartaoId));
  xn.text := IntToStr(FcartaoId);
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCartaoObrigatorioColaborador_gestoraCartao));
  xn.text := FgestoraCartao;
end; // procedure save

{ ttpCartaoColaborador }

function ttpCartaoColaborador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpCartaoColaborador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpCartaoColaborador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpCartaoColaborador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpCartaoColaborador_cartaoId) then
      cartaoId := StrToInt64Def(xn.text, 0)
    else if (sn = sntpCartaoColaborador_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpCartaoColaborador.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpCartaoColaborador.SetcartaoId(value:int64);
begin
  FcartaoId := value;
  FcartaoId_IsSet_ := true;
end;

procedure ttpCartaoColaborador.SetgestoraCartao(value:string);
begin
  FgestoraCartao := value;
  FgestoraCartao_IsSet_ := true;
end;

procedure ttpCartaoColaborador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpCartaoColaborador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if cartaoId_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCartaoColaborador_cartaoId));
    xn.text := IntToStr(FcartaoId);
  end;
  if gestoraCartao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpCartaoColaborador_gestoraCartao));
    xn.text := FgestoraCartao;
  end;
end; // procedure save

{ ttpColaborador }

function ttpColaborador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpColaborador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpColaborador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fendereco := ttpEnderecoSemIBGE.Create;
end; // constructor ...

constructor ttpColaborador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpColaborador_nome) then
      nome :=  xn.text // string
    else if (sn = sntpColaborador_identidade) then
      identidade :=  xn.text // string
    else if (sn = sntpColaborador_endereco) then
      Fendereco := ttpEnderecoSemIBGE.Create(xn)
    else if (sn = sntpColaborador_telefone) then
      telefone := StrToInt64Def(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpColaborador.Destroy;
begin
  if assigned(Fendereco) then  Fendereco.free;
  inherited;
end; // destructor ...

procedure ttpColaborador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpColaborador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpColaborador_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpColaborador_identidade));
  xn.text := Fidentidade;
  if Assigned(Fendereco) then
  begin
    xn := aNode.addChildByName(sntpColaborador_endereco);
    Fendereco.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpColaborador_telefone));
  xn.text := IntToStr(Ftelefone);
end; // procedure save

{ tcolaborador_tpInfRetornoOperacaoPagamento }

function tcolaborador_tpInfRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcolaborador_tpInfRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcolaborador_tpInfRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tcolaborador_tpInfRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncolaborador_tpInfRetornoOperacaoPagamento_cpf) then
      cpf :=  xn.text // string
    else if (sn = sncolaborador_tpInfRetornoOperacaoPagamento_informacoes) then
      informacoes := ttpColaborador.Create(xn)
    else if (sn = sncolaborador_tpInfRetornoOperacaoPagamento_cartao) then
      cartao := ttpCartaoObrigatorioColaborador.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcolaborador_tpInfRetornoOperacaoPagamento.Destroy;
begin
  if assigned(Finformacoes) then  Finformacoes.free;
  if assigned(Fcartao) then  Fcartao.free;
  inherited;
end; // destructor ...

procedure tcolaborador_tpInfRetornoOperacaoPagamento.Setinformacoes(value:ttpColaborador);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure tcolaborador_tpInfRetornoOperacaoPagamento.Setcartao(value:ttpCartaoObrigatorioColaborador);
begin
  Fcartao := value;
  Fcartao_IsSet_ := true;
end;

procedure tcolaborador_tpInfRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'colaborador_tpInfRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncolaborador_tpInfRetornoOperacaoPagamento_cpf));
  xn.text := Fcpf;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(sncolaborador_tpInfRetornoOperacaoPagamento_informacoes);
    Finformacoes.Save(xn);
  end;
  if Assigned(Fcartao) then
  begin
    xn := aNode.addChildByName(sncolaborador_tpInfRetornoOperacaoPagamento_cartao);
    Fcartao.Save(xn);
  end;
end; // procedure save

{ ttpInfRetornoOperacaoPagamento }

function ttpInfRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fide := tide_tpInfRetornoOperacaoPagamento.Create;
  Fcolaborador := tcolaborador_tpInfRetornoOperacaoPagamento.Create;
  Fpagamento := tpagamento_tpInfRetornoOperacaoPagamento.Create;
end; // constructor ...

constructor ttpInfRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpInfRetornoOperacaoPagamento_ID then
      ID := aRoot.attribute[i]; // string
    if sn = antpInfRetornoOperacaoPagamento_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfRetornoOperacaoPagamento_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      Fide := tide_tpInfRetornoOperacaoPagamento.Create(xn)
    else if (sn = sntpInfRetornoOperacaoPagamento_colaborador)
      and ((thisURI='') or (tcolaborador._nsURI_ = thisURI)) then
      Fcolaborador := tcolaborador_tpInfRetornoOperacaoPagamento.Create(xn)
    else if (sn = sntpInfRetornoOperacaoPagamento_rota) then
      Frota := ttpRota.Create(xn)
    else if (sn = sntpInfRetornoOperacaoPagamento_pagamento)
      and ((thisURI='') or (tpagamento._nsURI_ = thisURI)) then
      Fpagamento := tpagamento_tpInfRetornoOperacaoPagamento.Create(xn)
    else if (sn = sntpInfRetornoOperacaoPagamento_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfRetornoOperacaoPagamento.Destroy;
begin
  Fide.Free;
  Fcolaborador.Free;
  if assigned(Frota) then  Frota.free;
  Fpagamento.Free;
  inherited;
end; // destructor ...

procedure ttpInfRetornoOperacaoPagamento.Setrota(value:ttpRota);
begin
  Frota := value;
  Frota_IsSet_ := true;
end;

procedure ttpInfRetornoOperacaoPagamento.SetcategoriaPedagio(value:integer);
begin
  FcategoriaPedagio := value;
  FcategoriaPedagio_IsSet_ := true;
end;

procedure ttpInfRetornoOperacaoPagamento.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure ttpInfRetornoOperacaoPagamento.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpInfRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpInfRetornoOperacaoPagamento_ID] := FID;
  if token_IsSet_ then
    aNode.attribute[antpInfRetornoOperacaoPagamento_token] := Ftoken;

  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoOperacaoPagamento_ide);
    Fide.Save(xn);
  end;
  if Assigned(Fcolaborador) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoOperacaoPagamento_colaborador);
    Fcolaborador.Save(xn);
  end;
  if Assigned(Frota) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoOperacaoPagamento_rota);
    Frota.Save(xn);
  end;
  if Assigned(Fpagamento) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoOperacaoPagamento_pagamento);
    Fpagamento.Save(xn);
  end;
  if categoriaPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfRetornoOperacaoPagamento_categoriaPedagio));
    xn.text := IntToStr(FcategoriaPedagio);
  end;
end; // procedure save

{ tcolaborador }

function tcolaborador.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tcolaborador._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tcolaborador.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tcolaborador.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sncolaborador_cpf) then
      cpf :=  xn.text // string
    else if (sn = sncolaborador_informacoes) then
      informacoes := ttpColaborador.Create(xn)
    else if (sn = sncolaborador_cartao) then
      cartao := ttpCartaoObrigatorioColaborador.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tcolaborador.Destroy;
begin
  if assigned(Finformacoes) then  Finformacoes.free;
  if assigned(Fcartao) then  Fcartao.free;
  inherited;
end; // destructor ...

procedure tcolaborador.Setinformacoes(value:ttpColaborador);
begin
  Finformacoes := value;
  Finformacoes_IsSet_ := true;
end;

procedure tcolaborador.Setcartao(value:ttpCartaoObrigatorioColaborador);
begin
  Fcartao := value;
  Fcartao_IsSet_ := true;
end;

procedure tcolaborador.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'colaborador')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sncolaborador_cpf));
  xn.text := Fcpf;
  if Assigned(Finformacoes) then
  begin
    xn := aNode.addChildByName(sncolaborador_informacoes);
    Finformacoes.Save(xn);
  end;
  if Assigned(Fcartao) then
  begin
    xn := aNode.addChildByName(sncolaborador_cartao);
    Fcartao.Save(xn);
  end;
end; // procedure save

{ ttpInfOperacaoPagamento }

function ttpInfOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fide := tide_tpInfOperacaoPagamento.Create;
  Fcolaborador := tcolaborador.Create;
  Fpagamento := tpagamento.Create;
end; // constructor ...

constructor ttpInfOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpInfOperacaoPagamento_ID then
      ID := aRoot.attribute[i]; // string
    if sn = antpInfOperacaoPagamento_impAuto then
      impAuto := aRoot.attribute[i]; // tbyte
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfOperacaoPagamento_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      Fide := tide_tpInfOperacaoPagamento.Create(xn)
    else if (sn = sntpInfOperacaoPagamento_colaborador)
      and ((thisURI='') or (tcolaborador._nsURI_ = thisURI)) then
      Fcolaborador := tcolaborador.Create(xn)
    else if (sn = sntpInfOperacaoPagamento_rota) then
      rota := ttpRota.Create(xn)
    else if (sn = sntpInfOperacaoPagamento_pagamento)
      and ((thisURI='') or (tpagamento._nsURI_ = thisURI)) then
      Fpagamento := tpagamento.Create(xn)
    else if (sn = sntpInfOperacaoPagamento_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfOperacaoPagamento.Destroy;
begin
  Fide.Free;
  Fcolaborador.Free;
  if assigned(Frota) then  Frota.free;
  Fpagamento.Free;
  inherited;
end; // destructor ...

procedure ttpInfOperacaoPagamento.Setrota(value:ttpRota);
begin
  Frota := value;
  Frota_IsSet_ := true;
end;

procedure ttpInfOperacaoPagamento.SetcategoriaPedagio(value:integer);
begin
  FcategoriaPedagio := value;
  FcategoriaPedagio_IsSet_ := true;
end;

procedure ttpInfOperacaoPagamento.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure ttpInfOperacaoPagamento.SetimpAuto(value:tbyte);
begin
  FimpAuto := value;
  FimpAuto_IsSet_ := true;
end;

procedure ttpInfOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[antpInfOperacaoPagamento_ID] := FID;
  if impAuto_IsSet_ then
    aNode.attribute[antpInfOperacaoPagamento_impAuto] := FimpAuto;

  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(sntpInfOperacaoPagamento_ide);
    Fide.Save(xn);
  end;
  if Assigned(Fcolaborador) then
  begin
    xn := aNode.addChildByName(sntpInfOperacaoPagamento_colaborador);
    Fcolaborador.Save(xn);
  end;
  if Assigned(Frota) then
  begin
    xn := aNode.addChildByName(sntpInfOperacaoPagamento_rota);
    Frota.Save(xn);
  end;
  if Assigned(Fpagamento) then
  begin
    xn := aNode.addChildByName(sntpInfOperacaoPagamento_pagamento);
    Fpagamento.Save(xn);
  end;
  if categoriaPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfOperacaoPagamento_categoriaPedagio));
    xn.text := IntToStr(FcategoriaPedagio);
  end;
end; // procedure save

{ ttpOperacaoPagamento }

function ttpOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfOperacaoPagamento := ttpInfOperacaoPagamento.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor ttpOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpOperacaoPagamento_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpOperacaoPagamento_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpOperacaoPagamento_infOperacaoPagamento) then
      FinfOperacaoPagamento := ttpInfOperacaoPagamento.Create(xn)
    else if (sn = sntpOperacaoPagamento_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpOperacaoPagamento.Destroy;
begin
  if assigned(FinfOperacaoPagamento) then  FinfOperacaoPagamento.free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpOperacaoPagamento.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpOperacaoPagamento.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpOperacaoPagamento_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpOperacaoPagamento_token] := Ftoken;

  if Assigned(FinfOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(sntpOperacaoPagamento_infOperacaoPagamento);
    FinfOperacaoPagamento.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpOperacaoPagamento_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ ttpMensagem }

function ttpMensagem.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpMensagem._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpMensagem.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpMensagem.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpMensagem_mensagem) then
      mensagem :=  xn.text // string
    else if (sn = sntpMensagem_observacao) then
      observacao :=  xn.text // string
    else if (sn = sntpMensagem_codigo) then
      codigo :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpMensagem.Destroy;
begin
  inherited;
end; // destructor ...

procedure ttpMensagem.Setobservacao(value:string);
begin
  Fobservacao := value;
  Fobservacao_IsSet_ := true;
end;

procedure ttpMensagem.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpMensagem')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpMensagem_codigo));
  xn.text := FCodigo;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpMensagem_mensagem));
  xn.text := Fmensagem;
  if observacao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpMensagem_observacao));
    xn.text := Fobservacao;
  end;
end; // procedure save

{ ttpRetornoConsultaANTTDetalhe }

function ttpRetornoConsultaANTTDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaANTTDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaANTTDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := ttpMensagem.Create;
end; // constructor ...

constructor ttpRetornoConsultaANTTDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaANTTDetalhe_mensagem) then
      Fmensagem := ttpMensagem.Create(xn)
    else if (sn = sntpRetornoConsultaANTTDetalhe_nomeTransportador) then
      nomeTransportador :=  xn.text // string
    else if (sn = sntpRetornoConsultaANTTDetalhe_situacaoRNTRC) then
      situacaoRNTRC :=  xn.text // tbyte
    else if (sn = sntpRetornoConsultaANTTDetalhe_situacaoTransportador)
      and ((thisURI='') or (tsituacaoTransportador._nsURI_ = thisURI)) then
      situacaoTransportador := tsituacaoTransportador.Create(xn)
    else if (sn = sntpRetornoConsultaANTTDetalhe_veiculosTransportador)
      and ((thisURI='') or (tveiculosTransportador._nsURI_ = thisURI)) then
      veiculosTransportador := tveiculosTransportador.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaANTTDetalhe.Destroy;
begin
  if assigned(Fmensagem) then  Fmensagem.free;
  FsituacaoTransportador.Free;
  FveiculosTransportador.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaANTTDetalhe.SetnomeTransportador(value:string);
begin
  FnomeTransportador := value;
  FnomeTransportador_IsSet_ := true;
end;

procedure ttpRetornoConsultaANTTDetalhe.SetsituacaoRNTRC(value:tbyte);
begin
  FsituacaoRNTRC := value;
  FsituacaoRNTRC_IsSet_ := true;
end;

procedure ttpRetornoConsultaANTTDetalhe.SetsituacaoTransportador(value:tsituacaoTransportador);
begin
  FsituacaoTransportador := value;
  FsituacaoTransportador_IsSet_ := true;
end;

procedure ttpRetornoConsultaANTTDetalhe.SetveiculosTransportador(value:tveiculosTransportador);
begin
  FveiculosTransportador := value;
  FveiculosTransportador_IsSet_ := true;
end;

procedure ttpRetornoConsultaANTTDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaANTTDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagem) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaANTTDetalhe_mensagem);
    Fmensagem.Save(xn);
  end;
  if nomeTransportador_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoConsultaANTTDetalhe_nomeTransportador));
    xn.text := FnomeTransportador;
  end;
  if situacaoRNTRC_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoConsultaANTTDetalhe_situacaoRNTRC));
    xn.text := FsituacaoRNTRC;
  end;
  if Assigned(FsituacaoTransportador) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaANTTDetalhe_situacaoTransportador);
    FsituacaoTransportador.Save(xn);
  end;
  if Assigned(FveiculosTransportador) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaANTTDetalhe_veiculosTransportador);
    FveiculosTransportador.Save(xn);
  end;
end; // procedure save

{ tconsultaANTT }

function tconsultaANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tconsultaANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tconsultaANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FenvioConsultaANTT := ttpEnvioConsultaANTTDetalhe.Create;
  FretornoConsultaANTT := ttpRetornoConsultaANTTDetalhe.Create;
end; // constructor ...

constructor tconsultaANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snconsultaANTT_envioConsultaANTT) then
      FenvioConsultaANTT := ttpEnvioConsultaANTTDetalhe.Create(xn)
    else if (sn = snconsultaANTT_retornoConsultaANTT) then
      FretornoConsultaANTT := ttpRetornoConsultaANTTDetalhe.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tconsultaANTT.Destroy;
begin
  if assigned(FenvioConsultaANTT) then  FenvioConsultaANTT.free;
  if assigned(FretornoConsultaANTT) then  FretornoConsultaANTT.free;
  inherited;
end; // destructor ...

procedure tconsultaANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'consultaANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FenvioConsultaANTT) then
  begin
    xn := aNode.addChildByName(snconsultaANTT_envioConsultaANTT);
    FenvioConsultaANTT.Save(xn);
  end;
  if Assigned(FretornoConsultaANTT) then
  begin
    xn := aNode.addChildByName(snconsultaANTT_retornoConsultaANTT);
    FretornoConsultaANTT.Save(xn);
  end;
end; // procedure save

{ tconsultasANTT }

function tconsultasANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tconsultasANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tconsultasANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FconsultaANTT := tManagedStringlist.Create;
end; // constructor ...

constructor tconsultasANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aconsultaANTT: tconsultaANTT;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snconsultasANTT_consultaANTT)
      and ((thisURI='') or (tconsultaANTT._nsURI_ = thisURI)) then
    begin
      aconsultaANTT := tconsultaANTT.Create(xn);
      FconsultaANTT.AddObject('?', aconsultaANTT);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tconsultasANTT.Destroy;
begin
  FconsultaANTT.Free;
  inherited;
end; // destructor ...

procedure tconsultasANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'consultasANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "consultaANTT" is tManagedStringlist
  if Assigned(FconsultaANTT) then
    for i:=0 to FconsultaANTT.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snconsultasANTT_consultaANTT));
      tconsultaANTT(FconsultaANTT.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tmensagens_tpRetornoConsultaANTT }

function tmensagens_tpRetornoConsultaANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpRetornoConsultaANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpRetornoConsultaANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpRetornoConsultaANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpRetornoConsultaANTT_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpRetornoConsultaANTT.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpRetornoConsultaANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpRetornoConsultaANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpRetornoConsultaANTT_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoConsultaANTT }

function ttpRetornoConsultaANTT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaANTT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaANTT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoConsultaANTT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaANTT_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      mensagens := tmensagens_tpRetornoConsultaANTT.Create(xn)
    else if (sn = sntpRetornoConsultaANTT_consultasANTT)
      and ((thisURI='') or (tconsultasANTT._nsURI_ = thisURI)) then
      consultasANTT := tconsultasANTT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaANTT.Destroy;
begin
  Fmensagens.Free;
  FconsultasANTT.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaANTT.Setmensagens(value:tmensagens_tpRetornoConsultaANTT);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaANTT.SetconsultasANTT(value:tconsultasANTT);
begin
  FconsultasANTT := value;
  FconsultasANTT_IsSet_ := true;
end;

procedure ttpRetornoConsultaANTT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaANTT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaANTT_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(FconsultasANTT) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaANTT_consultasANTT);
    FconsultasANTT.Save(xn);
  end;
end; // procedure save

{ tmensagens_tpDetalheRetornoCancelarOperacaoPagamento }

function tmensagens_tpDetalheRetornoCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpDetalheRetornoCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpDetalheRetornoCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpDetalheRetornoCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpDetalheRetornoCancelarOperacaoPagamento_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ));
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpDetalheRetornoCancelarOperacaoPagamento.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpDetalheRetornoCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpDetalheRetornoCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpDetalheRetornoCancelarOperacaoPagamento_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpDetalheRetornoCancelarOperacaoPagamento }

function ttpDetalheRetornoCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDetalheRetornoCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDetalheRetornoCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagens := tmensagens_tpDetalheRetornoCancelarOperacaoPagamento.Create;
end; // constructor ...

constructor ttpDetalheRetornoCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDetalheRetornoCancelarOperacaoPagamento_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      Fmensagens := tmensagens_tpDetalheRetornoCancelarOperacaoPagamento.Create(xn)
    else if (sn = sntpDetalheRetornoCancelarOperacaoPagamento_statusPagamentoValor) then
      statusPagamentoValor :=  xn.text // tbyte
    else if (sn = sntpDetalheRetornoCancelarOperacaoPagamento_statusPagamentoPedagio) then
      statusPagamentoPedagio :=  xn.text // tbyte
    else if (sn = sntpDetalheRetornoCancelarOperacaoPagamento_dataCancelamento) then
      dataCancelamento :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDetalheRetornoCancelarOperacaoPagamento.Destroy;
begin
  Fmensagens.Free;
  inherited;
end; // destructor ...

procedure ttpDetalheRetornoCancelarOperacaoPagamento.SetstatusPagamentoValor(value:tbyte);
begin
  FstatusPagamentoValor := value;
  FstatusPagamentoValor_IsSet_ := true;
end;

procedure ttpDetalheRetornoCancelarOperacaoPagamento.SetstatusPagamentoPedagio(value:tbyte);
begin
  FstatusPagamentoPedagio := value;
  FstatusPagamentoPedagio_IsSet_ := true;
end;

procedure ttpDetalheRetornoCancelarOperacaoPagamento.SetdataCancelamento(value:string);
begin
  FdataCancelamento := value;
  FdataCancelamento_IsSet_ := true;
end;

procedure ttpDetalheRetornoCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDetalheRetornoCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpDetalheRetornoCancelarOperacaoPagamento_mensagens);
    Fmensagens.Save(xn);
  end;
  if statusPagamentoValor_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDetalheRetornoCancelarOperacaoPagamento_statusPagamentoValor));
    xn.text := FstatusPagamentoValor;
  end;
  if statusPagamentoPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDetalheRetornoCancelarOperacaoPagamento_statusPagamentoPedagio));
    xn.text := FstatusPagamentoPedagio;
  end;
  if dataCancelamento_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDetalheRetornoCancelarOperacaoPagamento_dataCancelamento));
    xn.text := FdataCancelamento;
  end;
end; // procedure save

{ tmensagens_tpRetornoCancelarOperacaoPagamento }

function tmensagens_tpRetornoCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpRetornoCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpRetornoCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpRetornoCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpRetornoCancelarOperacaoPagamento_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpRetornoCancelarOperacaoPagamento.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpRetornoCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpRetornoCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpRetornoCancelarOperacaoPagamento_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoCancelarOperacaoPagamento }

function ttpRetornoCancelarOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoCancelarOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoCancelarOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoCancelarOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoCancelarOperacaoPagamento_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      mensagens := tmensagens_tpRetornoCancelarOperacaoPagamento.Create(xn)
    else if (sn = sntpRetornoCancelarOperacaoPagamento_envioCancelarOperacaoPagamento) then
      envioCancelarOperacaoPagamento := ttpInfRetornoCancelarOperacaoPagamento.Create(xn)
    else if (sn = sntpRetornoCancelarOperacaoPagamento_retCancelarOperacaoPagamento) then
      retCancelarOperacaoPagamento := ttpDetalheRetornoCancelarOperacaoPagamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoCancelarOperacaoPagamento.Destroy;
begin
  Fmensagens.Free;
  if assigned(FenvioCancelarOperacaoPagamento) then  FenvioCancelarOperacaoPagamento.free;
  if assigned(FretCancelarOperacaoPagamento) then  FretCancelarOperacaoPagamento.free;
  inherited;
end; // destructor ...

procedure ttpRetornoCancelarOperacaoPagamento.Setmensagens(value:tmensagens_tpRetornoCancelarOperacaoPagamento);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoCancelarOperacaoPagamento.SetenvioCancelarOperacaoPagamento(value:ttpInfRetornoCancelarOperacaoPagamento);
begin
  FenvioCancelarOperacaoPagamento := value;
  FenvioCancelarOperacaoPagamento_IsSet_ := true;
end;

procedure ttpRetornoCancelarOperacaoPagamento.SetretCancelarOperacaoPagamento(value:ttpDetalheRetornoCancelarOperacaoPagamento);
begin
  FretCancelarOperacaoPagamento := value;
  FretCancelarOperacaoPagamento_IsSet_ := true;
end;

procedure ttpRetornoCancelarOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoCancelarOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoCancelarOperacaoPagamento_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(FenvioCancelarOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(sntpRetornoCancelarOperacaoPagamento_envioCancelarOperacaoPagamento);
    FenvioCancelarOperacaoPagamento.Save(xn);
  end;
  if Assigned(FretCancelarOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(sntpRetornoCancelarOperacaoPagamento_retCancelarOperacaoPagamento);
    FretCancelarOperacaoPagamento.Save(xn);
  end;
end; // procedure save

{ tmensagens_tpRetornoConsultaOperacaoPagamento }

function tmensagens_tpRetornoConsultaOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpRetornoConsultaOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpRetornoConsultaOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpRetornoConsultaOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpRetornoConsultaOperacaoPagamento_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpRetornoConsultaOperacaoPagamento.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpRetornoConsultaOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpRetornoConsultaOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpRetornoConsultaOperacaoPagamento_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tmensagens_tpRetornoOperacaoPagamentoDetalhe }

function tmensagens_tpRetornoOperacaoPagamentoDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpRetornoOperacaoPagamentoDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpRetornoOperacaoPagamentoDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpRetornoOperacaoPagamentoDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpRetornoOperacaoPagamentoDetalhe_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpRetornoOperacaoPagamentoDetalhe.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpRetornoOperacaoPagamentoDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpRetornoOperacaoPagamentoDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpRetornoOperacaoPagamentoDetalhe_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoOperacaoPagamentoDetalhe }

function ttpRetornoOperacaoPagamentoDetalhe.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoOperacaoPagamentoDetalhe._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoOperacaoPagamentoDetalhe.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagens := tmensagens_tpRetornoOperacaoPagamentoDetalhe.Create;
end; // constructor ...

constructor ttpRetornoOperacaoPagamentoDetalhe.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoOperacaoPagamentoDetalhe_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      Fmensagens := tmensagens_tpRetornoOperacaoPagamentoDetalhe.Create(xn)
    else if (sn = sntpRetornoOperacaoPagamentoDetalhe_autorizacao)
      and ((thisURI='') or (tautorizacao._nsURI_ = thisURI)) then
      autorizacao := tautorizacao_tpRetornoOperacaoPagamentoDetalhe.Create(xn)
    else if (sn = sntpRetornoOperacaoPagamentoDetalhe_pedagio)
      and ((thisURI='') or (tpedagio._nsURI_ = thisURI)) then
      pedagio := tpedagio_tpRetornoOperacaoPagamentoDetalhe.Create(xn)
    else if (sn = sntpRetornoOperacaoPagamentoDetalhe_saldo)
      and ((thisURI='') or (tsaldo._nsURI_ = thisURI)) then
      saldo := tsaldo_tpRetornoOperacaoPagamentoDetalhe.Create(xn)
    else if (sn = sntpRetornoOperacaoPagamentoDetalhe_statusPagamentoValor) then
      statusPagamentoValor :=  xn.text // tbyte
    else if (sn = sntpRetornoOperacaoPagamentoDetalhe_statusPagamentoPedagio) then
      statusPagamentoPedagio :=  xn.text // tbyte
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoOperacaoPagamentoDetalhe.Destroy;
begin
  Fmensagens.Free;
  Fautorizacao.Free;
  Fpedagio.Free;
  Fsaldo.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoOperacaoPagamentoDetalhe.Setautorizacao(value:tautorizacao_tpRetornoOperacaoPagamentoDetalhe);
begin
  Fautorizacao := value;
  Fautorizacao_IsSet_ := true;
end;

procedure ttpRetornoOperacaoPagamentoDetalhe.Setpedagio(value:tpedagio_tpRetornoOperacaoPagamentoDetalhe);
begin
  Fpedagio := value;
  Fpedagio_IsSet_ := true;
end;

procedure ttpRetornoOperacaoPagamentoDetalhe.Setsaldo(value:tsaldo_tpRetornoOperacaoPagamentoDetalhe);
begin
  Fsaldo := value;
  Fsaldo_IsSet_ := true;
end;

procedure ttpRetornoOperacaoPagamentoDetalhe.SetstatusPagamentoValor(value:tbyte);
begin
  FstatusPagamentoValor := value;
  FstatusPagamentoValor_IsSet_ := true;
end;

procedure ttpRetornoOperacaoPagamentoDetalhe.SetstatusPagamentoPedagio(value:tbyte);
begin
  FstatusPagamentoPedagio := value;
  FstatusPagamentoPedagio_IsSet_ := true;
end;

procedure ttpRetornoOperacaoPagamentoDetalhe.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoOperacaoPagamentoDetalhe')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoOperacaoPagamentoDetalhe_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpRetornoOperacaoPagamentoDetalhe_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if Assigned(Fpedagio) then
  begin
    xn := aNode.addChildByName(sntpRetornoOperacaoPagamentoDetalhe_pedagio);
    Fpedagio.Save(xn);
  end;
  if Assigned(Fsaldo) then
  begin
    xn := aNode.addChildByName(sntpRetornoOperacaoPagamentoDetalhe_saldo);
    Fsaldo.Save(xn);
  end;
  if statusPagamentoValor_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoOperacaoPagamentoDetalhe_statusPagamentoValor));
    xn.text := FstatusPagamentoValor;
  end;
  if statusPagamentoPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoOperacaoPagamentoDetalhe_statusPagamentoPedagio));
    xn.text := FstatusPagamentoPedagio;
  end;
end; // procedure save

{ tmensagens_tpDetalheRetornoOperacaoPagamento }

function tmensagens_tpDetalheRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpDetalheRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpDetalheRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpDetalheRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpDetalheRetornoOperacaoPagamento_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpDetalheRetornoOperacaoPagamento.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpDetalheRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpDetalheRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpDetalheRetornoOperacaoPagamento_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpDetalheRetornoOperacaoPagamento }

function ttpDetalheRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDetalheRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDetalheRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagens := tmensagens_tpDetalheRetornoOperacaoPagamento.Create;
end; // constructor ...

constructor ttpDetalheRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDetalheRetornoOperacaoPagamento_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      Fmensagens := tmensagens_tpDetalheRetornoOperacaoPagamento.Create(xn)
    else if (sn = sntpDetalheRetornoOperacaoPagamento_autorizacao)
      and ((thisURI='') or (tautorizacao._nsURI_ = thisURI)) then
      autorizacao := tautorizacao_tpDetalheRetornoOperacaoPagamento.Create(xn)
    else if (sn = sntpDetalheRetornoOperacaoPagamento_dataPagamento) then
      dataPagamento :=  xn.text // string
    else if (sn = sntpDetalheRetornoOperacaoPagamento_valorPagamento) then
      valorPagamento :=  xn.text // string
    else if (sn = sntpDetalheRetornoOperacaoPagamento_pedagio)
      and ((thisURI='') or (tpedagio._nsURI_ = thisURI)) then
      pedagio := tpedagio_tpDetalheRetornoOperacaoPagamento.Create(xn)
    else if (sn = sntpDetalheRetornoOperacaoPagamento_saldo)
      and ((thisURI='') or (tsaldo._nsURI_ = thisURI)) then
      saldo := tsaldo_tpDetalheRetornoOperacaoPagamento.Create(xn)
    else if (sn = sntpDetalheRetornoOperacaoPagamento_pagamentoPedagio)
      and ((thisURI='') or (tpagamentoPedagio._nsURI_ = thisURI)) then
      pagamentoPedagio := tpagamentoPedagio.Create(xn)
    else if (sn = sntpDetalheRetornoOperacaoPagamento_statusPagamentoValor) then
      statusPagamentoValor :=  xn.text // tbyte
    else if (sn = sntpDetalheRetornoOperacaoPagamento_statusPagamentoPedagio) then
      statusPagamentoPedagio :=  xn.text // tbyte
    else if (sn = sntpDetalheRetornoOperacaoPagamento_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDetalheRetornoOperacaoPagamento.Destroy;
begin
  Fmensagens.Free;
  Fautorizacao.Free;
  Fpedagio.Free;
  Fsaldo.Free;
  FpagamentoPedagio.Free;
  inherited;
end; // destructor ...

procedure ttpDetalheRetornoOperacaoPagamento.Setautorizacao(value:tautorizacao_tpDetalheRetornoOperacaoPagamento);
begin
  Fautorizacao := value;
  Fautorizacao_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.SetdataPagamento(value:string);
begin
  FdataPagamento := value;
  FdataPagamento_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.SetvalorPagamento(value:string);
begin
  FvalorPagamento := value;
  FvalorPagamento_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.Setpedagio(value:tpedagio_tpDetalheRetornoOperacaoPagamento);
begin
  Fpedagio := value;
  Fpedagio_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.Setsaldo(value:tsaldo_tpDetalheRetornoOperacaoPagamento);
begin
  Fsaldo := value;
  Fsaldo_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.SetpagamentoPedagio(value:tpagamentoPedagio);
begin
  FpagamentoPedagio := value;
  FpagamentoPedagio_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.SetstatusPagamentoValor(value:tbyte);
begin
  FstatusPagamentoValor := value;
  FstatusPagamentoValor_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.SetstatusPagamentoPedagio(value:tbyte);
begin
  FstatusPagamentoPedagio := value;
  FstatusPagamentoPedagio_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.SetgestoraCartao(value:string);
begin
  FgestoraCartao := value;
  FgestoraCartao_IsSet_ := true;
end;

procedure ttpDetalheRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDetalheRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpDetalheRetornoOperacaoPagamento_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpDetalheRetornoOperacaoPagamento_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if dataPagamento_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDetalheRetornoOperacaoPagamento_dataPagamento));
    xn.text := FdataPagamento;
  end;
  if valorPagamento_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDetalheRetornoOperacaoPagamento_valorPagamento));
    xn.text := FvalorPagamento;
  end;
  if Assigned(Fpedagio) then
  begin
    xn := aNode.addChildByName(sntpDetalheRetornoOperacaoPagamento_pedagio);
    Fpedagio.Save(xn);
  end;
  if Assigned(Fsaldo) then
  begin
    xn := aNode.addChildByName(sntpDetalheRetornoOperacaoPagamento_saldo);
    Fsaldo.Save(xn);
  end;
  if Assigned(FpagamentoPedagio) then
  begin
    xn := aNode.addChildByName(sntpDetalheRetornoOperacaoPagamento_pagamentoPedagio);
    FpagamentoPedagio.Save(xn);
  end;
  if statusPagamentoValor_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDetalheRetornoOperacaoPagamento_statusPagamentoValor));
    xn.text := FstatusPagamentoValor;
  end;
  if statusPagamentoPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDetalheRetornoOperacaoPagamento_statusPagamentoPedagio));
    xn.text := FstatusPagamentoPedagio;
  end;
  if gestoraCartao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDetalheRetornoOperacaoPagamento_gestoraCartao));
    xn.text := FgestoraCartao;
  end;
end; // procedure save

{ ttpRetornoConsultaOperacaoPagamento }

function ttpRetornoConsultaOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoConsultaOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaOperacaoPagamento_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      mensagens := tmensagens_tpRetornoConsultaOperacaoPagamento.Create(xn)
    else if (sn = sntpRetornoConsultaOperacaoPagamento_envioConsultaOperacaoPagamento) then
      envioConsultaOperacaoPagamento := ttpInfConsultaOperacaoPagamento.Create(xn)
    else if (sn = sntpRetornoConsultaOperacaoPagamento_retConsultaOperacaoPagamento) then
      retConsultaOperacaoPagamento := ttpDetalheRetornoOperacaoPagamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaOperacaoPagamento.Destroy;
begin
  Fmensagens.Free;
  if assigned(FenvioConsultaOperacaoPagamento) then  FenvioConsultaOperacaoPagamento.free;
  if assigned(FretConsultaOperacaoPagamento) then  FretConsultaOperacaoPagamento.free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaOperacaoPagamento.Setmensagens(value:tmensagens_tpRetornoConsultaOperacaoPagamento);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaOperacaoPagamento.SetenvioConsultaOperacaoPagamento(value:ttpInfConsultaOperacaoPagamento);
begin
  FenvioConsultaOperacaoPagamento := value;
  FenvioConsultaOperacaoPagamento_IsSet_ := true;
end;

procedure ttpRetornoConsultaOperacaoPagamento.SetretConsultaOperacaoPagamento(value:ttpDetalheRetornoOperacaoPagamento);
begin
  FretConsultaOperacaoPagamento := value;
  FretConsultaOperacaoPagamento_IsSet_ := true;
end;

procedure ttpRetornoConsultaOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaOperacaoPagamento_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(FenvioConsultaOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaOperacaoPagamento_envioConsultaOperacaoPagamento);
    FenvioConsultaOperacaoPagamento.Save(xn);
  end;
  if Assigned(FretConsultaOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaOperacaoPagamento_retConsultaOperacaoPagamento);
    FretConsultaOperacaoPagamento.Save(xn);
  end;
end; // procedure save

{ tpagamento_tpRetornoOperacaoPagamento }

function tpagamento_tpRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpagamento_tpRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpagamento_tpRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FenvioOperacaoPagamento := ttpInfRetornoOperacaoPagamento.Create;
end; // constructor ...

constructor tpagamento_tpRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = anpagamento_tpRetornoOperacaoPagamento_impAuto then
      impAuto := aRoot.attribute[i]; // tbyte
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpagamento_tpRetornoOperacaoPagamento_envioOperacaoPagamento) then
      FenvioOperacaoPagamento := ttpInfRetornoOperacaoPagamento.Create(xn)
    else if (sn = snpagamento_tpRetornoOperacaoPagamento_retornoOperacaoPagamento) then
      retornoOperacaoPagamento := ttpRetornoOperacaoPagamentoDetalhe.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpagamento_tpRetornoOperacaoPagamento.Destroy;
begin
  if assigned(FenvioOperacaoPagamento) then  FenvioOperacaoPagamento.free;
  if assigned(FretornoOperacaoPagamento) then  FretornoOperacaoPagamento.free;
  inherited;
end; // destructor ...

procedure tpagamento_tpRetornoOperacaoPagamento.SetretornoOperacaoPagamento(value:ttpRetornoOperacaoPagamentoDetalhe);
begin
  FretornoOperacaoPagamento := value;
  FretornoOperacaoPagamento_IsSet_ := true;
end;

procedure tpagamento_tpRetornoOperacaoPagamento.SetimpAuto(value:tbyte);
begin
  FimpAuto := value;
  FimpAuto_IsSet_ := true;
end;

procedure tpagamento_tpRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pagamento_tpRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if impAuto_IsSet_ then
    aNode.attribute[anpagamento_tpRetornoOperacaoPagamento_impAuto] := FimpAuto;

  if Assigned(FenvioOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(snpagamento_tpRetornoOperacaoPagamento_envioOperacaoPagamento);
    FenvioOperacaoPagamento.Save(xn);
  end;
  if Assigned(FretornoOperacaoPagamento) then
  begin
    xn := aNode.addChildByName(snpagamento_tpRetornoOperacaoPagamento_retornoOperacaoPagamento);
    FretornoOperacaoPagamento.Save(xn);
  end;
end; // procedure save

{ tmensagens_tpRetornoOperacaoPagamento }

function tmensagens_tpRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpRetornoOperacaoPagamento_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpRetornoOperacaoPagamento.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpRetornoOperacaoPagamento_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoOperacaoPagamento }

function ttpRetornoOperacaoPagamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoOperacaoPagamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoOperacaoPagamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoOperacaoPagamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoOperacaoPagamento_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      mensagens := tmensagens_tpRetornoOperacaoPagamento.Create(xn)
    else if (sn = sntpRetornoOperacaoPagamento_pagamento)
      and ((thisURI='') or (tpagamento._nsURI_ = thisURI)) then
      pagamento := tpagamento_tpRetornoOperacaoPagamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoOperacaoPagamento.Destroy;
begin
  Fmensagens.Free;
  Fpagamento.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoOperacaoPagamento.Setmensagens(value:tmensagens_tpRetornoOperacaoPagamento);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoOperacaoPagamento.Setpagamento(value:tpagamento_tpRetornoOperacaoPagamento);
begin
  Fpagamento := value;
  Fpagamento_IsSet_ := true;
end;

procedure ttpRetornoOperacaoPagamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoOperacaoPagamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoOperacaoPagamento_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(Fpagamento) then
  begin
    xn := aNode.addChildByName(sntpRetornoOperacaoPagamento_pagamento);
    Fpagamento.Save(xn);
  end;
end; // procedure save

{ tinfConsulta }

function tinfConsulta.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfConsulta._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfConsulta.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := ttpMensagem.Create;
end; // constructor ...

constructor tinfConsulta.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfConsulta_mensagem) then
      Fmensagem := ttpMensagem.Create(xn)
    else if (sn = sninfConsulta_nomeColaborador) then
      nomeColaborador :=  xn.text // string
    else if (sn = sninfConsulta_cpfColaborador) then
      cpfColaborador :=  xn.text // string
    else if (sn = sninfConsulta_dataEntregaCartao) then
      dataEntregaCartao :=  xn.text // string
    else if (sn = sninfConsulta_cartaoId) then
      cartaoId := StrToInt64Def(xn.text, 0)
    else if (sn = sninfConsulta_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else if (sn = sninfConsulta_saldo)
      and ((thisURI='') or (tsaldo._nsURI_ = thisURI)) then
      Fsaldo := tsaldo.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfConsulta.Destroy;
begin
  if assigned(Fmensagem) then  Fmensagem.free;
  Fsaldo.Free;
  inherited;
end; // destructor ...

procedure tinfConsulta.SetnomeColaborador(value:string);
begin
  FnomeColaborador := value;
  FnomeColaborador_IsSet_ := true;
end;

procedure tinfConsulta.SetcpfColaborador(value:string);
begin
  FcpfColaborador := value;
  FcpfColaborador_IsSet_ := true;
end;

procedure tinfConsulta.SetdataEntregaCartao(value:string);
begin
  FdataEntregaCartao := value;
  FdataEntregaCartao_IsSet_ := true;
end;

procedure tinfConsulta.SetcartaoId(value:int64);
begin
  FcartaoId := value;
  FcartaoId_IsSet_ := true;
end;

procedure tinfConsulta.SetgestoraCartao(value:string);
begin
  FgestoraCartao := value;
  FgestoraCartao_IsSet_ := true;
end;

procedure tinfConsulta.Setsaldo(value:tsaldo);
begin
  Fsaldo := value;
  Fsaldo_IsSet_ := true;
end;

procedure tinfConsulta.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infConsulta')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagem) then
  begin
    xn := aNode.addChildByName(sninfConsulta_mensagem);
    Fmensagem.Save(xn);
  end;
  if nomeColaborador_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfConsulta_nomeColaborador));
    xn.text := FnomeColaborador;
  end;
  if cpfColaborador_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfConsulta_cpfColaborador));
    xn.text := FcpfColaborador;
  end;
  if dataEntregaCartao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfConsulta_dataEntregaCartao));
    xn.text := FdataEntregaCartao;
  end;
  if cartaoId_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfConsulta_cartaoId));
    xn.text := IntToStr(FcartaoId);
  end;
  if gestoraCartao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfConsulta_gestoraCartao));
    xn.text := FgestoraCartao;
  end;
  if Assigned(Fsaldo) then
  begin
    xn := aNode.addChildByName(sninfConsulta_saldo);
    Fsaldo.Save(xn);
  end;
end; // procedure save

{ tretornoConsulta }

function tretornoConsulta.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tretornoConsulta._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tretornoConsulta.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfConsulta := tManagedStringlist.Create;
end; // constructor ...

constructor tretornoConsulta.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  ainfConsulta: tinfConsulta;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snretornoConsulta_infConsulta)
      and ((thisURI='') or (tinfConsulta._nsURI_ = thisURI)) then
    begin
      ainfConsulta := tinfConsulta.Create(xn);
      FinfConsulta.AddObject('?', ainfConsulta);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tretornoConsulta.Destroy;
begin
  FinfConsulta.Free;
  inherited;
end; // destructor ...

procedure tretornoConsulta.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'retornoConsulta')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "infConsulta" is tManagedStringlist
  if Assigned(FinfConsulta) then
    for i:=0 to FinfConsulta.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snretornoConsulta_infConsulta));
      tinfConsulta(FinfConsulta.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tmensagens_tpRetornoConsultaSaldoCartaoFrota }

function tmensagens_tpRetornoConsultaSaldoCartaoFrota.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpRetornoConsultaSaldoCartaoFrota._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpRetornoConsultaSaldoCartaoFrota.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpRetornoConsultaSaldoCartaoFrota.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpRetornoConsultaSaldoCartaoFrota_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpRetornoConsultaSaldoCartaoFrota.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpRetornoConsultaSaldoCartaoFrota.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpRetornoConsultaSaldoCartaoFrota')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpRetornoConsultaSaldoCartaoFrota_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoConsultaSaldoCartaoFrota }

function ttpRetornoConsultaSaldoCartaoFrota.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaSaldoCartaoFrota._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaSaldoCartaoFrota.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FenvioConsulta := tenvioConsulta.Create;
end; // constructor ...

constructor ttpRetornoConsultaSaldoCartaoFrota.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaSaldoCartaoFrota_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      mensagens := tmensagens_tpRetornoConsultaSaldoCartaoFrota.Create(xn)
    else if (sn = sntpRetornoConsultaSaldoCartaoFrota_envioConsulta)
      and ((thisURI='') or (tenvioConsulta._nsURI_ = thisURI)) then
      FenvioConsulta := tenvioConsulta.Create(xn)
    else if (sn = sntpRetornoConsultaSaldoCartaoFrota_retornoConsulta)
      and ((thisURI='') or (tretornoConsulta._nsURI_ = thisURI)) then
      retornoConsulta := tretornoConsulta.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaSaldoCartaoFrota.Destroy;
begin
  Fmensagens.Free;
  FenvioConsulta.Free;
  FretornoConsulta.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaSaldoCartaoFrota.Setmensagens(value:tmensagens_tpRetornoConsultaSaldoCartaoFrota);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaSaldoCartaoFrota.SetretornoConsulta(value:tretornoConsulta);
begin
  FretornoConsulta := value;
  FretornoConsulta_IsSet_ := true;
end;

procedure ttpRetornoConsultaSaldoCartaoFrota.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaSaldoCartaoFrota')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaSaldoCartaoFrota_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(FenvioConsulta) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaSaldoCartaoFrota_envioConsulta);
    FenvioConsulta.Save(xn);
  end;
  if Assigned(FretornoConsulta) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaSaldoCartaoFrota_retornoConsulta);
    FretornoConsulta.Save(xn);
  end;
end; // procedure save

{ tmensagens_tpRetornoConsultaResumoOT }

function tmensagens_tpRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens_tpRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens_tpRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens_tpRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_tpRetornoConsultaResumoOT_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens_tpRetornoConsultaResumoOT.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens_tpRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens_tpRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_tpRetornoConsultaResumoOT_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tmensagens }

function tmensagens.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tmensagens._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tmensagens.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := tManagedStringlist.Create;
end; // constructor ...

constructor tmensagens.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snmensagens_mensagem) then
    begin
      // list of simple type
      Fmensagem.AddObject('?', ttpMensagem.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tmensagens.Destroy;
begin
  Fmensagem.Free;
  inherited;
end; // destructor ...

procedure tmensagens.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'mensagens')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "mensagem" is tManagedStringlist
  if Assigned(Fmensagem) then
    for i:=0 to Fmensagem.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snmensagens_mensagem));
      ttpMensagem(Fmensagem.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

class function tmensagens.CreateFromXmlString(s: string): tmensagens;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := tmensagens.Create( parser );
   finally
      parser.Free;
   end;
end;

{ ttpRetornoPadrao }

function ttpRetornoPadrao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoPadrao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoPadrao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := ttpMensagem.Create;
end; // constructor ...

constructor ttpRetornoPadrao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpRetornoPadrao_versao then
      versao := aRoot.attribute[i]; // t
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoPadrao_mensagem) then
      Fmensagem := ttpMensagem.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoPadrao.Destroy;
begin
  if assigned(Fmensagem) then  Fmensagem.free;
  inherited;
end; // destructor ...

procedure ttpRetornoPadrao.Setversao(value:t);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpRetornoPadrao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoPadrao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpRetornoPadrao_versao] := Fversao;

  if Assigned(Fmensagem) then
  begin
    xn := aNode.addChildByName(sntpRetornoPadrao_mensagem);
    Fmensagem.Save(xn);
  end;
end; // procedure save

{ ttpMensagemErro }

function ttpMensagemErro.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpMensagemErro._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpMensagemErro.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdescricao := tManagedStringlist.Create;
end; // constructor ...

constructor ttpMensagemErro.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpMensagemErro_descricao) then
    begin
      // list of simple type
      Fdescricao.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpMensagemErro.Destroy;
begin
  Fdescricao.Free;
  inherited;
end; // destructor ...

procedure ttpMensagemErro.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpMensagemErro')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "descricao" is tManagedStringlist
  // but of simple elements
  if Assigned(Fdescricao) then
    for i:=0 to Fdescricao.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpMensagemErro_descricao));
      xn.text := Fdescricao.Strings[i];
    end; // for i:=0 to ...
end; // procedure save

class function ttpMensagemErro.CreateFromXmlString(
  s: string): ttpMensagemErro;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := ttpMensagemErro.Create( parser );
   finally
      parser.Free;
   end;
end;
{ ttpRetornoConfiguracao }

function ttpRetornoConfiguracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConfiguracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConfiguracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fimpressao := tManagedStringlist.Create;
  Fconfiguracao := tconfiguracao.Create;
end; // constructor ...

constructor ttpRetornoConfiguracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aimpressao: timpressao;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConfiguracao_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpRetornoConfiguracao_mensagens) then
      mensagens := ttpMensagemErro.Create(xn)
    else if (sn = sntpRetornoConfiguracao_impressao)
      and ((thisURI='') or (timpressao._nsURI_ = thisURI)) then
    begin
      aimpressao := timpressao.Create(xn);
      Fimpressao.AddObject('?', aimpressao);
    end
    else if (sn = sntpRetornoConfiguracao_configuracao)
      and ((thisURI='') or (tconfiguracao._nsURI_ = thisURI)) then
      Fconfiguracao := tconfiguracao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConfiguracao.Destroy;
begin
  if assigned(Fmensagens) then  Fmensagens.free;
  Fimpressao.Free;
  Fconfiguracao.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoConfiguracao.Setmensagens(value:ttpMensagemErro);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConfiguracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConfiguracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoConfiguracao_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConfiguracao_mensagens);
    Fmensagens.Save(xn);
  end;
  // element "impressao" is tManagedStringlist
  if Assigned(Fimpressao) then
    for i:=0 to Fimpressao.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoConfiguracao_impressao));
      timpressao_tpRetornoConfiguracao(Fimpressao.Objects[i]).Save(xn);
    end; // for i:=0 to ...
  if Assigned(Fconfiguracao) then
  begin
    xn := aNode.addChildByName(sntpRetornoConfiguracao_configuracao);
    Fconfiguracao.Save(xn);
  end;
end; // procedure save

{ ttpRetornoImpressaoDocumentos }

function ttpRetornoImpressaoDocumentos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoImpressaoDocumentos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoImpressaoDocumentos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fimpressao := tManagedStringlist.Create;
end; // constructor ...

constructor ttpRetornoImpressaoDocumentos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aimpressao: timpressao;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoImpressaoDocumentos_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpRetornoImpressaoDocumentos_mensagens) then
      mensagens := ttpMensagemErro.Create(xn)
    else if (sn = sntpRetornoImpressaoDocumentos_impressao)
      and ((thisURI='') or (timpressao._nsURI_ = thisURI)) then
    begin
      aimpressao := timpressao.Create(xn);
      Fimpressao.AddObject('?', aimpressao);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoImpressaoDocumentos.Destroy;
begin
  if assigned(Fmensagens) then  Fmensagens.free;
  Fimpressao.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoImpressaoDocumentos.Setmensagens(value:ttpMensagemErro);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoImpressaoDocumentos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoImpressaoDocumentos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoImpressaoDocumentos_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoImpressaoDocumentos_mensagens);
    Fmensagens.Save(xn);
  end;
  // element "impressao" is tManagedStringlist
  if Assigned(Fimpressao) then
    for i:=0 to Fimpressao.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoImpressaoDocumentos_impressao));
      timpressao_tpRetornoImpressaoDocumentos(Fimpressao.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoConsultaImpressaoDocumentos }

function ttpRetornoConsultaImpressaoDocumentos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaImpressaoDocumentos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaImpressaoDocumentos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoConsultaImpressaoDocumentos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaImpressaoDocumentos_mensagens) then
      mensagens := ttpMensagemErro.Create(xn)
    else if (sn = sntpRetornoConsultaImpressaoDocumentos_infImpressao) then
      infImpressao := ttpRetornoImpressaoDocumentos.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaImpressaoDocumentos.Destroy;
begin
  if assigned(Fmensagens) then  Fmensagens.free;
  if assigned(FinfImpressao) then  FinfImpressao.free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaImpressaoDocumentos.Setmensagens(value:ttpMensagemErro);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaImpressaoDocumentos.SetinfImpressao(value:ttpRetornoImpressaoDocumentos);
begin
  FinfImpressao := value;
  FinfImpressao_IsSet_ := true;
end;

procedure ttpRetornoConsultaImpressaoDocumentos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaImpressaoDocumentos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaImpressaoDocumentos_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(FinfImpressao) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaImpressaoDocumentos_infImpressao);
    FinfImpressao.Save(xn);
  end;
end; // procedure save

{ ttpRetornoConsultaEncerramentoOT }

function ttpRetornoConsultaEncerramentoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaEncerramentoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaEncerramentoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoConsultaEncerramentoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaEncerramentoOT_mensagens) then
      mensagens := ttpMensagemErro.Create(xn)
    else if (sn = sntpRetornoConsultaEncerramentoOT_encerramento) then
      encerramento := ttpRetornoEncerramentoOT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaEncerramentoOT.Destroy;
begin
  if assigned(Fmensagens) then  Fmensagens.free;
  if assigned(Fencerramento) then  Fencerramento.free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaEncerramentoOT.Setmensagens(value:ttpMensagemErro);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaEncerramentoOT.Setencerramento(value:ttpRetornoEncerramentoOT);
begin
  Fencerramento := value;
  Fencerramento_IsSet_ := true;
end;

procedure ttpRetornoConsultaEncerramentoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaEncerramentoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaEncerramentoOT_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(Fencerramento) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaEncerramentoOT_encerramento);
    Fencerramento.Save(xn);
  end;
end; // procedure save

{ ttpRetornoConsultaPgtos }

function ttpRetornoConsultaPgtos.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaPgtos._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaPgtos.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoConsultaPgtos.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaPgtos_mensagens) then
      mensagens := ttpMensagemErro.Create(xn)
    else if (sn = sntpRetornoConsultaPgtos_pgtos)
      and ((thisURI='') or (tpgtos._nsURI_ = thisURI)) then
      pgtos := tpgtos.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaPgtos.Destroy;
begin
  if assigned(Fmensagens) then  Fmensagens.free;
  Fpgtos.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaPgtos.Setmensagens(value:ttpMensagemErro);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaPgtos.Setpgtos(value:tpgtos);
begin
  Fpgtos := value;
  Fpgtos_IsSet_ := true;
end;

procedure ttpRetornoConsultaPgtos.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaPgtos')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaPgtos_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(Fpgtos) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaPgtos_pgtos);
    Fpgtos.Save(xn);
  end;
end; // procedure save

class function ttpRetornoConsultaPgtos.CreateFromXmlString(
  s: string): ttpRetornoConsultaPgtos;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := ttpRetornoConsultaPgtos.Create( parser );
   finally
      parser.Free;
   end;
end;

{ ttpRetornoPagamentoImediato }

function ttpRetornoPagamentoImediato.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoPagamentoImediato._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoPagamentoImediato.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoPagamentoImediato.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoPagamentoImediato_mensagens) then
      mensagens := ttpMensagemErro.Create(xn)
    else if (sn = sntpRetornoPagamentoImediato_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sntpRetornoPagamentoImediato_autorizacao) then
      autorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpRetornoPagamentoImediato_nomeParcela) then
      nomeParcela :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoPagamentoImediato.Destroy;
begin
  if assigned(Fmensagens) then  Fmensagens.free;
  if assigned(Fautorizacao) then  Fautorizacao.free;
  inherited;
end; // destructor ...

procedure ttpRetornoPagamentoImediato.Setmensagens(value:ttpMensagemErro);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoPagamentoImediato.Setcnpj(value:string);
begin
  Fcnpj := value;
  Fcnpj_IsSet_ := true;
end;

procedure ttpRetornoPagamentoImediato.Setautorizacao(value:ttpAutorizacaoOT);
begin
  Fautorizacao := value;
  Fautorizacao_IsSet_ := true;
end;

procedure ttpRetornoPagamentoImediato.SetnomeParcela(value:string);
begin
  FnomeParcela := value;
  FnomeParcela_IsSet_ := true;
end;

procedure ttpRetornoPagamentoImediato.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoPagamentoImediato')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoPagamentoImediato_mensagens);
    Fmensagens.Save(xn);
  end;
  if cnpj_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPagamentoImediato_cnpj));
    xn.text := Fcnpj;
  end;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpRetornoPagamentoImediato_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if nomeParcela_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoPagamentoImediato_nomeParcela));
    xn.text := FnomeParcela;
  end;
end; // procedure save

class function ttpRetornoPagamentoImediato.CreateFromXmlString(
  s: string): ttpRetornoPagamentoImediato;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := ttpRetornoPagamentoImediato.Create( parser );
   finally
      parser.Free;
   end;
end;

{ ttpRetornoConsultaCancelamento }

function ttpRetornoConsultaCancelamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaCancelamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaCancelamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoConsultaCancelamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaCancelamento_mensagens) then
      mensagens := ttpMensagemErro.Create(xn)
    else if (sn = sntpRetornoConsultaCancelamento_cancelamento) then
      cancelamento := ttpRetornoCancelamento.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaCancelamento.Destroy;
begin
  if assigned(Fmensagens) then  Fmensagens.free;
  if assigned(Fcancelamento) then  Fcancelamento.free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaCancelamento.Setmensagens(value:ttpMensagemErro);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaCancelamento.Setcancelamento(value:ttpRetornoCancelamento);
begin
  Fcancelamento := value;
  Fcancelamento_IsSet_ := true;
end;

procedure ttpRetornoConsultaCancelamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaCancelamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaCancelamento_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(Fcancelamento) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaCancelamento_cancelamento);
    Fcancelamento.Save(xn);
  end;
end; // procedure save

class function ttpRetornoConsultaCancelamento.CreateFromXmlString(
  s: string): ttpRetornoConsultaCancelamento;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := ttpRetornoConsultaCancelamento.Create( parser );
   finally
      parser.Free;
   end;
end;

{ ttpDirecionamentoPedagio }

function ttpDirecionamentoPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDirecionamentoPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDirecionamentoPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Frota := ttpRota.Create;
end; // constructor ...

constructor ttpDirecionamentoPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDirecionamentoPedagio_pedagioERP) then
      pedagioERP :=  xn.text // string
    else if (sn = sntpDirecionamentoPedagio_cpf) then
      cpf :=  xn.text // string
    else if (sn = sntpDirecionamentoPedagio_valor) then
      valor :=  xn.text // string
    else if (sn = sntpDirecionamentoPedagio_rota) then
      Frota := ttpRota.Create(xn)
    else if (sn = sntpDirecionamentoPedagio_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDirecionamentoPedagio.Destroy;
begin
  if assigned(Frota) then  Frota.free;
  inherited;
end; // destructor ...

procedure ttpDirecionamentoPedagio.Setvalor(value:string);
begin
  Fvalor := value;
  Fvalor_IsSet_ := true;
end;

procedure ttpDirecionamentoPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDirecionamentoPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDirecionamentoPedagio_pedagioERP));
  xn.text := FpedagioERP;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDirecionamentoPedagio_cpf));
  xn.text := Fcpf;
  if valor_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDirecionamentoPedagio_valor));
    xn.text := Fvalor;
  end;
  if Assigned(Frota) then
  begin
    xn := aNode.addChildByName(sntpDirecionamentoPedagio_rota);
    Frota.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDirecionamentoPedagio_categoriaPedagio));
  xn.text := IntToStr(FcategoriaPedagio);
end; // procedure save

{ tdirecionamento_pedagio_financeiro }

function tdirecionamento_pedagio_financeiro.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdirecionamento_pedagio_financeiro._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdirecionamento_pedagio_financeiro.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tdirecionamento_pedagio_financeiro.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndirecionamento_pedagio_financeiro_adicionar) then
      adicionar := ttpDirecionamentoPedagio.Create(xn)
    else if (sn = sndirecionamento_pedagio_financeiro_remover)
      and ((thisURI='') or (tremover._nsURI_ = thisURI)) then
      remover := tremover.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdirecionamento_pedagio_financeiro.Destroy;
begin
  if assigned(Fadicionar) then  Fadicionar.free;
  Fremover.Free;
  inherited;
end; // destructor ...

procedure tdirecionamento_pedagio_financeiro.Setadicionar(value:ttpDirecionamentoPedagio);
begin
  Fadicionar := value;
  Fadicionar_IsSet_ := true;
end;

procedure tdirecionamento_pedagio_financeiro.Setremover(value:tremover);
begin
  Fremover := value;
  Fremover_IsSet_ := true;
end;

procedure tdirecionamento_pedagio_financeiro.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'direcionamento_pedagio_financeiro')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fadicionar) then
  begin
    xn := aNode.addChildByName(sndirecionamento_pedagio_financeiro_adicionar);
    Fadicionar.Save(xn);
  end;
  if Assigned(Fremover) then
  begin
    xn := aNode.addChildByName(sndirecionamento_pedagio_financeiro_remover);
    Fremover.Save(xn);
  end;
end; // procedure save

{ tpedagio_financeiro }

function tpedagio_financeiro.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpedagio_financeiro._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpedagio_financeiro.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpedagio_financeiro.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpedagio_financeiro_valor) then
      valor :=  xn.text // string
    else if (sn = snpedagio_financeiro_direcionamento)
      and ((thisURI='') or (tdirecionamento._nsURI_ = thisURI)) then
      direcionamento := tdirecionamento_pedagio_financeiro.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpedagio_financeiro.Destroy;
begin
  Fdirecionamento.Free;
  inherited;
end; // destructor ...

procedure tpedagio_financeiro.Setvalor(value:string);
begin
  Fvalor := value;
  Fvalor_IsSet_ := true;
end;

procedure tpedagio_financeiro.Setdirecionamento(value:tdirecionamento_pedagio_financeiro);
begin
  Fdirecionamento := value;
  Fdirecionamento_IsSet_ := true;
end;

procedure tpedagio_financeiro.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pedagio_financeiro')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if valor_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpedagio_financeiro_valor));
    xn.text := Fvalor;
  end;
  if Assigned(Fdirecionamento) then
  begin
    xn := aNode.addChildByName(snpedagio_financeiro_direcionamento);
    Fdirecionamento.Save(xn);
  end;
end; // procedure save

{ tfinanceiro }

function tfinanceiro.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tfinanceiro._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tfinanceiro.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tfinanceiro.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snfinanceiro_novaParc) then
      novaParc := ttpAlterarParcela.Create(xn)
    else if (sn = snfinanceiro_ajustaParc)
      and ((thisURI='') or (tajustaParc._nsURI_ = thisURI)) then
      ajustaParc := tajustaParc.Create(xn)
    else if (sn = snfinanceiro_pedagio)
      and ((thisURI='') or (tpedagio._nsURI_ = thisURI)) then
      pedagio := tpedagio_financeiro.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tfinanceiro.Destroy;
begin
  if assigned(FnovaParc) then  FnovaParc.free;
  FajustaParc.Free;
  Fpedagio.Free;
  inherited;
end; // destructor ...

procedure tfinanceiro.SetnovaParc(value:ttpAlterarParcela);
begin
  FnovaParc := value;
  FnovaParc_IsSet_ := true;
end;

procedure tfinanceiro.SetajustaParc(value:tajustaParc);
begin
  FajustaParc := value;
  FajustaParc_IsSet_ := true;
end;

procedure tfinanceiro.Setpedagio(value:tpedagio_financeiro);
begin
  Fpedagio := value;
  Fpedagio_IsSet_ := true;
end;

procedure tfinanceiro.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'financeiro')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FnovaParc) then
  begin
    xn := aNode.addChildByName(snfinanceiro_novaParc);
    FnovaParc.Save(xn);
  end;
  if Assigned(FajustaParc) then
  begin
    xn := aNode.addChildByName(snfinanceiro_ajustaParc);
    FajustaParc.Save(xn);
  end;
  if Assigned(Fpedagio) then
  begin
    xn := aNode.addChildByName(snfinanceiro_pedagio);
    Fpedagio.Save(xn);
  end;
end; // procedure save

{ talteracao }

function talteracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function talteracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor talteracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor talteracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snalteracao_ANTT)
      and ((thisURI='') or (tANTT._nsURI_ = thisURI)) then
      ANTT := tANTT.Create(xn)
    else if (sn = snalteracao_financeiro)
      and ((thisURI='') or (tfinanceiro._nsURI_ = thisURI)) then
      financeiro := tfinanceiro.Create(xn)
    else if (sn = snalteracao_adicionais) then
      adicionais := ttpAdicionalImpressao.Create(xn)
    else if (sn = snalteracao_semMF)
      and ((thisURI='') or (tsemMF._nsURI_ = thisURI)) then
      semMF := tsemMF.Create(xn)
    else if (sn = snalteracao_condutor)
      and ((thisURI='') or (tcondutor._nsURI_ = thisURI)) then
      condutor := tcondutor_alteracao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor talteracao.Destroy;
begin
  FANTT.Free;
  Ffinanceiro.Free;
  if assigned(Fadicionais) then  Fadicionais.free;
  FsemMF.Free;
  Fcondutor.Free;
  inherited;
end; // destructor ...

procedure talteracao.SetANTT(value:tANTT);
begin
  FANTT := value;
  FANTT_IsSet_ := true;
end;

procedure talteracao.Setfinanceiro(value:tfinanceiro);
begin
  Ffinanceiro := value;
  Ffinanceiro_IsSet_ := true;
end;

procedure talteracao.Setadicionais(value:ttpAdicionalImpressao);
begin
  Fadicionais := value;
  Fadicionais_IsSet_ := true;
end;

procedure talteracao.SetsemMF(value:tsemMF);
begin
  FsemMF := value;
  FsemMF_IsSet_ := true;
end;

procedure talteracao.Setcondutor(value:tcondutor_alteracao);
begin
  Fcondutor := value;
  Fcondutor_IsSet_ := true;
end;

procedure talteracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'alteracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FANTT) then
  begin
    xn := aNode.addChildByName(snalteracao_ANTT);
    FANTT.Save(xn);
  end;
  if Assigned(Ffinanceiro) then
  begin
    xn := aNode.addChildByName(snalteracao_financeiro);
    Ffinanceiro.Save(xn);
  end;
  if Assigned(Fadicionais) then
  begin
    xn := aNode.addChildByName(snalteracao_adicionais);
    Fadicionais.Save(xn);
  end;
  if Assigned(FsemMF) then
  begin
    xn := aNode.addChildByName(snalteracao_semMF);
    FsemMF.Save(xn);
  end;
  if Assigned(Fcondutor) then
  begin
    xn := aNode.addChildByName(snalteracao_condutor);
    Fcondutor.Save(xn);
  end;
end; // procedure save

{ talteracoes }

function talteracoes.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function talteracoes._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor talteracoes.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Falteracao := tManagedStringlist.Create;
end; // constructor ...

constructor talteracoes.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  aalteracao: talteracao;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snalteracoes_alteracao)
      and ((thisURI='') or (talteracao._nsURI_ = thisURI)) then
    begin
      aalteracao := talteracao.Create(xn);
      Falteracao.AddObject('?', aalteracao);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor talteracoes.Destroy;
begin
  Falteracao.Free;
  inherited;
end; // destructor ...

procedure talteracoes.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'alteracoes')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "alteracao" is tManagedStringlist
  if Assigned(Falteracao) then
    for i:=0 to Falteracao.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snalteracoes_alteracao));
      talteracao(Falteracao.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tinfOT_tpAlteraOT }

function tinfOT_tpAlteraOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfOT_tpAlteraOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfOT_tpAlteraOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
  Falteracoes := talteracoes.Create;
end; // constructor ...

constructor tinfOT_tpAlteraOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = aninfOT_tpAlteraOT_ID then
      ID := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfOT_tpAlteraOT_cnpj) then
      cnpj :=  xn.text // string
    else if (sn = sninfOT_tpAlteraOT_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sninfOT_tpAlteraOT_alteracoes)
      and ((thisURI='') or (talteracoes._nsURI_ = thisURI)) then
      Falteracoes := talteracoes.Create(xn)
    else if (sn = sninfOT_tpAlteraOT_motivo) then
      motivo :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfOT_tpAlteraOT.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  Falteracoes.Free;
  inherited;
end; // destructor ...

procedure tinfOT_tpAlteraOT.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure tinfOT_tpAlteraOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[aninfOT_tpAlteraOT_ID] := FID;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfOT_tpAlteraOT_cnpj));
  xn.text := Fcnpj;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sninfOT_tpAlteraOT_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if Assigned(Falteracoes) then
  begin
    xn := aNode.addChildByName(sninfOT_tpAlteraOT_alteracoes);
    Falteracoes.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfOT_tpAlteraOT_motivo));
  xn.text := Fmotivo;
end; // procedure save

{ ttpAlteraOT }

function ttpAlteraOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpAlteraOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpAlteraOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfOT := tinfOT_tpAlteraOT.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor ttpAlteraOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpAlteraOT_infOT)
      and ((thisURI='') or (tinfOT._nsURI_ = thisURI)) then
      FinfOT := tinfOT_tpAlteraOT.Create(xn)
    else if (sn = sntpAlteraOT_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpAlteraOT.Destroy;
begin
  FinfOT.Free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpAlteraOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpAlteraOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FinfOT) then
  begin
    xn := aNode.addChildByName(sntpAlteraOT_infOT);
    FinfOT.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpAlteraOT_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ ttpAlteracaoOT }

function ttpAlteracaoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpAlteracaoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpAlteracaoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FOT := ttpAlteraOT.Create;
end; // constructor ...

constructor ttpAlteracaoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpAlteracaoOT_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpAlteracaoOT_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpAlteracaoOT_OT) then
      FOT := ttpAlteraOT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpAlteracaoOT.Destroy;
begin
  if assigned(FOT) then  FOT.free;
  inherited;
end; // destructor ...

procedure ttpAlteracaoOT.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpAlteracaoOT.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpAlteracaoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpAlteracaoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpAlteracaoOT_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpAlteracaoOT_token] := Ftoken;

  if Assigned(FOT) then
  begin
    xn := aNode.addChildByName(sntpAlteracaoOT_OT);
    FOT.Save(xn);
  end;
end; // procedure save

{ tdirecionamentosPedagio }

function tdirecionamentosPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdirecionamentosPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdirecionamentosPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdirecionamento := tManagedStringlist.Create;
end; // constructor ...

constructor tdirecionamentosPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndirecionamentosPedagio_direcionamento) then
    begin
      // list of simple type
      Fdirecionamento.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdirecionamentosPedagio.Destroy;
begin
  Fdirecionamento.Free;
  inherited;
end; // destructor ...

procedure tdirecionamentosPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'direcionamentosPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "direcionamento" is tManagedStringlist
  if Assigned(Fdirecionamento) then
    for i:=0 to Fdirecionamento.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamentosPedagio_direcionamento));
      ttpDirecionamentoPedagio(Fdirecionamento.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpValores }

function ttpValores.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpValores._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpValores.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fretencoes := ttpImpostos.Create;
end; // constructor ...

constructor ttpValores.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpValores_vlrFrete) then
      vlrFrete :=  xn.text // string
    else if (sn = sntpValores_despesas) then
      despesas := ttpDespesas.Create(xn)
    else if (sn = sntpValores_parcelamento) then
      parcelamento := ttpParcelamento.Create(xn)
    else if (sn = sntpValores_retencoes) then
      Fretencoes := ttpImpostos.Create(xn)
    else if (sn = sntpValores_tipoRateio) then
      tipoRateio :=  xn.text // tbyte
    else if (sn = sntpValores_descontos)
      and ((thisURI='') or (tdescontos._nsURI_ = thisURI)) then
      descontos := tdescontos.Create(xn)
    else if (sn = sntpValores_vlrCombustivel) then
      vlrCombustivel :=  xn.text // string
    else if (sn = sntpValores_vlrPedagio) then
      vlrPedagio :=  xn.text // string
    else if (sn = sntpValores_direcionamentosPedagio)
      and ((thisURI='') or (tdirecionamentosPedagio._nsURI_ = thisURI)) then
      direcionamentosPedagio := tdirecionamentosPedagio.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpValores.Destroy;
begin
  if assigned(Fdespesas) then  Fdespesas.free;
  if assigned(Fparcelamento) then  Fparcelamento.free;
  if assigned(Fretencoes) then  Fretencoes.free;
  Fdescontos.Free;
  FdirecionamentosPedagio.Free;
  inherited;
end; // destructor ...

procedure ttpValores.Setdespesas(value:ttpDespesas);
begin
  Fdespesas := value;
  Fdespesas_IsSet_ := true;
end;

procedure ttpValores.Setparcelamento(value:ttpParcelamento);
begin
  Fparcelamento := value;
  Fparcelamento_IsSet_ := true;
end;

procedure ttpValores.Setdescontos(value:tdescontos);
begin
  Fdescontos := value;
  Fdescontos_IsSet_ := true;
end;

procedure ttpValores.SetvlrCombustivel(value:string);
begin
  FvlrCombustivel := value;
  FvlrCombustivel_IsSet_ := true;
end;

procedure ttpValores.SetvlrPedagio(value:string);
begin
  FvlrPedagio := value;
  FvlrPedagio_IsSet_ := true;
end;

procedure ttpValores.SetdirecionamentosPedagio(value:tdirecionamentosPedagio);
begin
  FdirecionamentosPedagio := value;
  FdirecionamentosPedagio_IsSet_ := true;
end;

procedure ttpValores.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpValores')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpValores_vlrFrete));
  xn.text := FvlrFrete;
  if Assigned(Fdespesas) then
  begin
    xn := aNode.addChildByName(sntpValores_despesas);
    Fdespesas.Save(xn);
  end;
  if Assigned(Fparcelamento) then
  begin
    xn := aNode.addChildByName(sntpValores_parcelamento);
    Fparcelamento.Save(xn);
  end;
  if Assigned(Fretencoes) then
  begin
    xn := aNode.addChildByName(sntpValores_retencoes);
    Fretencoes.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpValores_tipoRateio));
  xn.text := FtipoRateio;
  if Assigned(Fdescontos) then
  begin
    xn := aNode.addChildByName(sntpValores_descontos);
    Fdescontos.Save(xn);
  end;
  if vlrCombustivel_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpValores_vlrCombustivel));
    xn.text := FvlrCombustivel;
  end;
  if vlrPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpValores_vlrPedagio));
    xn.text := FvlrPedagio;
  end;
  if Assigned(FdirecionamentosPedagio) then
  begin
    xn := aNode.addChildByName(sntpValores_direcionamentosPedagio);
    FdirecionamentosPedagio.Save(xn);
  end;
end; // procedure save

{ ttransp }

function ttransp.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttransp._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttransp.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fveiculos := tveiculos.Create;
  Fvalores := ttpValores.Create;
end; // constructor ...

constructor ttransp.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntransp_rntrc) then
      rntrc :=  xn.text // string
    else if (sn = sntransp_infTransportador) then
      infTransportador := ttpTransportador.Create(xn)
    else if (sn = sntransp_gestoraCartao) then
      gestoraCartao :=  xn.text // string
    else if (sn = sntransp_subcontratado) then
      subcontratado := ttpSubcontratado.Create(xn)
    else if (sn = sntransp_rota) then
      Frota := ttpRota.Create(xn)
    else if (sn = sntransp_condutores)
      and ((thisURI='') or (tcondutores._nsURI_ = thisURI)) then
      condutores := tcondutores.Create(xn)
    else if (sn = sntransp_veiculos)
      and ((thisURI='') or (tveiculos._nsURI_ = thisURI)) then
      Fveiculos := tveiculos.Create(xn)
    else if (sn = sntransp_valores) then
      Fvalores := ttpValores.Create(xn)
    else if (sn = sntransp_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttransp.Destroy;
begin
  if assigned(FinfTransportador) then  FinfTransportador.free;
  if assigned(Fsubcontratado) then  Fsubcontratado.free;
  if assigned(Frota) then  Frota.free;
  Fcondutores.Free;
  Fveiculos.Free;
  if assigned(Fvalores) then  Fvalores.free;
  inherited;
end; // destructor ...

procedure ttransp.SetinfTransportador(value:ttpTransportador);
begin
  FinfTransportador := value;
  FinfTransportador_IsSet_ := true;
end;

procedure ttransp.SetgestoraCartao(value:string);
begin
  FgestoraCartao := value;
  FgestoraCartao_IsSet_ := true;
end;

procedure ttransp.Setsubcontratado(value:ttpSubcontratado);
begin
  Fsubcontratado := value;
  Fsubcontratado_IsSet_ := true;
end;

procedure ttransp.Setrota(value:ttpRota);
begin
  Frota := value;
  Frota_IsSet_ := true;
end;

procedure ttransp.Setcondutores(value:tcondutores);
begin
  Fcondutores := value;
  Fcondutores_IsSet_ := true;
end;

procedure ttransp.SetcategoriaPedagio(value:integer);
begin
  FcategoriaPedagio := value;
  FcategoriaPedagio_IsSet_ := true;
end;

procedure ttransp.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'transp')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntransp_rntrc));
  xn.text := Frntrc;
  if Assigned(FinfTransportador) then
  begin
    xn := aNode.addChildByName(sntransp_infTransportador);
    FinfTransportador.Save(xn);
  end;
  if gestoraCartao_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntransp_gestoraCartao));
    xn.text := FgestoraCartao;
  end;
  if Assigned(Fsubcontratado) then
  begin
    xn := aNode.addChildByName(sntransp_subcontratado);
    Fsubcontratado.Save(xn);
  end;
  if Assigned(Frota) then
  begin
    xn := aNode.addChildByName(sntransp_rota);
    Frota.Save(xn);
  end;
  if Assigned(Fcondutores) then
  begin
    xn := aNode.addChildByName(sntransp_condutores);
    Fcondutores.Save(xn);
  end;
  if Assigned(Fveiculos) then
  begin
    xn := aNode.addChildByName(sntransp_veiculos);
    Fveiculos.Save(xn);
  end;
  if Assigned(Fvalores) then
  begin
    xn := aNode.addChildByName(sntransp_valores);
    Fvalores.Save(xn);
  end;
  if categoriaPedagio_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntransp_categoriaPedagio));
    xn.text := IntToStr(FcategoriaPedagio);
  end;
end; // procedure save

{ tinfOT }

function tinfOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fide := tide.Create;
  Fcarga := ttpCarga.Create;
  Ftransp := ttransp.Create;
end; // constructor ...

constructor tinfOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = aninfOT_ID then
      ID := aRoot.attribute[i]; // string
    if sn = aninfOT_gerPgtoFin then
      gerPgtoFin := aRoot.attribute[i]; // tbyte
    if sn = aninfOT_gerPgtoPedagio then
      gerPgtoPedagio := aRoot.attribute[i]; // tbyte
    if sn = aninfOT_impAuto then
      impAuto := aRoot.attribute[i]; // tbyte
    if sn = aninfOT_tipoOp then
      tipoOp := aRoot.attribute[i]; // tbyte
    if sn = aninfOT_utilizaDirecionamentoPedagio then
      utilizaDirecionamentoPedagio := aRoot.attribute[i]; // tbyte
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfOT_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      Fide := tide.Create(xn)
    else if (sn = sninfOT_carga) then
      Fcarga := ttpCarga.Create(xn)
    else if (sn = sninfOT_contatos)
      and ((thisURI='') or (tcontatos._nsURI_ = thisURI)) then
      contatos := tcontatos.Create(xn)
    else if (sn = sninfOT_transp)
      and ((thisURI='') or (ttransp._nsURI_ = thisURI)) then
      Ftransp := ttransp.Create(xn)
    else if (sn = sninfOT_quitacao)
      and ((thisURI='') or (tquitacao._nsURI_ = thisURI)) then
      quitacao := tquitacao.Create(xn)
    else if (sn = sninfOT_adicionais) then
      adicionais := ttpAdicionalImpressao.Create(xn)
    else if (sn = sninfOT_confirmador)
      and ((thisURI='') or (tconfirmador._nsURI_ = thisURI)) then
      confirmador := tconfirmador.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfOT.Destroy;
begin
  Fide.Free;
  if assigned(Fcarga) then  Fcarga.free;
  Fcontatos.Free;
  Ftransp.Free;
  Fquitacao.Free;
  if assigned(Fadicionais) then  Fadicionais.free;
  Fconfirmador.Free;
  inherited;
end; // destructor ...

procedure tinfOT.Setcontatos(value:tcontatos);
begin
  Fcontatos := value;
  Fcontatos_IsSet_ := true;
end;

procedure tinfOT.Setquitacao(value:tquitacao);
begin
  Fquitacao := value;
  Fquitacao_IsSet_ := true;
end;

procedure tinfOT.Setadicionais(value:ttpAdicionalImpressao);
begin
  Fadicionais := value;
  Fadicionais_IsSet_ := true;
end;

procedure tinfOT.Setconfirmador(value:tconfirmador);
begin
  Fconfirmador := value;
  Fconfirmador_IsSet_ := true;
end;

procedure tinfOT.SetID(value:string);
begin
  FID := value;
  FID_IsSet_ := true;
end;

procedure tinfOT.SetgerPgtoFin(value:tbyte);
begin
  FgerPgtoFin := value;
  FgerPgtoFin_IsSet_ := true;
end;

procedure tinfOT.SetgerPgtoPedagio(value:tbyte);
begin
  FgerPgtoPedagio := value;
  FgerPgtoPedagio_IsSet_ := true;
end;

procedure tinfOT.SetimpAuto(value:tbyte);
begin
  FimpAuto := value;
  FimpAuto_IsSet_ := true;
end;

procedure tinfOT.SettipoOp(value:tbyte);
begin
  FtipoOp := value;
  FtipoOp_IsSet_ := true;
end;

procedure tinfOT.SetutilizaDirecionamentoPedagio(value:tbyte);
begin
  FutilizaDirecionamentoPedagio := value;
  FutilizaDirecionamentoPedagio_IsSet_ := true;
end;

procedure tinfOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if ID_IsSet_ then
    aNode.attribute[aninfOT_ID] := FID;
  if gerPgtoFin_IsSet_ then
    aNode.attribute[aninfOT_gerPgtoFin] := FgerPgtoFin;
  if gerPgtoPedagio_IsSet_ then
    aNode.attribute[aninfOT_gerPgtoPedagio] := FgerPgtoPedagio;
  if impAuto_IsSet_ then
    aNode.attribute[aninfOT_impAuto] := FimpAuto;
  if tipoOp_IsSet_ then
    aNode.attribute[aninfOT_tipoOp] := FtipoOp;
  if utilizaDirecionamentoPedagio_IsSet_ then
    aNode.attribute[aninfOT_utilizaDirecionamentoPedagio] := FutilizaDirecionamentoPedagio;

  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(sninfOT_ide);
    Fide.Save(xn);
  end;
  if Assigned(Fcarga) then
  begin
    xn := aNode.addChildByName(sninfOT_carga);
    Fcarga.Save(xn);
  end;
  if Assigned(Fcontatos) then
  begin
    xn := aNode.addChildByName(sninfOT_contatos);
    Fcontatos.Save(xn);
  end;
  if Assigned(Ftransp) then
  begin
    xn := aNode.addChildByName(sninfOT_transp);
    Ftransp.Save(xn);
  end;
  if Assigned(Fquitacao) then
  begin
    xn := aNode.addChildByName(sninfOT_quitacao);
    Fquitacao.Save(xn);
  end;
  if Assigned(Fadicionais) then
  begin
    xn := aNode.addChildByName(sninfOT_adicionais);
    Fadicionais.Save(xn);
  end;
  if Assigned(Fconfirmador) then
  begin
    xn := aNode.addChildByName(sninfOT_confirmador);
    Fconfirmador.Save(xn);
  end;
end; // procedure save

{ ttpOT }

function ttpOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfOT := tinfOT.Create;
  FSignature := tSignature.Create;
end; // constructor ...

constructor ttpOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpOT_infOT)
      and ((thisURI='') or (tinfOT._nsURI_ = thisURI)) then
      FinfOT := tinfOT.Create(xn)
    else if (sn = sntpOT_Signature)
      and ((thisURI='') or (tSignature._nsURI_ = thisURI)) then
      FSignature := tSignature.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpOT.Destroy;
begin
  FinfOT.Free;
  FSignature.Free;
  inherited;
end; // destructor ...

procedure ttpOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FinfOT) then
  begin
    xn := aNode.addChildByName(sntpOT_infOT);
    FinfOT.Save(xn);
  end;
  if Assigned(FSignature) then
  begin
    xn := aNode.addChildByName(sntpOT_Signature);
    FSignature.Save(xn);
  end;
end; // procedure save

{ toperacoes }

function toperacoes.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function toperacoes._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor toperacoes.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FOT := tManagedStringlist.Create;
end; // constructor ...

constructor toperacoes.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snoperacoes_OT) then
    begin
      // list of simple type
      FOT.Add(xn.text);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor toperacoes.Destroy;
begin
  FOT.Free;
  inherited;
end; // destructor ...

procedure toperacoes.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'operacoes')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "OT" is tManagedStringlist
  if Assigned(FOT) then
    for i:=0 to FOT.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snoperacoes_OT));
      ttpOT(FOT.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpLoteOT }

function ttpLoteOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpLoteOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpLoteOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Foperacoes := toperacoes.Create;
end; // constructor ...

constructor ttpLoteOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  for i:=0 to aRoot.attributecount -1 do
  begin
    sn := NamePart(aRoot.attributeName[i]);
    if sn = antpLoteOT_versao then
      versao := aRoot.attribute[i]; // ttoken
    if sn = antpLoteOT_token then
      token := aRoot.attribute[i]; // string
  end;

  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpLoteOT_operacoes)
      and ((thisURI='') or (toperacoes._nsURI_ = thisURI)) then
      Foperacoes := toperacoes.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpLoteOT.Destroy;
begin
  Foperacoes.Free;
  inherited;
end; // destructor ...

procedure ttpLoteOT.Setversao(value:ttoken);
begin
  Fversao := value;
  Fversao_IsSet_ := true;
end;

procedure ttpLoteOT.Settoken(value:string);
begin
  Ftoken := value;
  Ftoken_IsSet_ := true;
end;

procedure ttpLoteOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpLoteOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if versao_IsSet_ then
    aNode.attribute[antpLoteOT_versao] := Fversao;
  if token_IsSet_ then
    aNode.attribute[antpLoteOT_token] := Ftoken;

  if Assigned(Foperacoes) then
  begin
    xn := aNode.addChildByName(sntpLoteOT_operacoes);
    Foperacoes.Save(xn);
  end;
end; // procedure save

{ tdirecionamento_tpResumoDirecionamentosPedagio }

function tdirecionamento_tpResumoDirecionamentosPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdirecionamento_tpResumoDirecionamentosPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdirecionamento_tpResumoDirecionamentosPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tdirecionamento_tpResumoDirecionamentosPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndirecionamento_tpResumoDirecionamentosPedagio_pedagioERP) then
      pedagioERP :=  xn.text // string
    else if (sn = sndirecionamento_tpResumoDirecionamentosPedagio_cpf) then
      cpf :=  xn.text // string
    else if (sn = sndirecionamento_tpResumoDirecionamentosPedagio_rotaERP) then
      rotaERP :=  xn.text // string
    else if (sn = sndirecionamento_tpResumoDirecionamentosPedagio_valor) then
      valor :=  xn.text // string
    else if (sn = sndirecionamento_tpResumoDirecionamentosPedagio_origem) then
      origem :=  xn.text // string
    else if (sn = sndirecionamento_tpResumoDirecionamentosPedagio_destino) then
      destino :=  xn.text // string
    else if (sn = sndirecionamento_tpResumoDirecionamentosPedagio_status) then
      status :=  xn.text // tbyte
    else if (sn = sndirecionamento_tpResumoDirecionamentosPedagio_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdirecionamento_tpResumoDirecionamentosPedagio.Destroy;
begin
  inherited;
end; // destructor ...

procedure tdirecionamento_tpResumoDirecionamentosPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'direcionamento_tpResumoDirecionamentosPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_tpResumoDirecionamentosPedagio_pedagioERP));
  xn.text := FpedagioERP;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_tpResumoDirecionamentosPedagio_cpf));
  xn.text := Fcpf;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_tpResumoDirecionamentosPedagio_rotaERP));
  xn.text := FrotaERP;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_tpResumoDirecionamentosPedagio_valor));
  xn.text := Fvalor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_tpResumoDirecionamentosPedagio_origem));
  xn.text := Forigem;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_tpResumoDirecionamentosPedagio_destino));
  xn.text := Fdestino;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_tpResumoDirecionamentosPedagio_status));
  xn.text := Fstatus;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_tpResumoDirecionamentosPedagio_categoriaPedagio));
  xn.text := IntToStr(FcategoriaPedagio);
end; // procedure save

{ ttpResumoDirecionamentosPedagio }

function ttpResumoDirecionamentosPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpResumoDirecionamentosPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpResumoDirecionamentosPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdirecionamento := tManagedStringlist.Create;
end; // constructor ...

constructor ttpResumoDirecionamentosPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  adirecionamento: tdirecionamento_tpResumoDirecionamentosPedagio;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpResumoDirecionamentosPedagio_direcionamento)
      and ((thisURI='') or (tdirecionamento._nsURI_ = thisURI)) then
    begin
      adirecionamento := tdirecionamento_tpResumoDirecionamentosPedagio.Create(xn);
      Fdirecionamento.AddObject('?', adirecionamento);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpResumoDirecionamentosPedagio.Destroy;
begin
  Fdirecionamento.Free;
  inherited;
end; // destructor ...

procedure ttpResumoDirecionamentosPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpResumoDirecionamentosPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "direcionamento" is tManagedStringlist
  if Assigned(Fdirecionamento) then
    for i:=0 to Fdirecionamento.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpResumoDirecionamentosPedagio_direcionamento));
      tdirecionamento_tpResumoDirecionamentosPedagio(Fdirecionamento.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpInfRetornoConsultaResumoOT }

function ttpInfRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpInfRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpInfRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fide := tide_tpInfRetornoConsultaResumoOT.Create;
  Fautorizacao := ttpAutorizacaoOT.Create;
  Fvalores := ttpRetornoValores.Create;
end; // constructor ...

constructor ttpInfRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpInfRetornoConsultaResumoOT_dataHora) then
      dataHora :=  xn.text // string
    else if (sn = sntpInfRetornoConsultaResumoOT_ide)
      and ((thisURI='') or (tide._nsURI_ = thisURI)) then
      Fide := tide_tpInfRetornoConsultaResumoOT.Create(xn)
    else if (sn = sntpInfRetornoConsultaResumoOT_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpInfRetornoConsultaResumoOT_avisoTransportador) then
      avisoTransportador :=  xn.text // string
    else if (sn = sntpInfRetornoConsultaResumoOT_valores) then
      Fvalores := ttpRetornoValores.Create(xn)
    else if (sn = sntpInfRetornoConsultaResumoOT_pedagio)
      and ((thisURI='') or (tpedagio._nsURI_ = thisURI)) then
      pedagio := tpedagio_tpInfRetornoConsultaResumoOT.Create(xn)
    else if (sn = sntpInfRetornoConsultaResumoOT_direcionamentosPedagio) then
      direcionamentosPedagio := ttpResumoDirecionamentosPedagio.Create(xn)
    else if (sn = sntpInfRetornoConsultaResumoOT_parcelas)
      and ((thisURI='') or (tparcelas._nsURI_ = thisURI)) then
      parcelas := tparcelas_tpInfRetornoConsultaResumoOT.Create(xn)
    else if (sn = sntpInfRetornoConsultaResumoOT_condutores)
      and ((thisURI='') or (tcondutores._nsURI_ = thisURI)) then
      condutores := tcondutores_tpInfRetornoConsultaResumoOT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpInfRetornoConsultaResumoOT.Destroy;
begin
  Fide.Free;
  if assigned(Fautorizacao) then  Fautorizacao.free;
  if assigned(Fvalores) then  Fvalores.free;
  Fpedagio.Free;
  if assigned(FdirecionamentosPedagio) then  FdirecionamentosPedagio.free;
  Fparcelas.Free;
  Fcondutores.Free;
  inherited;
end; // destructor ...

procedure ttpInfRetornoConsultaResumoOT.SetavisoTransportador(value:string);
begin
  FavisoTransportador := value;
  FavisoTransportador_IsSet_ := true;
end;

procedure ttpInfRetornoConsultaResumoOT.Setpedagio(value:tpedagio_tpInfRetornoConsultaResumoOT);
begin
  Fpedagio := value;
  Fpedagio_IsSet_ := true;
end;

procedure ttpInfRetornoConsultaResumoOT.SetdirecionamentosPedagio(value:ttpResumoDirecionamentosPedagio);
begin
  FdirecionamentosPedagio := value;
  FdirecionamentosPedagio_IsSet_ := true;
end;

procedure ttpInfRetornoConsultaResumoOT.Setparcelas(value:tparcelas_tpInfRetornoConsultaResumoOT);
begin
  Fparcelas := value;
  Fparcelas_IsSet_ := true;
end;

procedure ttpInfRetornoConsultaResumoOT.Setcondutores(value:tcondutores_tpInfRetornoConsultaResumoOT);
begin
  Fcondutores := value;
  Fcondutores_IsSet_ := true;
end;

procedure ttpInfRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpInfRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfRetornoConsultaResumoOT_dataHora));
  xn.text := FdataHora;
  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoConsultaResumoOT_ide);
    Fide.Save(xn);
  end;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoConsultaResumoOT_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if avisoTransportador_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpInfRetornoConsultaResumoOT_avisoTransportador));
    xn.text := FavisoTransportador;
  end;
  if Assigned(Fvalores) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoConsultaResumoOT_valores);
    Fvalores.Save(xn);
  end;
  if Assigned(Fpedagio) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoConsultaResumoOT_pedagio);
    Fpedagio.Save(xn);
  end;
  if Assigned(FdirecionamentosPedagio) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoConsultaResumoOT_direcionamentosPedagio);
    FdirecionamentosPedagio.Save(xn);
  end;
  if Assigned(Fparcelas) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoConsultaResumoOT_parcelas);
    Fparcelas.Save(xn);
  end;
  if Assigned(Fcondutores) then
  begin
    xn := aNode.addChildByName(sntpInfRetornoConsultaResumoOT_condutores);
    Fcondutores.Save(xn);
  end;
end; // procedure save

{ ttpRetornoConsultaResumoOT }

function ttpRetornoConsultaResumoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaResumoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaResumoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoConsultaResumoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaResumoOT_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      mensagens := tmensagens_tpRetornoConsultaResumoOT.Create(xn)
    else if (sn = sntpRetornoConsultaResumoOT_envioConsultaResumoOT) then
      envioConsultaResumoOT := ttpInfConsultaResumoOT.Create(xn)
    else if (sn = sntpRetornoConsultaResumoOT_retConsultaResumoOT) then
      retConsultaResumoOT := ttpInfRetornoConsultaResumoOT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaResumoOT.Destroy;
begin
  Fmensagens.Free;
  if assigned(FenvioConsultaResumoOT) then  FenvioConsultaResumoOT.free;
  if assigned(FretConsultaResumoOT) then  FretConsultaResumoOT.free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaResumoOT.Setmensagens(value:tmensagens_tpRetornoConsultaResumoOT);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaResumoOT.SetenvioConsultaResumoOT(value:ttpInfConsultaResumoOT);
begin
  FenvioConsultaResumoOT := value;
  FenvioConsultaResumoOT_IsSet_ := true;
end;

procedure ttpRetornoConsultaResumoOT.SetretConsultaResumoOT(value:ttpInfRetornoConsultaResumoOT);
begin
  FretConsultaResumoOT := value;
  FretConsultaResumoOT_IsSet_ := true;
end;

procedure ttpRetornoConsultaResumoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaResumoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaResumoOT_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(FenvioConsultaResumoOT) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaResumoOT_envioConsultaResumoOT);
    FenvioConsultaResumoOT.Save(xn);
  end;
  if Assigned(FretConsultaResumoOT) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaResumoOT_retConsultaResumoOT);
    FretConsultaResumoOT.Save(xn);
  end;
end; // procedure save

class function ttpRetornoConsultaResumoOT.CreateFromXmlString(
  s: string): ttpRetornoConsultaResumoOT;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := ttpRetornoConsultaResumoOT.Create( parser );
   finally
      parser.Free;
   end;
end;

{ tpraca }

function tpraca.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpraca._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpraca.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tpraca.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpraca_nome) then
      nome :=  xn.text // string
    else if (sn = snpraca_valor) then
      valor :=  xn.text // string
    else if (sn = snpraca_localizacao) then
      localizacao :=  xn.text // string
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpraca.Destroy;
begin
  inherited;
end; // destructor ...

procedure tpraca.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'praca')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpraca_nome));
  xn.text := Fnome;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpraca_valor));
  xn.text := Fvalor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpraca_localizacao));
  xn.text := Flocalizacao;
end; // procedure save

{ tpracas }

function tpracas.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tpracas._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tpracas.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fpraca := tManagedStringlist.Create;
end; // constructor ...

constructor tpracas.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  apraca: tpraca;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snpracas_praca)
      and ((thisURI='') or (tpraca._nsURI_ = thisURI)) then
    begin
      apraca := tpraca.Create(xn);
      Fpraca.AddObject('?', apraca);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tpracas.Destroy;
begin
  Fpraca.Free;
  inherited;
end; // destructor ...

procedure tpracas.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'pracas')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "praca" is tManagedStringlist
  if Assigned(Fpraca) then
    for i:=0 to Fpraca.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snpracas_praca));
      tpraca(Fpraca.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ tdirecionamento }

function tdirecionamento.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tdirecionamento._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tdirecionamento.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor tdirecionamento.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sndirecionamento_pedagioERP) then
      pedagioERP :=  xn.text // string
    else if (sn = sndirecionamento_cpf) then
      cpf :=  xn.text // string
    else if (sn = sndirecionamento_rotaERP) then
      rotaERP :=  xn.text // string
    else if (sn = sndirecionamento_valor) then
      valor :=  xn.text // string
    else if (sn = sndirecionamento_origem) then
      origem :=  xn.text // string
    else if (sn = sndirecionamento_destino) then
      destino :=  xn.text // string
    else if (sn = sndirecionamento_pracas)
      and ((thisURI='') or (tpracas._nsURI_ = thisURI)) then
      pracas := tpracas.Create(xn)
    else if (sn = sndirecionamento_status) then
      status :=  xn.text // tbyte
    else if (sn = sndirecionamento_categoriaPedagio) then
      categoriaPedagio := StrToIntDef(xn.text, 0)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tdirecionamento.Destroy;
begin
  Fpracas.Free;
  inherited;
end; // destructor ...

procedure tdirecionamento.Setpracas(value:tpracas);
begin
  Fpracas := value;
  Fpracas_IsSet_ := true;
end;

procedure tdirecionamento.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'direcionamento')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_pedagioERP));
  xn.text := FpedagioERP;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_cpf));
  xn.text := Fcpf;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_rotaERP));
  xn.text := FrotaERP;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_valor));
  xn.text := Fvalor;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_origem));
  xn.text := Forigem;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_destino));
  xn.text := Fdestino;
  if Assigned(Fpracas) then
  begin
    xn := aNode.addChildByName(sndirecionamento_pracas);
    Fpracas.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_status));
  xn.text := Fstatus;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sndirecionamento_categoriaPedagio));
  xn.text := IntToStr(FcategoriaPedagio);
end; // procedure save

{ ttpDirecionamentosPedagio }

function ttpDirecionamentosPedagio.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpDirecionamentosPedagio._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpDirecionamentosPedagio.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fdirecionamento := tManagedStringlist.Create;
end; // constructor ...

constructor ttpDirecionamentosPedagio.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
  adirecionamento: tdirecionamento;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpDirecionamentosPedagio_direcionamento)
      and ((thisURI='') or (tdirecionamento._nsURI_ = thisURI)) then
    begin
      adirecionamento := tdirecionamento.Create(xn);
      Fdirecionamento.AddObject('?', adirecionamento);
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpDirecionamentosPedagio.Destroy;
begin
  Fdirecionamento.Free;
  inherited;
end; // destructor ...

procedure ttpDirecionamentosPedagio.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpDirecionamentosPedagio')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "direcionamento" is tManagedStringlist
  if Assigned(Fdirecionamento) then
    for i:=0 to Fdirecionamento.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpDirecionamentosPedagio_direcionamento));
      tdirecionamento(Fdirecionamento.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoConsultaAlteracao }

function ttpRetornoConsultaAlteracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaAlteracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaAlteracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fautorizacao := ttpAutorizacaoOT.Create;
  Fide := ttpRetornoIdentificacao.Create;
  Fvalores := ttpRetornoValores.Create;
end; // constructor ...

constructor ttpRetornoConsultaAlteracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaAlteracao_dataHora) then
      dataHora :=  xn.text // string
    else if (sn = sntpRetornoConsultaAlteracao_autorizacao) then
      Fautorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sntpRetornoConsultaAlteracao_ide) then
      Fide := ttpRetornoIdentificacao.Create(xn)
    else if (sn = sntpRetornoConsultaAlteracao_valores) then
      Fvalores := ttpRetornoValores.Create(xn)
    else if (sn = sntpRetornoConsultaAlteracao_pedagio) then
      pedagio := ttpRetornoPedagio.Create(xn)
    else if (sn = sntpRetornoConsultaAlteracao_direcionamentosPedagio) then
      direcionamentosPedagio := ttpDirecionamentosPedagio.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaAlteracao.Destroy;
begin
  if assigned(Fautorizacao) then  Fautorizacao.free;
  if assigned(Fide) then  Fide.free;
  if assigned(Fvalores) then  Fvalores.free;
  if assigned(Fpedagio) then  Fpedagio.free;
  if assigned(FdirecionamentosPedagio) then  FdirecionamentosPedagio.free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaAlteracao.Setpedagio(value:ttpRetornoPedagio);
begin
  Fpedagio := value;
  Fpedagio_IsSet_ := true;
end;

procedure ttpRetornoConsultaAlteracao.SetdirecionamentosPedagio(value:ttpDirecionamentosPedagio);
begin
  FdirecionamentosPedagio := value;
  FdirecionamentosPedagio_IsSet_ := true;
end;

procedure ttpRetornoConsultaAlteracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaAlteracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sntpRetornoConsultaAlteracao_dataHora));
  xn.text := FdataHora;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaAlteracao_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaAlteracao_ide);
    Fide.Save(xn);
  end;
  if Assigned(Fvalores) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaAlteracao_valores);
    Fvalores.Save(xn);
  end;
  if Assigned(Fpedagio) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaAlteracao_pedagio);
    Fpedagio.Save(xn);
  end;
  if Assigned(FdirecionamentosPedagio) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaAlteracao_direcionamentosPedagio);
    FdirecionamentosPedagio.Save(xn);
  end;
end; // procedure save

class function ttpRetornoConsultaAlteracao.CreateFromXmlString(
  s: string): ttpRetornoConsultaAlteracao;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := ttpRetornoConsultaAlteracao.Create( parser );
   finally
      parser.Free;
   end;
end;

{ ttpRetornoAlteracao }

function ttpRetornoAlteracao.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoAlteracao._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoAlteracao.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoAlteracao.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoAlteracao_mensagens)
      and ((thisURI='') or (tmensagens._nsURI_ = thisURI)) then
      mensagens := tmensagens.Create(xn)
    else if (sn = sntpRetornoAlteracao_alteracao) then
      alteracao := ttpRetornoConsultaAlteracao.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoAlteracao.Destroy;
begin
  Fmensagens.Free;
  if assigned(Falteracao) then  Falteracao.free;
  inherited;
end; // destructor ...

procedure ttpRetornoAlteracao.Setmensagens(value:tmensagens);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoAlteracao.Setalteracao(value:ttpRetornoConsultaAlteracao);
begin
  Falteracao := value;
  Falteracao_IsSet_ := true;
end;

procedure ttpRetornoAlteracao.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoAlteracao')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoAlteracao_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(Falteracao) then
  begin
    xn := aNode.addChildByName(sntpRetornoAlteracao_alteracao);
    Falteracao.Save(xn);
  end;
end; // procedure save

class function ttpRetornoAlteracao.CreateFromXmlString(
  s: string): ttpRetornoAlteracao;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := ttpRetornoAlteracao.Create( parser );
   finally
      parser.Free;
   end;
end;

{ tinfOT_tpRetornoOT }

function tinfOT_tpRetornoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function tinfOT_tpRetornoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor tinfOT_tpRetornoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  Fmensagem := ttpMensagem.Create;
  Fide := ttpRetornoIdentificacao.Create;
end; // constructor ...

constructor tinfOT_tpRetornoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sninfOT_tpRetornoOT_mensagem) then
      Fmensagem := ttpMensagem.Create(xn)
    else if (sn = sninfOT_tpRetornoOT_mensagems) then
      Fmensagems := tmensagens_tpRetornoConsultaANTT.Create( xn )
    else if (sn = sninfOT_tpRetornoOT_dataHora) then
      dataHora :=  xn.text // string
    else if (sn = sninfOT_tpRetornoOT_ide) then
      Fide := ttpRetornoIdentificacao.Create(xn)
    else if (sn = sninfOT_tpRetornoOT_autorizacao) then
      autorizacao := ttpAutorizacaoOT.Create(xn)
    else if (sn = sninfOT_tpRetornoOT_avisoTransportador) then
      avisoTransportador :=  xn.text // string
    else if (sn = sninfOT_tpRetornoOT_valores) then
      valores := ttpRetornoValores.Create(xn)
    else if (sn = sninfOT_tpRetornoOT_pedagio)
      and ((thisURI='') or (tpedagio._nsURI_ = thisURI)) then
      pedagio := tpedagio.Create(xn)
    else if (sn = sninfOT_tpRetornoOT_direcionamentosPedagio) then
      direcionamentosPedagio := ttpDirecionamentosPedagio.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor tinfOT_tpRetornoOT.Destroy;
begin
  if assigned(Fmensagem) then  Fmensagem.free;
  if assigned(Fide) then  Fide.free;
  if assigned(Fautorizacao) then  Fautorizacao.free;
  if assigned(Fvalores) then  Fvalores.free;
  Fpedagio.Free;
  if assigned(FdirecionamentosPedagio) then  FdirecionamentosPedagio.free;
  if assigned(Fmensagems) then  Fmensagems.free;
  inherited;
end; // destructor ...

procedure tinfOT_tpRetornoOT.Setautorizacao(value:ttpAutorizacaoOT);
begin
  Fautorizacao := value;
  Fautorizacao_IsSet_ := true;
end;

procedure tinfOT_tpRetornoOT.SetavisoTransportador(value:string);
begin
  FavisoTransportador := value;
  FavisoTransportador_IsSet_ := true;
end;

procedure tinfOT_tpRetornoOT.Setvalores(value:ttpRetornoValores);
begin
  Fvalores := value;
  Fvalores_IsSet_ := true;
end;

procedure tinfOT_tpRetornoOT.Setpedagio(value:tpedagio);
begin
  Fpedagio := value;
  Fpedagio_IsSet_ := true;
end;

procedure tinfOT_tpRetornoOT.SetdirecionamentosPedagio(value:ttpDirecionamentosPedagio);
begin
  FdirecionamentosPedagio := value;
  FdirecionamentosPedagio_IsSet_ := true;
end;

procedure tinfOT_tpRetornoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'infOT_tpRetornoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagem) then
  begin
    xn := aNode.addChildByName(sninfOT_tpRetornoOT_mensagem);
    Fmensagem.Save(xn);
  end;
  xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfOT_tpRetornoOT_dataHora));
  xn.text := FdataHora;
  if Assigned(Fide) then
  begin
    xn := aNode.addChildByName(sninfOT_tpRetornoOT_ide);
    Fide.Save(xn);
  end;
  if Assigned(Fautorizacao) then
  begin
    xn := aNode.addChildByName(sninfOT_tpRetornoOT_autorizacao);
    Fautorizacao.Save(xn);
  end;
  if avisoTransportador_IsSet_ then
  begin
    xn := aNode.addChildByName(nsName(_NameSpaceAlias, sninfOT_tpRetornoOT_avisoTransportador));
    xn.text := FavisoTransportador;
  end;
  if Assigned(Fvalores) then
  begin
    xn := aNode.addChildByName(sninfOT_tpRetornoOT_valores);
    Fvalores.Save(xn);
  end;
  if Assigned(Fpedagio) then
  begin
    xn := aNode.addChildByName(sninfOT_tpRetornoOT_pedagio);
    Fpedagio.Save(xn);
  end;
  if Assigned(FdirecionamentosPedagio) then
  begin
    xn := aNode.addChildByName(sninfOT_tpRetornoOT_direcionamentosPedagio);
    FdirecionamentosPedagio.Save(xn);
  end;
end; // procedure save

{ ttpRetornoOT }

function ttpRetornoOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FinfOT := tinfOT_tpRetornoOT.Create;
end; // constructor ...

constructor ttpRetornoOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoOT_infOT)
      and ((thisURI='') or (tinfOT._nsURI_ = thisURI)) then
      FinfOT := tinfOT_tpRetornoOT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoOT.Destroy;
begin
  FinfOT.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(FinfOT) then
  begin
    xn := aNode.addChildByName(sntpRetornoOT_infOT);
    FinfOT.Save(xn);
  end;
end; // procedure save

{ toperacoes_tpRetornoConsultaLoteOT }

function toperacoes_tpRetornoConsultaLoteOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function toperacoes_tpRetornoConsultaLoteOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor toperacoes_tpRetornoConsultaLoteOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
  FOT := tManagedStringlist.Create;
end; // constructor ...

constructor toperacoes_tpRetornoConsultaLoteOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  Create;

  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = snoperacoes_tpRetornoConsultaLoteOT_OT) then
    begin
      FOT.AddObject( '?', ttpRetornoOT.Create( xn ) );
    end
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor toperacoes_tpRetornoConsultaLoteOT.Destroy;
begin
  FOT.Free;
  inherited;
end; // destructor ...

procedure toperacoes_tpRetornoConsultaLoteOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'operacoes_tpRetornoConsultaLoteOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  // element "OT" is tManagedStringlist
  if Assigned(FOT) then
    for i:=0 to FOT.Count - 1 do
    begin
      xn := aNode.addChildByName(nsName(_NameSpaceAlias, snoperacoes_tpRetornoConsultaLoteOT_OT));
      ttpRetornoOT(FOT.Objects[i]).Save(xn);
    end; // for i:=0 to ...
end; // procedure save

{ ttpRetornoConsultaLoteOT }

function ttpRetornoConsultaLoteOT.GetAsString: string;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      self.Save( parser );
      parser.formatedXML := False;
      parser.XMLTag      := False;
      result := parser.xml;
   finally
      parser.Free;
   end;
end;

class function ttpRetornoConsultaLoteOT._nsURI_;
begin
  result := thisNameSpaceURI;
end; // class function _nsURI_

constructor ttpRetornoConsultaLoteOT.Create;
begin
  inherited;
  _NamespaceAlias := defNamespaceAlias;
end; // constructor ...

constructor ttpRetornoConsultaLoteOT.Create(aRoot:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  sn: string;
  i: integer;
  thisURI: string;
begin
  inherited create;
  F_NameSpaceAlias := aRoot.NameSpace;
  xn := aRoot.FirstChild;
  while Assigned(xn) do
  begin
    sn := NamePart(xn.name);
    thisURI := xn.namespaceURI;
    if (sn = sntpRetornoConsultaLoteOT_mensagens) then
      mensagens := ttpMensagemErro.Create(xn)
    else if (sn = sntpRetornoConsultaLoteOT_operacoes)
      and ((thisURI='') or (toperacoes._nsURI_ = thisURI)) then
      operacoes := toperacoes_tpRetornoConsultaLoteOT.Create(xn)
    else;
    xn := xn.NextSibling;
  end; // while Assigned(xn) do ...
end; // constructor ...

destructor ttpRetornoConsultaLoteOT.Destroy;
begin
  if assigned(Fmensagens) then  Fmensagens.free;
  Foperacoes.Free;
  inherited;
end; // destructor ...

procedure ttpRetornoConsultaLoteOT.Setmensagens(value:ttpMensagemErro);
begin
  Fmensagens := value;
  Fmensagens_IsSet_ := true;
end;

procedure ttpRetornoConsultaLoteOT.Setoperacoes(value:toperacoes_tpRetornoConsultaLoteOT);
begin
  Foperacoes := value;
  Foperacoes_IsSet_ := true;
end;

procedure ttpRetornoConsultaLoteOT.Save(aNode:tJanXMLNode2);
var
  xn: tJanXMLNode2;
  i: integer;
begin
  if aNode.name = '' then
    aNode.name := nsName(_NameSpaceAlias, 'tpRetornoConsultaLoteOT')
  else if pos(colon, aNode.name) = 0 then
    aNode.name := nsName(_NameSpaceAlias, aNode.name);

  if _NameSpaceAlias <> '' then
  begin
    xn := aNode;
    while Assigned(xn.ParentNode) do
      xn := xn.ParentNode;
    xn.attribute['xmlns:' + _NameSpaceAlias] := thisNameSpaceURI;
  end;

  if Assigned(Fmensagens) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaLoteOT_mensagens);
    Fmensagens.Save(xn);
  end;
  if Assigned(Foperacoes) then
  begin
    xn := aNode.addChildByName(sntpRetornoConsultaLoteOT_operacoes);
    Foperacoes.Save(xn);
  end;
end; // procedure save

class function ttpRetornoConsultaLoteOT.CreateFromXmlString(
  s: string): ttpRetornoConsultaLoteOT;
var
  parser : TjanXMLParser2;
begin
   parser := TjanXMLParser2.create;
   try
      parser.xml := s;
      result := ttpRetornoConsultaLoteOT.Create( parser );
   finally
      parser.Free;
   end;
end;
{ tBaseNddWS }

constructor tBaseNddWS.Create;
begin
  inherited;
  if FindCmdLineSwitch('debug', ['-'], True ) then
  begin
     EnterCriticalSection(CritSect);
     try
        tBaseNddWS_class_var_Refs.AddObject( Self.ClassName, self );
     finally
        LeaveCriticalSection(CritSect);
     end;
  end;
  //Inc(tBaseNddWS_class_var_Refs);
end;

destructor tBaseNddWS.destroy;
begin
  //dec(tBaseNddWS_class_var_Refs);

  if FindCmdLineSwitch('debug', ['-'], True ) then
  begin
     EnterCriticalSection(CritSect);
     try
        tBaseNddWS_class_var_Refs.Delete(  tBaseNddWS_class_var_Refs.IndexOfObject( self ) );
     finally
        LeaveCriticalSection(CritSect);
     end;
  end;
  inherited;
end;

initialization
//   tBaseNddWS_class_var_Refs := 0;
   InitializeCriticalSection(CritSect);
   tBaseNddWS_class_var_Refs := TStringList.Create;
finalization
   DeleteCriticalSection(CritSect);
   if tBaseNddWS_class_var_Refs.Count <> 0 then
   begin
      tBaseNddWS_class_var_Refs.SaveToFile( 'dump.txt'  );
      tBaseNddWS_class_var_Refs.Free;
      //raise Exception.Create( 'Estouro de memorio com '+intToStr(tBaseNddWS_class_var_Refs) );
   end;

end.
